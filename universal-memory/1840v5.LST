Turbo Assembler	 Version 5.0	    11-17-21 18:28:28	    Page 1
1840v5.asm



			     ;This source code made by Gleb Larionov, Prague.
			     ;Changed by Leonid	Yadrennikov, Tyumen.
			     ;v1 - 05.10.2021 -	ros_checksum removed, ES1841 memory switching-on added
			     ;v2 - 13.10.2021 -	int vector table loader	and table itself shortened (like in PCBIOSv3),
			     ;			BX register in STGTST is free
			     ;___________________
			     ; v4 - ??/??/???? (Other version than 24/04/1981) новая клавиатура
			     ;	БАЗОВАЯ СИСТЕМА ВВОДА/ВЫВОДА (БСУВВ)
			     ;___________________
      =0060		     port_a  equ     60h
      =F000		     cod     equ     0f000h
      =0040		     dat     equ     0040h
      =0030		     sta     equ     0030h
      =0050		     xxdat   equ     0050h
      =B800		     video_ra equ    0b800h
      =0061		     port_b  equ     61h
      =0062		     port_c  equ     62h
      =0063		     cmd_port equ    63h
      =0020		     inta00  equ     20h
      =0021		     inta01  equ     21h
      =0020		     eoi     equ     20h
      =0040		     timer   equ     40h
      =0043		     tim_ctl equ     43h
      =0040		     timero  equ     40h
      =0001		     tmint   equ     01
      =0008		     dma08   equ     08
      =0000		     dma     equ     00
      =0540		     max_period	equ  540h
      =0410		     min_period	equ  410h
      =0060		     kbd_in  equ     60h
      =0002		     kbdint  equ     02
      =0060		     kb_dat  equ     60h
      =0061		     kb_ctl  equ     61h
			     ;_______________
			     ;	Расположение прерываний 8086
			     ;_________________________
0000			     abs0    segment para
0000			     zb	     label   byte
0000			     zw	     label   word
0000			     stg_loc0 label  byte
				     org     2*4
0008			     nmi_ptr label   word
				     org     5*4
0014			     int5_ptr label  word
				     org     8*4
0020			     int_addr label  word
0020			     int_ptr label   dword
				     org     0dh*4
0034			     hdisk_int	label  dword
				     org     10h*4
0040			     video_int label word
				     org     13h*4
004C			     org_vector	 label	dword
				     org     19h*4
0064			     boot_vec  label  dword
				     org     1dh*4
0074			     parm_ptr label  dword
				     org     01eh*4
0078			     disk_pointer label	dword
0078			     diskette_parm  label  dword
				     org     01fh*4
007C			     ext_ptr label   dword
				     org     040h*4
0100			     disk_vector  label	 dword
				     org     041h*4

0104			     hf_tbl_vec	 label	dword
				     org     410h
0410			     eq_fl   label   byte

				     org     413h
0413			     mem_siz label   word
				     org     472h
0472			     res_fl  label   word
				     org     4d0h
04D0			     csi     label   word
				     org     4e0h
04E0			     tabl1   label   word
				     org     7c00h
7C00			     boot_locn label far
7C00			     abs0    ends

			     ;______________________
			     ;	Использование стека только во	время	       +
			     инициализации
			     ;______________________
0000			     stac    segment para stack
0000  80*(????)			     dw	     128 dup(?)



0100			     tos     label   word
0100			     stac    ends

			     ;______________________
			     ;	Область данных ПЗУ
			     ;____________________
0000			     data segment    para
0000  04*(????)		     rs232_base	dw 4 dup(?)



0008  04*(????)		     printer_base dw 4 dup(?)



0010  ????		     equip_flag	dw ?
0012  ??		     mfg_tst db	     ?
0013  ????		     memory_size dw  ?
0015  ????		     io_ram_size dw  ?
			     ;_______________
			     ;	Область данных клавиатуры
			     ;_________________
0017  ??		     kb_flag db	     ?

			     ;	Размещение флажков в kb_flag

      =0080		     ins_state equ   80h
      =0040		     caps_state	equ  40h
      =0020		     num_state equ   20h
      =0010		     scroll_state equ 10h
      =0008		     alt_shift equ   08h
      =0004		     ctl_shift equ   04h
      =0002		     left_shift	equ  02h
      =0001		     right_shift equ 01h

0018  ??		     kb_flag_1 db    ?

      =0080		     ins_shift equ   80h
      =0040		     caps_shift	equ  40h
      =0020		     num_shift equ   20h
      =0010		     scroll_shift equ 10h
      =0008		     hold_state	equ  08h
      =0004		     inv_shift equ   04h
      =0002		     lat	     equ     02h
      =0001		     lat_shift	     equ     01h



0019  ??		     alt_input db    ?
001A  ????		     buffer_head dw  ?
001C  ????		     buffer_tail dw  ?
001E  10*(????)		     kb_buffer dw    16	dup(?)



003E			     kb_buffer_end label word

			     ;	head=tail указывает на заполнение буфера

      =0045		     num_key equ     69
      =0046		     scroll_key	equ  70
      =0038		     alt_key equ     56
      =001D		     ctl_key equ     29
      =0056		     caps_key equ    86
      =0054		     left_key equ    84
      =0055		     right_key equ   85
      =0052		     ins_key equ     82
      =0053		     del_key equ     83
      =0059		     inf_key   equ   89
      =0058		     inv_key_l	equ  88
      =005A		     inv_key_r equ   90
      =005B		     rus_key	equ  91
      =0057		     lat_key equ     87

			     ;____________________
			     ;	Область данных НГМД
			     ;____________________
003E  ??		     seek_status db  ?
			     ;
			     ;
      =0080		     int_flag equ    080h
003F  ??		     motor_status db ?
			     ;
			     ;
0040  ??		     motor_count db  ?
      =0025		     motor_wait	equ  37

			     ;
0041  ??		     diskette_status db	?
      =0080		     time_out equ    80h
      =0040		     bad_seek equ    40h
      =0020		     bad_nec  equ    20h
      =0010		     bad_crc  equ    10h
      =0009		     dma_boundary equ 09h
      =0008		     bad_dma  equ    08h
      =0004		     record_not_fnd equ	04h
      =0003		     write_protect equ 03h
      =0002		     bad_addr_mark equ 02h
      =0001		     bad_cmd equ     01h

0042			     cmd_block	label  byte
0042			     hd_error  label  byte
0042  07*(??)		     nec_status	db   7 dup(?)




			     ;_____________________
			     ;	Область данных ЭЛИ
			     ;_____________________
0049  ??		     crt_mode db     ?
004A  ????		     crt_cols dw     ?
004C  ????		     crt_len  dw     ?
004E  ????		     crt_start dw    ?
0050  08*(????)		     cursor_posn dw  8 dup(?)



0060  ????		     cursor_mode dw  ?
0062  ??		     active_page db  ?
0063  ????		     addr_6845 dw    ?
0065  ??		     crt_mode_set db ?
0066  ??		     crt_pallette db ?

			     ;___________________
			     ;	Область данных НМД
			     ;___________________
0067  ????		     io_rom_init dw  ?
0069  ????		     io_rom_seg	dw   ?
006B  ??		     last_val db     ?

			     ;___________________
			     ;	Область данных таймера
			     ;___________________
006C  ????		     timer_low dw    ?
006E  ????		     timer_high	dw   ?
0070  ??		     timer_ofl db    ?
			     ;___________________
			     ;	Область данных системы
			     ;___________________
0071  ??		     bios_break	db   ?
0072  ????		     reset_flag	dw   ?
0074  ??		     diskw_status  db  ?
0075  ??		     hf_num  db	  ?
0076  ??		     control_byte  db  ?
0077  ??		     port_off  db  ?
					     org     7ch
007C			     stat_offset     label   byte ; смещение для хранения	       +
			     состояний	модема

				     org     80h
0080  ????		     buffer_start    dw	     ?
0082  ????		     buffer_end	     dw	     ?
				     org     0090h
0090  ????		     idnpol  dw	     ?
				     org     0e0h
00E0			     tabl    label   word

				     org     3ff0h
3FF0			     tmp_tos label   word
			     ;
3FF0			     data    ends

			     ;___________________
			     ;	Область расширения данных
			     ;_________________________________
0000			     xxdata segment  para
0000  ??		     status_byte db  ?
0001			     xxdata  ends

			     ;_________________
			     ;	Буфер ЭЛИ
			     ;___________________
0000			     video_ram segment para
0000			     regen   label   byte
0000			     regenw  label   word
0000  4000*(??)			     db	     16384 dup(?)



4000			     video_ram ends
			     ;____________________
			     ;	Основной массив в ПЗУ	(сегмент	code)
			     ;____________________

0000			     code segment para

					     org 0E000h

E000  35 37 30 30 30 35	31+  a5700051Copr_Ib db	'5700051 copr. ibm 1981'
      20 63 6F 70 72 2E	20+
      69 62 6D 20 31 39	38+
      31
E016  E0EAr		     c1		     dw	offset c11	     ; адрес    возврата
E018  E1F6r		     caw	     dw	offset ca3
				     assume cs:code,ss:code,es:abs0,ds:data

E01A			     stgtst:
E01A  B9 2000				     mov     cx,4000h/2		     ;rc 2x less because 16bit	       +
			     (by-word) testing

E01D			     stgtst_cnt	     proc    near
E01D  FC				     cld
E01E  8E D9				     mov     ds, cx
E020  B8 FFFF				     mov     ax, 0FFFFh
E023  BA AA55				     mov     dx, 0AA55h
E026  2B FF				     sub     di, di
E028  F3> AB				     repe stosw

E02A			     c2a:
E02A  4F				     dec     di
E02B  4F				     dec     di
E02C  FD				     std

E02D			     c2b:
E02D  8B F7				     mov     si, di
E02F  8C D9				     mov     cx, ds
			     ;---------------rc:
E031  8A FC				     mov     bh, ah
E033  8A DF				     mov     bl, bh	     ;rc now old pattern is in BX

E035			     c3:
E035  26				     db	     26h	     ;rc ES segment prefix
E036  AD				     lodsw
E037  33 C3				     xor     ax, bx
E039  75 29				     jnz     c4			     ;rc if error, make	it 8bit	       +
			     compartible
E03B  E4 62				     in	     al, 62h
E03D  24 40				     and     al, 40h
E03F  B0 00				     mov     al, 0
E041  75 28				     jnz     c7x
E043  83 FB 00				     cmp     bx, 0
E046  74 05				     jz	     c3a
E048  8A C2				     mov     al, dl
E04A  8A E0				     mov     ah, al	     ;rc now new pattern is in AX
E04C  AB				     stosw

E04D			     c3a:
E04D  E2 E6				     loop    c3
E04F  83 FB 00				     cmp     bx, 0
E052  74 17				     jz	     c7x
E054  8B D8				     mov     bx, ax
E056  86 F2				     xchg    dh, dl
E058  FC				     cld
E059  47				     inc     di
E05A  47				     inc     di
E05B  74 D0				     jz	     c2b
E05D  4F				     dec     di
E05E  4F				     dec     di
E05F  BA 0001				     mov     dx, 1
E062  EB C6				     jmp     short c2a

E064			     c4:					     ;rc make 16-bit test result 8-bit +
			     (old) error processing compartible
E064  3C 00				     cmp al,0
E066  75 03				     jne c7x		     ;rc L-byte	- proceed as usual, precerving +
			     NZ	flag
E068  8A C4				     mov al,ah		     ;rc else make compartible with 8bit
E06A  4F				     dec di		     ;rc set DI	to even	address	and NZ flag
E06B			     c7x:
E06B  C3				     retn
E06C			     stgtst_cnt	     endp


			     ;____________________
			     ;	Сброс системы - фаза 1
			     ;____________________
			     ;_____________________
			     ;	Проверка 16К памяти
			     ;_____________________
			     ;___________________
			     ;	ТЕСТ.01
			     ;	     Тест процессора 8086. Осуществляет	       +
			     проверку регистра
			     ;	     признаков, команд перехода и		       +
			     считывания-записи
			     ;	     общих	и сегментных	регистров.
			     ;_____________________________________
E06C			     reset   label   near
E06C  FA		     start:  cli		     ; сброс признака разрешения+
			     прерывания
E06D  B4 D5			     mov     ah,0d5h	     ;уст признаки SF,CF,ZF,AF
E06F  9E			     sahf
E070  73 4E			     jnc     err01	     ;CF=0,в программу ошибок
E072  75 4C			     jnz     err01	     ;ZF=0,в программу ошибок
E074  7B 4A			     jnp     err01	     ;PF=0,в программу ошибок
E076  79 48			     jns     err01	     ;SF=0,в программу ошибок
E078  9F			     lahf		     ;загрузить признаки в AH
E079  B1 05			     mov     cl,5	     ;загрузить счетчик
E07B  D2 EC			     shr     ah,cl	     ;выделить бит переноса
E07D  73 41			     jnc     err01	     ;признак AF=0
E07F  B0 40			     mov     al,40h	     ;уст признак переполнения
E081  D0 E0			     shl     al,1	     ;уст для контроля
E083  71 3B			     jno     err01	     ;признак OF	не уст
E085  32 E4			     xor     ah,ah	     ;уст AH=0
E087  9E			     sahf		     ;уст в	исходное состояние SF,+
			     CF,ZF,PF
E088  72 36			     jc	     err01	     ;признак CF=1
E08A  74 34			     jz	     err01	     ;признак ZF=1
E08C  78 32			     js	     err01	     ;признак SF=1
E08E  7A 30			     jp	     err01	     ;признак PF=1
E090  9F			     lahf		     ;загрузить признаки в AH
E091  B1 05			     mov     cl,5	     ;загрузить счетчик
E093  D2 EC			     shr     ah,cl	     ;выделить бит переноса
E095  72 29			     jc	     err01	     ;признак IF=1
E097  D0 E4			     shl     ah,1	     ;контроль,	что OF сброшен
E099  70 25			     jo	     err01
E09B  B8 FFFF			     mov     ax,0ffffh	     ;уст эталона в AX
E09E  F9			     stc
E09F  8E D8		     c8:     mov     ds,ax	     ;запись во	все регистры
E0A1  8C DB			     mov     bx,ds
E0A3  8E C3			     mov     es,bx
E0A5  8C C1			     mov     cx,es
E0A7  8E D1			     mov     ss,cx
E0A9  8C D2			     mov     dx,ss
E0AB  8B E2			     mov     sp,dx
E0AD  8B EC			     mov     bp,sp
E0AF  8B F5			     mov     si,bp
E0B1  8B FE			     mov     di,si
E0B3  73 07			     jnc     c9
E0B5  33 C7			     xor     ax,di	     ;проверка всех	регистров
							     ;эталонами "FFFF", "0000"
E0B7  75 07			     jnz     err01
E0B9  F8			     clc
E0BA  73 E3			     jnc     c8
E0BC			     c9:
E0BC  0B C7			     or	     ax,di	     ;нулевым шаблоном все	       +
			     регистры проверены ?
E0BE  74 02			     jz	     c10	     ;ДА - переход к следующему    +
			     тесту
E0C0  EB AA		     err01:  jmp   short  start
			     ;_______________________
			     ; ТЕСТ.02
			     ;_______________________
E0C2			     c10:
E0C2  B0 00			     mov     al,0	     ;запретить прерывaния NMI
E0C4  E6 A0			     out     0a0h,al
E0C6  E6 83			     out     83h,al	     ;инициализация регистрa       +
			     страниц ПДП
E0C8  B0 99			     mov     al,99h	     ;уст A,C -ввод, B -	вывод
E0CA  E6 63			    out	     cmd_port,al	     ;запись в регистр	       +
			     режима
								     ;трехканального порта
E0CC  B0 FC			     mov     al,0fch		     ;блокировка контроля    +
			     по четности
E0CE  E6 61			     out     port_b,al
E0D0  2A C0			     sub     al,al
E0D2  BA 03D8			     mov     dx,3d8h
E0D5  EE			     out     dx,al	     ;блокировка цветного ЭЛИ
E0D6  FE C0			     inc     al
E0D8  BA 03B8			     mov     dx,3b8h
E0DB  EE			     out     dx,al	     ;блокировка черно-белого     +
			     ЭЛИ
E0DC  B8 F000			     mov     ax,cod	     ;уст сегментного регистра SS
E0DF  8E D0			     mov     ss,ax
E0E1  BB E000			     mov     bx,0e000h		     ;уст начального адреса +
			     памяти
E0E4  BC E016r			     mov     sp,offset c1	     ;уст адреса возврата
E0E7  EB 03			     jmp     short ros
E0E9  90				     nop
E0EA  75 D4		     c11:    jne     err01
			     ;------------------------
			     ;	ТЕСТ.03
			     ;	 Осуществляет проверку, инициализацию и      +
			     запуск ПДП и
			     ; таймера 1	для регенерации памяти
			     ;_________________________
			     ;	 Блокировка контроллера ПДП

E0EC  B0 04		     ros:    mov     al,04
E0EE  E6 08			     out     dma08,al

			     ;	 Проверка правильности функционирования
			     ;	 таймера	1

E0F0  B0 54			     mov     al,54h	     ;выбор таймера	1,LSB, режим 2
E0F2  E6 43			     out     timer+3,al
E0F4  2B C9			     sub     cx,cx
E0F6  8A D9			     mov     bl,cl
E0F8  8A C1			     mov     al,cl	     ;уст начального счетчика     +
			     таймера в 0
E0FA  E6 41			     out     timer+1,al
E0FC			     c12:
E0FC  B0 40			     mov     al,40h
E0FE  E6 43			     out     timer+3,al
E100  E4 41			     in	     al,timer+1	     ;считывание счетчика	       +
			     таймера 1
E102  0A D8			     or	     bl,al	     ;все биты таймера включены ?
E104  80 FB FF			     cmp     bl,0ffh	     ;ДА - сравнение	с FF
E107  74 04			     je	     c13	     ;биты таймера сброшены
E109  E2 F1			     loop    c12	     ;биты таймера установлены
E10B  EB B3			     jmp     short err01     ;сбой таймера 1, останов	       +
			     системы
E10D			     c13:
E10D  8A C3			     mov     al,bl	     ;уст счетчика таймера 1
E10F  2B C9			     sub     cx,cx
E111  E6 41			     out     timer+1,al
E113			     c14:	     ;цикл таймера
E113  B0 40			     mov     al,40h
E115  E6 43			     out     timer+3,al
E117  E4 41			     in	     al,timer+1		     ;считывание счетчика    +
			     таймера 1
E119  22 D8			     and     bl,al
E11B  74 04			     jz	     c15
E11D  E2 F4			     loop    c14	     ;цикл таймера
E11F  EB 9F			     jmp     short err01

			     ;	 Инициализация таймера 1

E121			     c15:
E121  B0 54			     mov     al,54h
E123  E6 43			     out     timer+3,al	     ;запись в регистр режима      +
			     таймера
E125  B0 07			     mov     al,7    ;уст коэффициента деления для    +
			     регенерации
E127  E6 41			     out     timer+1,al	     ;запись в счетчик таймера 1
E129  E6 0D			     out     dma+0dh,al	     ;послать гашение ПДП

			     ;	 Цикл проверки регистров ПДП

E12B  B0 FF			     mov     al,0ffh	     ;запись шаблона FF во все       +
			     регистры
E12D  8A D8		     c16:    mov     bl,al	     ;сохранить шаблон для	       +
			     сравнения
E12F  8A F8			     mov     bh,al
E131  B9 0008			     mov     cx,8	     ;уст цикла	счетчика
E134  BA 0000			     mov     dx,dma	     ;уст адреса регистра порта  +
			     ввода/вывода
E137  EE		     c17:    out     dx,al	     ;запись  шаблона в регистр
E138  EE			     out     dx,al	     ;старшие 16	бит регистра
E139  B8 0101			     mov     ax,0101h	     ;изменение AX перед		       +
			     считыванием
E13C  EC			     in	     al,dx
E13D  8A E0			     mov     ah,al	     ;сохранить младшие	16 бит      +
			     регистра
E13F  EC			     in	     al,dx
E140  3B D8			     cmp     bx,ax	     ;считан тот же шаблон ?
E142  74 03			     je	     c18	     ;ДА - проверка следующего     +
			     регистра
E144  E9 FF79			     jmp     err01	     ;НЕТ - ошибка
E147			     c18:			     ;выбор следующего регистра +
			     ПДП
E147  42			     inc     dx		     ;установка адреса		       +
			     следующего
							     ;регистра ПДП
E148  E2 ED			     loop    c17	     ;запись шаблона для	       +
			     следующего регистра
E14A  F6 D0			     not     al		       ;уст шаблона в 0
E14C  74 DF			     jz	     c16

			     ;	 Инициализация и запуск ПДП

E14E  B0 FF			     mov     al,0ffh	     ;уст счетчика 64K для	       +
			     регенерации
E150  E6 01			     out     dma+1,al
E152  E6 01			     out     dma+1,al
E154  B0 58			     mov     al,058h	     ;уст режим	ПДП,	счетчик 0,      +
			     считывание
E156  E6 0B			     out     dma+0bh,al	     ;запись в регистр режима ПДП
E158  B0 00			     mov     al,0	     ;доступность контроллера    +
			     ПДП
E15A  E6 08			     out     dma+8,al	     ;уст регистр команд ПДП
E15C  E6 0A			     out     dma+10,al	     ;доступность канала 0 для     +
			     регенерации
E15E  B0 41			     mov     al,41h	     ;уст режим	дла канала 1
E160  E6 0B			     out     dma+0bh,al
E162  B0 42			     mov     al,42h	     ;уст режим	для канала 2
E164  E6 0B			     out     dma+0bh,al
E166  B0 43			     mov     al,43h	     ;уст режим	для канала 3
E168  E6 0B			     out     dma+0bh,al
			     ;======================================RCgoff begin
			     ;-----------------turn ES1841 memory on, if present
E16A  BA 02B0				     mov dx,2b0h
E16D  B0 0C				     mov al,0ch			     ;0b0000.1100 - turn RD,WR on, no  +
			     reconfig
E16F  EE				     out dx,al
			     ;======================================RCgoff end
E170  B8 0040				     mov     ax, dat
E173  8E D8				     mov     ds, ax

E175  8B 1E 0072r			     mov     bx, ds:reset_flag
E179  8B 36 0013r			     mov si, ds:memory_size	     ;keep memory size in SI after     +
			     reboot
E17D  2B C0				     sub     ax, ax
E17F  8E C0				     mov     es, ax
E181  E4 62				     in	     al, port_c
E183  24 0F				     and     al, 0Fh
E185  FE C0				     inc     al
E187  02 C0				     add     al, al
E189  BA 0000				     mov     dx, 0
E18C  8B E8				     mov     bp,ax			     ;BP will be segment count +
			     (and will be 0, i.e. no error, after finish)
E18E  33 C0				     xor     ax, ax			     ;write 0 to mem
E190  FC				     cld

E191  2B FF				     sub     di, di			     ;not in loop because after+
			     writing 32768 words already will be DI=0
E193			     c19:
E193  B9 8000				     mov     cx, 32768
E196  F3> AB				     rep stosw				     ;clear full segment (32768+
			     words=6536	bytes)
E198  81 C2 1000			     add     dx, 4096			     ;next segment
E19C  8E C2				     mov     es, dx
E19E  4D				     dec     bp
E19F  74 02				     jz	     c21
E1A1  EB F0				     jmp     short c19
			     ;____________________
			     ;	 Инициализация контроллера
			     ;	 прерываний 8259
			     ;____________________
E1A3			     c21:
E1A3  B0 13			     mov     al,13h	     ;ICW1 - EDGE, SNGL, ICW4
E1A5  E6 20			     out     inta00,al
E1A7  B0 08			     mov     al,8	     ;УСТ ICW2 - прерывание типа 8(8-F)
E1A9  E6 21			     out     inta01,al
E1AB  B0 09			     mov     al,9	     ;уст ICW4 - BUFFERD , режим 8086
E1AD  E6 21			     out     inta01,al
E1AF  2B C0				     sub     ax, ax
E1B1  8E C0				     mov     es, ax
												     ;DS still +
			     points to BIOS data area
E1B3  89 1E 0072r			     mov     ds:reset_flag, bx
E1B7  89 36 0013r			     mov     ds:memory_size, si
E1BB  81 3E 0072r 1234			     cmp     ds:reset_flag, 1234h
E1C1  74 38				     jz	     c25
E1C3  8E D8				     mov     ds, ax
E1C5  BC 3FF0r				     mov     sp, offset	tmp_tos
E1C8  8E D0				     mov     ss, ax
E1CA  8B F8				     mov     di, ax
E1CC  BB 0024				     mov     bx, 9*4	     ; int 9 (KBD)
E1CF  C7 07 E29Er			     mov     word ptr [bx], offset d11
E1D3  43				     inc     bx
E1D4  43				     inc     bx
E1D5  8C 0F				     mov     [bx], cs
E1D7  E8 03F1				     call    kbd_reset
E1DA  80 FB 65				     cmp     bl, 65h	     ; Manufacturing test mode - viz document  +
			     in	BIOS root or http://www.vcfed.org/forum/archive/index.php/t-12377.html
E1DD  75 0E				     jnz     c23
E1DF  B2 FF				     mov     dl, 0FFh

E1E1			     c22:
E1E1  E8 03F4				     call    sp_test
E1E4  8A C3				     mov     al, bl
E1E6  AA				     stosb
E1E7  FE CA				     dec     dl
E1E9  75 F6				     jnz     c22
E1EB  CD 3E				     int     3Eh

E1ED			     c23:
E1ED  0E				     push    cs
E1EE  17				     pop     ss
					     assume ss:code
E1EF  FA				     cli
E1F0  BC E018r				     mov     sp, offset	caw  ; [caw] = offset ca3 (next	jmp -> indirect+
			     call)
E1F3  E9 FE24				     jmp     stgtst

E1F6			     ca3:
E1F6  74 03				     jz	     c25
E1F8  E9 FEC5				     jmp     err01

			     ;	 Установка сегмента стека	и SP

E1FB			     c25:
E1FB  B8 0030			     mov     ax,sta	     ;получить величину	стека
E1FE  8E D0			     mov     ss,ax	     ;уст стек
E200  BC 0100r			     mov     sp,offset tos   ;стек готов
E203  EB 1C			     jmp     short tst6	     ;переход к	следующему тесту

			     ;ros_checksum proc	 near
			     ;	     mov     cx,8192	     ;число байт для сложения
			     ;	     xor     al,al
			     ;c26:   add     al,cs:[bx]
			     ;	     inc     bx		     ;указание следующего байта
			     ;	     loop    c26	     ;сложить все байты в модуле +
			     ROS
			     ;	     or	     al,al	     ;сумма = 0 ?
			     ;	     ret
			     ;ros_checksum endp
			     ;______________________
			     ;	 Начальный тест надежности
			     ;______________________
				     assume  cs:code,es:abs0

E205  70 61 72 69 74 79	20+  d1		     db	'parity	check 2'
      63 68 65 63 6B 20	32


      =000E		     d1l     equ     14
E213  70 61 72 69 74 79	20+  d2		     db	'parity	check 1'
      63 68 65 63 6B 20	31


      =000E		     d2l     equ     14
			     ;______________________
			     ;	 ТЕСТ.06
			     ;	      Тест контроллера прерываний
			     ;	      8259
			     ;_______________________
E221			     tst6:
			     ;	 Проверка регистра масок прерываний (IMR)

E221  FA			     cli		     ;сброс признака разрешения +
			     прерываний
E222  B0 00			     mov     al,0	     ;уст IMR в 0
E224  E6 21			     out     inta01,al
E226  E4 21			     in	     al,inta01	     ;считывание IMR
E228  0A C0			     or	     al,al	     ;IMR=0 ?
E22A  75 39			     jnz     d6		     ;IMR не 0,в программу ошибок
E22C  B0 FF			     mov     al,0ffh	     ;недоступность прерываний
E22E  E6 21			     out     inta01,al	     ;запись в IMR
E230  E4 21			     in	     al,inta01	     ;считывание IMR
E232  04 01			     add     al,1	     ;все биты IMR установлены ?
E234  75 2F			     jnz     d6		     ;НЕТ - в программу ошибок

E236  2B C0			     sub     ax,ax	     ;уст регистра ES
E238  8E C0			     mov     es,ax


			     ;	 Контроль ожидания прерывания

E23A  FC			     cld		     ; уст признак направления
E23B  B9 0020			     mov     cx,20h	     ;rc все	прерывания 00..1F,	       +
			     относящиеся к BIOS
E23E  33 FF			     xor     di,di
E240			     d3:
E240  B8 E29Er			     mov     ax,offset d11   ; установить адрес		       +
			     процедуры	прерываний
E243  AB			     stosw
E244  B8 F000			     mov     ax,cod  ; получить	адрес сегмента	       +
			     процедуры
E247  AB			     stosw
E248  E2 F6			     loop    d3

			     ;	 Установка указателя вектора прерывания NMI
E24A  26: C7 06	0008r	  +	     mov     es:nmi_ptr,offset nmi_int
      E2ABr
			     ;-----уст вектора прерываний 5
E251  26: C7 06	0014r	  +	     mov     es:int5_ptr,offset	print_screen   ; печать экрана
      FF54r

			     ;	 Прерывания замаскированы

E258  32 E4			     xor     ah,ah	     ;очистить регистр AH
E25A  FB			     sti		     ; установка признака	       +
			     разрешения прерывания
E25B  2B C9			     sub     cx,cx	     ; ожидание	1 сек любого	       +
			     прерывания,
E25D  E2 FE		     d4:     loop    d4		     ; которое может произойти
E25F  E2 FE		     d5:     loop    d5
E261  0A E4			     or	     ah,ah	     ; прерывание возникло ?
E263  74 08			     jz	     d7		     ; нет -	к следующему	тесту
E265  BA 0101		     d6:     mov     dx,101h	     ; уст длительности		       +
			     звукового	сигнала
E268  E8 0315			     call    err_beep	     ; идти	в программу		       +
			     звукового	сигнала
E26B  FA			     cli
E26C  F4			     hlt		     ; останов системы
			     ;__________________
			     ;	 ТЕСТ.07
			     ;	      Проверка таймера 8253
			     ;___________________
E26D			     d7:
E26D  B4 00			     mov     ah,0	     ; сброс признака прерывания+
			     таймера
E26F  32 ED			     xor     ch,ch	     ; очистить	регистр CH
E271  B0 FE			     mov     al,0feh   ; маскировать	все прерывания,   +
			     кроме	LVL 0
E273  E6 21			     out     inta01,al	     ; запись IMR
E275  B0 10			     mov     al,00010000b    ; выбрать TIM 0, LSD, режим 0,	BINARY
E277  E6 43			     out     tim_ctl,al	 ;записать регистр режима	       +
			     управления таймера
E279  B1 16			     mov     cl,16h	     ; уст счетчик программного  +
			     цикла
E27B  8A C1			     mov     al,cl	     ; установить счетчик	       +
			     таймера 0
E27D  E6 40			     out     timero,al	     ; записать	счетчик таймера 0
E27F  F6 C4 FF		     d8:     test    ah,0ffh	     ; прерывание таймера 0	       +
			     произошло	?
E282  75 04			     jnz     d9		     ; да - таймер считал	медленно
E284  E2 F9			     loop    d8		     ; ожидание	прерывания	       +
			     определенное время
E286  EB DD			     jmp     short d6	;прерывание таймера 0 не	       +
			     произошло	- ошибка
E288  B1 12		     d9:     mov     cl,18	     ; уст счетчик программного  +
			     цикла
E28A  B0 FF			     mov     al,0ffh	     ; записать	счетчик таймера 0
E28C  E6 40			     out     timero,al
E28E  B4 00			     mov     ah,0	     ; сброс признака,		       +
			     полученного прерывания
E290  B0 FE			     mov     al,0feh	     ; недоступность прерываний +
			     таймера 0
E292  E6 21			     out     inta01,al
E294  F6 C4 FF		     d10:    test    ah,0ffh	     ; прерывание таймера 0	       +
			     произошло	?
E297  75 CC			     jnz     d6		     ; да - таймер считает быстро
E299  E2 F9			     loop    d10	     ; ожидание	прерывания	       +
			     определенное время
E29B  EB 37			     jmp     short tst8		     ; переход к следующему  +
			     тесту
E29D  90			     nop
			     ;____________________
			     ;	 Программа обслуживания
			     ;	 временного прерывания
			     ;____________________
E29E			     d11     proc    near
E29E  B4 01			     mov     ah,1
E2A0  50			     push    ax		     ; хранить регистр AX
E2A1  B0 FF			     mov     al,0ffh	     ; размаскировать все	       +
			     прерывания
E2A3  E6 21			     out     inta01,al
E2A5  B0 20			     mov     al,eoi
E2A7  E6 20			     out     inta00,al
E2A9  58			     pop     ax		     ; восстановить	регистр AX
E2AA  CF			     iret
E2AB			     d11     endp

E2AB			     nmi_int proc    near
E2AB  50			     push    ax		     ; хранить регистр AX
E2AC  E4 62			     in	     al,port_c
E2AE  A8 40			     test    al,40h	     ; ошибка паритета при	       +
			     вводе/выводе ?
E2B0  74 08			     jz	     d12	     ; да - признак сбрасывается  +
			     в	0
E2B2  BE E205r			     mov     si,offset d1    ; адрес поля сообщения об     +
			     ошибке
E2B5  B9 000E			     mov     cx,d1l	     ; длина поля сообщения об     +
			     ошибке
E2B8  EB 0A			     jmp     short d13	     ; отобразить ошибку на	       +
			     дисплее
E2BA			     d12:
E2BA  A8 80			     test    al,80h
E2BC  74 10			     jz	     d14
E2BE  BE E213r			     mov     si,offset d2    ; адрес поля сообщения об     +
			     ошибке
E2C1  B9 000E			     mov     cx,d2l	     ; длина поля сообщения об     +
			     ошибке
E2C4			     d13:
E2C4  B8 0000			     mov     ax,0	     ; инициировать	и установить+
			     режим	ЭЛИ
E2C7  CD 10			     int     10h	     ; вызвать процедуру VIDEO_IO
E2C9  E8 0329			     call    p_msg	     ; распечатать ошибку
E2CC  FA			     cli
E2CD  F4			     hlt		     ; останов системы
E2CE			     d14:
E2CE  58			     pop     ax		     ; восстановить	AX
E2CF  CF			     iret
E2D0			     nmi_int endp
			     ;____________________
			     ;	 Начальный тест надежности
			     ;____________________
				     assume  cs:code,ds:data

E2D0  20 32 30 31	     e1	     db	     ' 201'
      =0004		     e1l     equ     04h

			     ;	 Выполнение программы БСУВВ,
			     ;	 генерирующей вектора прерываний

E2D4			     tst8:
E2D4  FC			     cld		     ; установить признак	       +
			     направления вперед
E2D5  BF 0040r			     mov     di,offset video_int   ; уст адреса области	       +
			     прерываний
E2D8  0E			     push    cs
E2D9  1F			     pop     ds		     ; уст адреса таблицы	       +
			     векторов
E2DA  BE FF03r			     mov     si,offset vector_table+10h	 ; смещение VECTOR_TABLE+(2*8) +
			     (начало прогр прерыв)
E2DD  B9 0010			     mov     cx,10h
E2E0  A5		     e1a:    movsw	     ; передать	таблицу векторов	в     +
			     память
E2E1  47			     inc     di
E2E2  47			     inc     di
E2E3  E2 FB			     loop    e1a

			     ;	 Установка таймера 0 в	режим 3

E2E5  B0 FF			     mov     al,0ffh
E2E7  E6 21			     out     inta01,al
E2E9  B0 36			     mov     al,36h	     ; выбор счетчика 0,		       +
			     считывания-за-
			     ; писи	младшего,затем старшего байта		       +
			     счетчика,уст режима 3
E2EB  E6 43			     out     timer+3,al	     ; запись режима таймера
E2ED  B0 C7			     mov     al,0c7h
E2EF  E6 40			     out     timer,al	     ; записать	младшую часть      +
			     счетчика
E2F1  B0 DB			     mov     al,0dbh
E2F3  E6 40			     out     timer,al	     ; записать	старшую часть      +
			     счетчика


				     assume  ds:data
E2F5  B8 0040			     mov     ax,dat	     ; DS - сегмент данных
E2F8  8E D8			     mov     ds,ax
E2FA			     e3:
E2FA  81 3E 0072r 1234		     cmp     reset_flag,1234h
E300  74 03			     jz	     e3a
E302  E8 1554			     call    bct     ;загрузка знакогенератора Ч/Б    +
			     ЭЛИ
			     ;_____________________
			     ;	 ТЕСТ.08
			     ;	      Инициализация и запуск
			     ;	      контроллера ЭЛИ
			     ;______________________
E305  E4 60		     e3a:    in	     al,port_a	     ; считывание состояния	       +
			     переключателей
E307  B4 00			     mov     ah,0
E309  A3 0010r			     mov     equip_flag,ax   ; запомнить считанное	       +
			     состояние	пере-
							     ; ключателей
E30C  24 30			     and     al,30h	     ; выделить	переключатели     +
			     ЭЛИ
E30E  75 03			     jnz     e7		     ; переключатели ЭЛИ	       +
			     установлены в 0 ?
E310  E9 0098			     jmp     e19	     ; пропустить тест ЭЛИ
E313			     e7:
E313  86 E0			     xchg    ah,al
E315  80 FC 30			     cmp     ah,30h	     ; адаптер ч/б ?
E318  74 09			     je	     e8		     ; да - установить режим для   +
			     ч/б адаптера
E31A  FE C0			     inc     al	      ;	уст цветной режим для		       +
			     цветного адаптера
E31C  80 FC 20			     cmp     ah,20h	     ; режим 80х25 установлен ?
E31F  75 02			     jne     e8		     ; нет -	уст режим для 40х25
E321  B0 03			     mov     al,3	     ; установить режим 80х25
E323			     e8:
E323  50			     push    ax		     ; хранить режим ЭЛИ	в стеке
E324  2A E4			     sub     ah,ah	     ;
E326  CD 10			     int     10h
E328  58			     pop     ax
E329  50			     push    ax
E32A  BB B000			     mov     bx,0b000h
E32D  BA 03B8			     mov     dx,3b8h	     ; регистр режима для ч/б
E330  B9 0800			     mov     cx,4096/2	     ; счетчик байт для ч/б	       +
			     адаптера
E333  B0 01			     mov     al,1	     ; уст режим для	ч/б адаптера
E335  80 FC 30			     cmp     ah,30h	     ; ч/б адаптер ЭЛИ подключен ?
E338  74 0B			     je	     e9		     ; переход к проверке буфера +
			     ЭЛИ
E33A  BB B800			     mov     bx,0b800h
E33D  BA 03D8			     mov     dx,3d8h	     ; регистр режима для	       +
			     цветного адаптера
E340  B9 2000			     mov     cx,4000h/2
E343  FE C8			     dec     al		     ; уст режим в 0 для цветного  +
			     адаптера
			     ;
			     ;	     Проверка буфера ЭЛИ
			     ;
E345			     e9:
E345  EE			     out     dx,al	     ; блокировка ЭЛИ для	       +
			     цветного адаптера
E346  8E C3			     mov     es,bx
E348  B8 0040			     mov     ax,dat	     ; DS - сегмент данных
E34B  8E D8			     mov     ds,ax
E34D  81 3E 0072r 1234		     cmp     reset_flag,1234h
E353  74 0D			     je	     e10
E355  8E DB			     mov     ds,bx	     ;
E357  E8 FCC3			     call    stgtst_cnt	     ; переход к проверке памяти
E35A  74 06			     je	     e10
E35C  BA 0102			     mov     dx,102h
E35F  E8 021E			     call    err_beep

			     ;___________________________
			     ;
			     ;	 ТЕСТ.09
			     ;	      Осуществляет проверку	формирования       +
			     строк	в буфере	ЭЛИ
			     ;_________________________
E362			     e10:
E362  58			     pop     ax	  ; получить считанные			       +
			     переключатели	ЭЛИ в AH
E363  50			     push    ax		     ; сохранить их
E364  B4 00			     mov     ah,0
E366  CD 10			     int     10h
E368  B8 7020			     mov     ax,7020h	     ; запись пробелов в	режиме   +
			     реверса
E36B  2B FF			     sub     di,di	     ; установка начала области
E36D  B9 0028			     mov     cx,40	     ;
E370  FC			     cld	 ; установить	признак направления  +
			     для уменьшения
E371  F3> AB			     rep     stosw	     ; записать	в память
			     ;______________________
			     ;	  ТЕСТ.10
			     ;	       Осуществляет	проверку линий		       +
			     интерфейса ЭЛИ
			     ;______________________
E373  58			     pop     ax		     ; получить	считанные	       +
			     переключатели
E374  50			     push    ax		     ; сохранить их
E375  80 FC 30			     cmp     ah,30h	     ; ч/б адаптер подключен ?
E378  BA 03BA			     mov     dx,03bah	     ; уст адрес порта состояния +
			     ч/б дисплея
E37B  74 03			     je	     e11	     ; да - переход к	следующей     +
			     строке
E37D  BA 03DA			     mov     dx,03dah	     ; цветной адаптер подключен
			     ;
			     ;	     Тест строчной развертки
			     ;
E380			     e11:
E380  B4 08			     mov     ah,8
E382			     e12:
E382  2B C9			     sub     cx,cx
E384  EC		     e13:    in	     al,dx	 ;считывание порта состояния   +
			     контроллера СМ607
E385  22 C4			     and     al,ah	     ; проверка	строки
E387  75 04			     jnz     e14
E389  E2 F9			     loop    e13
E38B  EB 13			     jmp     short e17	     ; переход к сообщению об       +
			     ошибке
E38D  2B C9		     e14:    sub     cx,cx
E38F  EC		     e15:    in	     al,dx     ;считывание порта	состояния     +
			     контроллера СМ607
E390  22 C4			     and     al,ah
E392  74 04			     jz	     e16
E394  E2 F9			     loop    e15
E396  EB 08			     jmp     short e17
			     ;
			     ;	     Следующий	строчный импульс
			     ;
E398			     e16:
E398  B1 03			     mov     cl,3	     ; получить	следующий бит      +
			     для контроля
E39A  D2 EC			     shr     ah,cl
E39C  75 E4			     jnz     e12
E39E  EB 06			     jmp     short e18	     ; отобразить курсор на	       +
			     экране
			     ;
			     ;	     Сообщение	об ошибке конттроллера СМ607
			     ;
E3A0			     e17:
E3A0  BA 0103			     mov     dx,103h
E3A3  E8 01DA			     call    err_beep
			     ;
			     ;	     Отображение курсора на	экране
			     ;
E3A6			     e18:
E3A6  58			     pop     ax		     ; получить	считанные	       +
			     переключатели	в AH
E3A7  B4 00			     mov     ah,0	     ; установить режим
E3A9  CD 10			     int     10h
			     ;______________________
			     ;	 ТЕСТ.11
			     ;	      Дополнительный тест памяти
			     ;______________________
				     assume  ds:data
E3AB			     e19:
E3AB  B8 0040			     mov     ax,dat
E3AE  8E D8			     mov     ds,ax
E3B0  81 3E 0072r 1234			     cmp     reset_flag,1234h
E3B6  74 0D				     je	     skip_size_det
E3B8  E4 62				     in	     al, port_c
E3BA  24 0F				     and     al, 0Fh
E3BC  FE C0				     inc     al
E3BE  B4 80				     mov     ah, 80h
E3C0  F6 E4				     mul     ah
E3C2  A3 0013r				     mov     ds:memory_size, ax
E3C5			     skip_size_det:
E3C5  A1 0013r				     mov     ax,ds:memory_size		     ;restore if reboot	and no +
			     damages if	power-on
E3C8  A3 0015r				     mov     ds:io_ram_size, ax



			     ;	 Проверка любой действительной памяти
			     ;	 на считывание и запись

E3CB  E9 0245			     jmp     e190

			     ;	 Печать адреса и эталона, если
			     ;	 произошла ошибка данных


E3CE			     osh:
E3CE  50			     push ax	     ;
E3CF  8A C6			     mov     al,dh	     ; получить	адрес (8 старших   +
			     разрядов)
E3D1  E8 0019			     call prn_hex_byte
E3D4  58			     pop ax	     ; получить	XOR записанного и	       +
			     прочтенного
E3D5  E8 0015			     call prn_hex_byte
E3D8  32 C0			     xor al,al
E3DA  D1 EF			     shr di,1
E3DC  73 01			     jnc evn
E3DE  40			     inc ax
E3DF  E8 000B		     evn:    call prn_hex_byte
E3E2  BE E2D0r			     mov     si,offset e1    ; установить адрес поля	       +
			     сообщения
							     ; об ошибке
E3E5  B9 0004			     mov     cx,e1l	     ; получить	счетчик поля	       +
			     сообщения	об ошибке
E3E8  E8 020A			     call    p_msg	     ; печать ошибки
E3EB			     e22:
E3EB  EB 3A			     jmp     short tst12	     ; переход к следующему  +
			     тесту
E3ED			     prn_hex_byte proc near
E3ED  50			     push ax
E3EE  B1 04			     mov     cl,4
E3F0  D2 E8			     shr     al,cl	     ;
E3F2  E8 0007			     call    xlat_print_cod  ; преобразование и печать    +
			     старшего разряда
E3F5  58			     pop ax
E3F6  24 0F			     and     al,0fh
E3F8  E8 0001			     call    xlat_print_cod  ; преобразование и печать    +
			     младшего разряда
E3FB  C3			     ret
E3FC			     prn_hex_byte endp
			     org     0e3fch
			     ;_____________________
			     ;
			     ;	 Процедура вывода на экран сообщения об       +
			     ошибке в коде ASCII
			     ;
			     ;_______________________

E3FC			     xlat_print_cod proc near
E3FC  1E			     push    ds		     ; сохранить DS
E3FD  0E			     push    cs
E3FE  1F			     pop     ds
E3FF  BB E417r			     mov     bx,offset f4e   ; адрес таблицы кодов ASCII
E402  D7			     xlatb
E403  B4 0E			     mov     ah,14
E405  B7 00			     mov     bh,0
E407  CD 10			     int     10h
E409  1F			     pop     ds
E40A  C3			     ret
E40B			     xlat_print_cod endp
			     ;______________________
			     ;	 Сброс системы - фаза 4
			     ;______________________
			     ;
			     ;	 Коды сообщений об ошибках
			     ;_______________________

				     assume  cs:code,ds:data
E40B  20 33 30 31	     f1	     db	     ' 301'
      =0004		     f1l     equ     4h		     ; сообщение клавиатуры
E40F  31 33 31		     f2	     db	     '131'
      =0003		     f2l     equ     3h		     ; сообщение кассеты
E412  36 30 31		     f3	     db	     '601'
      =0003		     f3l     equ     3h		     ; сообщение НГМД

E415			     f4	     label   word
E415  0378			     dw	     378h
E417			     f4e     label   word
E417  30 31 32 33 34 35	36+  ascii_tbl db    '0123456789abcdef'
      37 38 39 61 62 63	64+
      65 66


			     ;______________________
			     ;	 ТЕСТ.12
			     ;	 Тест клавиатуры
			     ;______________________
E427			     tst12:

E427  B8 0040			     mov     ax,dat
E42A  8E D8			     mov     ds,ax
E42C  E8 019C			     call    kbd_reset	     ; Сброс клавиатуры
E42F  B0 4D			     mov     al,4dh	     ; доступность клавиатуры
E431  E6 61			     out     port_b,al
E433  E3 27			     jcxz    f6		     ; нет -	печать ошибки
E435  80 FB AA			     cmp     bl,0aah	     ; код сканирования 'AA' ?
E438  75 22			     jne     f6		     ; нет -	печать ошибки

			     ;	 Поиск "залипших" клавиш

E43A  B0 CC			     mov     al,0cch	   ; сброс	клавиатуры, уст	       +
			     синхронизации
E43C  E6 61			     out     port_b,al
E43E  B0 4C			     mov     al,4ch	   ; доступность клавиатуры
E440  E6 61			     out     port_b,al
E442  2B C9			     sub     cx,cx
			     ;
			     ;	     Ожидание прерывания клавиатуры
			     ;
E444			     f5:
E444  E2 FE			     loop    f5		     ; задержка
E446  E4 60			     in	     al,kbd_in	     ; получение кода		       +
			     сканирования
E448  3C 00			     cmp     al,0	     ; код сканирования равен 0 ?
E44A  74 19			     je	     f7		     ; да - продолжение		       +
			     тестирования
E44C  8A E8			     mov     ch,al	     ; сохранить код		       +
			     сканирования
E44E  B1 04			     mov     cl,4
E450  D2 E8			     shr     al,cl
E452  E8 FFA7			     call    xlat_print_cod  ; преобразование и печать
E455  8A C5			     mov     al,ch	     ; восстановить	код		       +
			     сканирования
E457  24 0F			     and     al,0fh	     ; выделить	младший байт
E459  E8 FFA0			     call    xlat_print_cod  ; преобразование и печать
E45C  BE E40Br		     f6:     mov     si,offset f1    ; получить	адрес поля	       +
			     сообщения	об
							     ; ошибке
E45F  B9 0004			     mov     cx,f1l	      ;	длина поля сообщения об    +
			     ошибке
E462  E8 0190			     call    p_msg	      ;	вывод сообщения об ошибке+
			     на экран

			     ;	 Установка таблицы векторов прерываний

E465			     f7:
E465  2B C0			     sub     ax,ax
E467  8E C0			     mov     es,ax
E469  B9 0008			     mov     cx,8	     ; получить	счетчик векторов
E46C  0E			     push    cs
E46D  1F			     pop     ds
E46E  BE FEF3r			     mov     si,offset vector_table   ;	адрес таблицы	       +
			     векторов
E471  BF 0020r			     mov     di,offset int_ptr
E474  FC			     cld
E475  A5		     f7a:    movsw
E476  47			     inc     di
E477  47			     inc     di
E478  E2 FB			     loop    f7a
E47A  EB 01			     jmp short tst14

				     org     0e47dh	     ;rc для	устранения съезжания+
			     при переделке загрузчика таблицы векторв      +
			     прерываний

			     ;______________________
			     ;	 ТЕСТ.14
			     ;	 Осуществляет проверку НГМД
			     ;______________________
E47D  B8 0040		     tst14:  mov     ax,dat	     ; уст. регистр DS
E480  8E D8			     mov     ds,ax
E482  B0 FC			     mov     al,0fch  ;	доступность прерываний	       +
			     таймера и клавиатуры
E484  E6 21			     out     inta01,al
E486  A0 0010r			     mov     al,byte ptr equip_flag  ; получить	состояние     +
			     переклю-
								     ; чателей
E489  A8 01			     test    al,01h	     ; первоначальная загрузка с+
			     НГМД ?
E48B  75 03			     jnz     f10	     ; да - проверка управления    +
			     НГМД
E48D  E9 00ED			     jmp     f23
E490			     f10:
E490  B0 BC			     mov     al,0bch	     ; доступность прерываний с  +
			     НГМД,
E492  E6 21			     out     inta01,al	     ; клавиатуры и таймера
E494  B4 00			     mov     ah,0	     ; сброс контроллера НГМД
E496  CD 13			     int     13h	     ; переход к сбросу НГМД
E498  F6 C4 FF			     test    ah,0ffh	     ; состояние верно ?
E49B  75 20			     jnz     f13	     ; нет -	сбой устройства

			     ;	 Включить мотор устройства 0

E49D  BA 03F2			     mov     dx,03f2h	     ; получить	адрес адаптера    +
			     НГМД
E4A0  B0 1C			     mov     al,1ch	     ; включить	мотор
E4A2  EE			     out     dx,al
E4A3  2B C9			     sub     cx,cx

			     ;	  Ожидание включения мотора НГМД

E4A5			     f11:
E4A5  E2 FE			     loop    f11
E4A7			     f12:			     ; ожидание	мотора 1
E4A7  E2 FE			     loop    f12
E4A9  33 D2			     xor     dx,dx
E4AB  B5 01			     mov     ch,1	     ; выбор первой дорожки
E4AD  88 16 003Er		     mov seek_status,dl
E4B1  E8 09B3			     call    seek	     ; переход к рекалибровке      +
			     НГМД
E4B4  72 07			     jc	     f13	     ; перейти в программу ошибок
E4B6  B5 22			     mov     ch,34	     ; выбор 34 дорожки
E4B8  E8 09AC			     call    seek
E4BB  73 09			     jnc     f14	     ; выключить мотор

			     ;	  Ошибки НГМД

E4BD			     f13:
E4BD  BE E412r			     mov     si,offset f3    ; получить	адрес поля	       +
			     сообщения	об
							     ; ошибке
E4C0  B9 0003			     mov     cx,f3l	     ; установить счетчик
E4C3  E8 012F			     call    p_msg	     ; идти	в программу ошибок

			     ;	 Выключить мотор устройства 0

E4C6			     f14:
E4C6  B0 0C			     mov     al,0ch	     ; выключить мотор		       +
			     устройства 0
E4C8  BA 03F2			     mov     dx,03f2h	     ; уст адрес порта		       +
			     управления НГМД
E4CB  EE			     out     dx,al

			     ;	 Установка печати и базового адреса
			     ;	 адаптера стыка С2, если устройства		       +
			     подключены

E4CC			     f15:
E4CC  83 FD 00			     cmp     bp,0000h
E4CF  74 18			     jz	     dal
E4D1  BA 0003			     mov     dx,3
E4D4  E8 00A9			     call    err_beep
E4D7  BE E6A6r			     mov     si,offset f39
E4DA  B9 0017				     mov     cx, 23
E4DD  E8 0115			     call    p_msg
E4E0			     err_wait:
E4E0  B4 00			     mov     ah,0
E4E2  CD 16			     int     16h
E4E4  80 FC 3B			     cmp     ah,3bh
E4E7  75 F7			     jnz     err_wait
E4E9  2A E4		     dal:    sub     ah,ah
E4EB  A0 0049r			     mov     al,crt_mode
E4EE  CD 10			     int     10h
E4F0  C7 06 001Ar 001Er			     mov     ds:buffer_head, offset kb_buffer ;	ERROR -	Must be	approx.+
			     6 lines upper, before int 16h
E4F6  C7 06 001Cr 001Er			     mov     ds:buffer_tail, offset kb_buffer ;	ERROR -	Must be	approx.+
			     6 lines upper, before int 16h
E4FC  BD E415r			     mov     bp,offset f4    ; таблица PRT_SRC
E4FF  BE 0000			     mov     si,0
E502			     f16:
E502  2E: 8B 56	00		     mov     dx,cs:[bp]	     ; получить	базовый адрес      +
			     печати
E506  B0 AA			     mov     al,0aah	     ; записать	данные в	порт А
E508  EE			     out     dx,al
E509  2A C0			     sub     al,al
E50B  EC			     in	     al,dx	     ; считывание порта А
E50C  3C AA			     cmp     al,0aah	     ; шаблон данных тот	же
E50E  75 06			     jne     f17	 ; нет - проверка следующего      +
			     устройства печати
E510  89 94 0008r		     mov     word ptr printer_base[si],dx  ;да-уст	базовый	       +
			     адрес
E514  46			     inc     si		     ; вычисление следующего       +
			     слова
E515  46			     inc     si
E516			     f17:
E516  45			     inc     bp		     ; указать следующий базовый+
			     адрес
E517  45			     inc     bp
E518  81 FD E417r		     cmp     bp,offset f4e   ; все возможные адреса	       +
			     проверены	?
E51C  75 E4			     jne     f16	     ; нет, к проверке следующего+
			     адреса печати
E51E  BB 0000			     mov     bx,0
E521  BA 03FF			     mov     dx,3ffh	     ; проверка	подключения	       +
			     адаптера 1	стыка С2
E524  B0 8A			     mov     al,8ah
E526  EE			     out     dx,al
E527  BA 02FF			     mov     dx,2ffh
E52A  EE			     out     dx,al
E52B  BA 03FC			     mov     dx,3fch
E52E  B0 AA			     mov     al,0aah
E530  EE			     out     dx,al
E531  42			     inc     dx
E532  33 C0				     xor     ax, ax
E534  EE				     out     dx, al
E535  EC			     in	     al,dx
E536  3C AA			     cmp     al,0aah
E538  75 08			     jnz     f18
E53A  C7 87 0000r 03F8		     mov  word ptr rs232_base[bx],3f8h	; уст адрес адаптера 1
E540  43			     inc     bx
E541  43			     inc     bx
E542  BA 02FC		     f18:    mov     dx,2fch	     ; проверка	подключения	       +
			     адаптера 2	стыка С2
E545  B0 AA			     mov     al,0aah
E547  EE			     out     dx,al
E548  42			     inc     dx
E549  33 C0				     xor     ax, ax
E54B  EE				     out     dx, al
E54C  EC			     in	     al,dx
E54D  3C AA			     cmp     al,0aah
E54F  75 08			     jnz     f19
E551  C7 87 0000r 02F8		     mov  word ptr rs232_base[bx],2f8h	 ; уст адрес адаптера 2
E557  43			     inc     bx
E558  43			     inc     bx



			     ;_____Установка EQUIP_FLAG для	инди-
			     ;	   кации номера печати

E559			     f19:
E559  E9 1411				     jmp     f19a

E55C			     f19b:
E55C  D2 C8			     ror     al,cl
E55E  0A C3			     or	     al,bl
E560  A2 0011r			     mov     byte ptr equip_flag+1,al
E563  BA 0201			     mov     dx,201h
E566  EC			     in	     al,dx
E567  A8 0F			     test    al,0fh
E569  75 05			     jnz     f20			; проверка адаптера    +
			     игр
E56B  80 0E 0011r 10		     or	     byte ptr equip_flag+1,16
E570			     f20:
E570  E9 140D				     jmp     f20a
E573  90				     nop

E574			     f20b:
E574  BA 0001				     mov     dx, 1
E577  E8 0006			     call    err_beep	     ; переход к подпрограмме      +
			     звукового	сигнала
E57A			     f21:
E57A  E9 017A				     jmp     boot_strap

E57D			     f23:
E57D  E9 FF4C			     jmp     f15

			     ;	  Установка длительности звукового сигнала

				     assume  cs:code,ds:data
E580			     err_beep proc   near
E580  9C			     pushf		     ; сохранить признаки
E581  FA			     cli		     ; сброс признака разрешения+
			     прерывания
E582  1E			     push    ds		     ; сохранить DS
E583  B8 0040			     mov     ax,dat	     ; DS - сегмент данных
E586  8E D8			     mov     ds,ax
E588  0A F6			     or	     dh,dh
E58A  74 0B			     jz	     g3
E58C			     g1:			      ;	длинный звуковой	сигнал
E58C  B3 06			     mov     bl,6	      ;	счетчик для звуковых	       +
			     сигналов
E58E  E8 0018			     call    beep	      ;	выполнить звуковой сигнал
E591  E2 FE		     g2:     loop    g2		      ;	задержка между звуковыми +
			     сигналами
E593  FE CE			     dec     dh
E595  75 F5			     jnz     g1
E597			     g3:			      ;	короткий звуковой сигнал
E597  B3 01			     mov     bl,1   ; счетчик для короткого		       +
			     звукового	сигнала
E599  E8 000D			     call    beep	     ; выполнить звуковой сигнал
E59C  E2 FE		     g4:     loop    g4		     ; задержка	между звуковыми  +
			     сигналами
E59E  FE CA			     dec     dl		     ;
E5A0  75 F5			     jnz     g3		     ; выполнить
E5A2  E2 FE		     g5:     loop    g5		     ; длинная задержка перед      +
			     возвратом
E5A4  E2 FE		     g6:     loop    g6
E5A6  1F			     pop     ds		     ; восстановление DS
E5A7  9D			     popf		; восстановление			       +
			     первоначальных признаков
E5A8  C3			     ret		     ; возврат к программе
E5A9			     err_beep	     endp

			     ;	 Подпрограмма звукового сигнала

E5A9			     beep    proc    near
E5A9  B0 B6			     mov     al,10110110b    ; таймер 2,младший и	старший +
			     счет-
							     ; чики, двоичный счет
E5AB  E6 43			     out     timer+3,al	     ; записать	в регистр режима
E5AD  B8 045E			     mov     ax,45eh	     ; делитель
E5B0  E6 42			     out     timer+2,al	     ; записать	младший счетчик
E5B2  8A C4			     mov     al,ah
E5B4  E6 42			     out     timer+2,al	     ; записать	старший счетчик
E5B6  E4 61			     in	     al,port_b	     ; получить	текущее		       +
			     состояние	порта
E5B8  8A E0			     mov     ah,al	     ; сохранить это состояние
E5BA  0C 03			     or	     al,03	     ; включить	звук
E5BC  E6 61			     out     port_b,al
E5BE  2B C9			     sub     cx,cx	     ; установить счетчик	       +
			     ожидания
E5C0  E2 FE		     g7:     loop    g7		     ; задержка	перед		       +
			     выключением
E5C2  FE CB			     dec     bl		     ; задержка	счетчика	       +
			     закончена	?
E5C4  75 FA			     jnz     g7	     ; нет -	продолжение подачи	       +
			     звукового	сигнала
E5C6  8A C4			     mov     al,ah	     ; восстановить	значение       +
			     порта
E5C8  E6 61			     out     port_b,al
E5CA  C3			     ret		     ; возврат к программе
E5CB			     beep    endp
			     ;_____________________
			     ;	 Эта	процедура вызывает программный
			     ;	 сброс клавиатуры
			     ;_____________________
E5CB			     kbd_reset proc  near
E5CB  B0 0C			     mov     al,0ch	; установить низкий уровень     +
			     синхронизации
E5CD  E6 61			     out     port_b,al	     ; записать	порт B
E5CF  B9 7530			     mov     cx,30000	     ; время длительности	       +
			     низкого уровня
E5D2  E2 FE		     g8:     loop    g8
E5D4  B0 CC			     mov     al,0cch	     ; уст CLK
E5D6  E6 61			     out     port_b,al
E5D8			     sp_test:
E5D8  B0 4C			     mov     al,4ch	     ; уст высокий уровень	       +
			     синхронизации
E5DA  E6 61			     out     port_b,al
E5DC  B0 FD			     mov     al,0fdh	     ; разрешить прерывания	       +
			     клавиатуры
E5DE  E6 21			     out     inta01,al	     ; записать	регистр масок
E5E0  FB			     sti		     ; уст признака разрешения    +
			     прерывания
E5E1  B4 00			     mov     ah,0
E5E3  2B C9			     sub     cx,cx	     ; уст счетчика ожидания	       +
			     прерываний
E5E5  F6 C4 FF		     g9:     test    ah,0ffh	     ; прерывание клавиатуры       +
			     возникло ?
E5E8  75 02			     jnz     g10   ;  да - считывание возвращенного   +
			     кода сканирования
E5EA  E2 F9			     loop    g9		     ; нет -	цикл ожидания
E5EC  E4 60		     g10:    in	     al,port_a	 ; считать код сканирования      +
			     клавиатуры
E5EE  8A D8			     mov     bl,al	     ; сохранить этот код
E5F0  B0 CC			     mov     al,0cch	     ; очистка клавиатуры
E5F2  E6 61			     out     port_b,al
E5F4  C3			     ret		     ; возврат к программе
E5F5			     kbd_reset	     endp
			     ;_____________________
			     ;	 Эта	программа выводит на экран дисплея
			     ;	 сообщения об ошибках
			     ;
			     ;	   Необходимые условия:
			     ;	 SI = адрес поля сообщения об ошибке
			     ;	 CX = длина поля сообщения об ошибке
			     ;	 Максимальный размер передаваемой
			     ;	 информации -	36 знаков
			     ;
			     ;______________________
E5F5			     p_msg   proc    near
E5F5  B8 0040			     mov     ax,dat
E5F8  8E D8			     mov     ds,ax
E5FA  8B EE			     mov     bp,si
E5FC			     g12:
E5FC  2E: 8A 04			     mov     al,cs:[si]	     ; поместить знак в AL
E5FF  46			     inc     si		     ; указать следующий знак
E600  B7 00			     mov     bh,0	     ; установить страницу
E602  B4 0E			     mov     ah,14	     ; уст функцию записи знака
E604  CD 10			     int     10h	     ; и записать знак
E606  E2 F4			     loop    g12     ; продолжать до записи всего       +
			     сообщения
E608  B8 0E0D			     mov     ax,0e0dh	; переместить курсор в начало  +
			     строки
E60B  CD 10			     int     10h
E60D  B8 0E0A			     mov     ax,0e0ah  ; переместить	курсор на	       +
			     следующую	строку
E610  CD 10			     int     10h
E612  C3			     ret
E613			     p_msg   endp


E613			     e190:
E613  1E				     push    ds
E614  B8 0010				     mov     ax, 16
E617  81 3E 0072r 1234			     cmp     ds:reset_flag, 1234h
E61D  75 03				     jnz     e20a
E61F  E9 FDC9				     jmp     e22

E622			     e20a:
E622  B8 0010				     mov     ax, 16
E625  EB 25				     jmp     short prt_siz

E627			     e20b:
E627  8B 1E 0013r			     mov     bx, ds:memory_size
E62B  83 EB 10				     sub     bx, 16
E62E  B1 04				     mov     cl, 4
E630  D3 EB				     shr     bx, cl
E632  8B CB				     mov     cx, bx
E634  BB 0400				     mov     bx, 400h

E637			     e20c:
E637  8E DB				     mov     ds, bx

E639  8E C3				     mov     es, bx
E63B  81 C3 0400			     add     bx, 400h
E63F  52				     push    dx
E640  51				     push    cx
E641  53				     push    bx
E642  50				     push    ax
E643  E8 F9D4				     call    stgtst
E646  75 41				     jnz     e21a
E648  58				     pop     ax
E649  05 0010				     add     ax, 16

E64C			     prt_siz:
E64C  50				     push    ax
E64D  BB 000A				     mov     bx, 10
E650  B9 0003				     mov     cx, 3

E653			     decimal_loop:
E653  33 D2				     xor     dx, dx
E655  F7 F3				     div     bx
E657  80 CA 30				     or	     dl, 30h
E65A  52				     push    dx
E65B  E2 F6				     loop    decimal_loop
E65D  B9 0003				     mov     cx, 3

E660			     prt_dec_loop:
E660  58				     pop     ax
E661  E8 0034				     call    prt_hex
E664  E2 FA				     loop    prt_dec_loop
E666  B9 0007				     mov     cx, 7
E669  BE E69Fr				     mov     si, offset	e300 ; " Kb OK\r"

E66C			     kb_ok:
E66C  2E: 8A 04				     mov     al, cs:[si]
E66F  46				     inc     si
E670  E8 0025				     call    prt_hex
E673  E2 F7				     loop    kb_ok
E675  58				     pop     ax
E676  3D 0010				     cmp     ax, 16
E679  74 AC				     jz	     e20b
E67B  5B				     pop     bx
E67C  59				     pop     cx
E67D  5A				     pop     dx
E67E  E2 B7				     loop    e20c
E680  B0 0A				     mov     al, 10
E682  E8 0013				     call    prt_hex
E685  1F				     pop     ds

E686  E9 FD62				     jmp     e22

E689			     e21a:
E689  5B				     pop     bx
E68A  83 C4 06				     add     sp, 6
E68D  8C C2				     mov     dx, es
E68F  1F				     pop     ds
E690  1E				     push    ds
E691  89 1E 0013r			     mov     ds:memory_size, bx
E695  E9 FD36				     jmp     osh

E698			     prt_hex	     proc near
E698  B4 0E				     mov     ah, 14
E69A  B7 00				     mov     bh, 0
E69C  CD 10				     int     10h
E69E  C3				     retn
E69F			     prt_hex	     endp

E69F  20 4B 62 20 4F 4B	0D   e300	     db	' Kb OK',0Dh
E6A6  45 52 52 4F 52 20	28+  f39	     db	'ERROR (RESUME="F1" KEY)'
      52 45 53 55 4D 45	3D+
      22 46 31 22 20 4B	45+
      59 29

			     ;	 Таблица	кодов русских больших букв	       +
			     (заглавных)

E6BD			     rust2   label   byte
E6BD  1B 21 40 23 24 25	5E+	     db	     1bh,'!@#$',37,05eh,'&*()_+'
      26 2A 28 29 5F 2B


E6CA  08 00			     db	     08h,0
E6CC  B9 C6 C3 BA B5 BD	B3+	     db	     0b9h,0c6h,0c3h,0bah,0b5h,0bdh,0b3h,0c8h
      C8

E6D4  C9 B7 B6 CD 0D FF	C4+	     db	     0c9h,0b7h,0b6h,0cdh,0dh,-1,0c4h,0cbh
      CB

E6DC  B2 B0 BF C0 BE BB	B4+	     db	     0b2h,0b0h,0bfh,0c0h,0beh,0bbh,0b4h,27h
      27

E6E4  22 B1 CE 7C CF C7	C1+	     db	     '"',0b1h,0ceh,7ch,0cfh,0c7h,0c1h,0bch,0b8h
      BC B8

E6ED  C2 CC 3C 3E 3F C5	00+	     db	     0c2h,0cch,'<>?',0c5h,000,-1,' ',0cah
      FF 20 CA




			     ;___int 19_____________
			     ;	 Программа загрузки системы с НГМД
			     ;
			     ; Программа считывает содержимое дорожки 0     +
			     сектора 1 в
			     ; ячейку boot_locn (адрес 7C00,сегмент 0)
			     ;	 Если НГМД отсутствует или произошла	       +
			     аппаратная ошибка,
			     ; устанавливается прерывание типа INT	18H,	       +
			     которое вызывает
			     ; выполнение программ тестирования и	       +
			     инициализации
			     ; системы
			     ;
			     ;_________________________
				     assume  cs:code,ds:data
E6F7			     boot_strap	proc near

E6F7  FB			     sti		   ; установить признак	       +
			     разрешения прерывания
E6F8  B8 0040			     mov     ax,dat	   ; установить адресацию
E6FB  8E D8			     mov     ds,ax
E6FD  A1 0010r			     mov     ax,equip_flag ; получить состояние	       +
			     переключателей
E700  A8 01			     test    al,1	   ; опрос	первоначальной	       +
			     загрузки
E702  74 23			     jz	     h3

			     ;	 Система	загружается с НГМД
			     ;	 CX содержит счетчик повторений

E704  B9 0004			     mov     cx,4	     ; установить счетчик	       +
			     повторений
E707			     h1:			     ; первоначальная загрузка
E707  51			     push    cx		     ; сохранить счетчик	       +
			     повторений
E708  B4 00			     mov     ah,0	     ; сброс НГМД
E70A  CD 13			     int     13h
E70C  72 14			     jc	     h2		     ; если	ошибка,повторить
E70E  B4 02			     mov     ah,2	     ; считать сектор 1
E710  BB 0000			     mov     bx,0	     ;
E713  8E C3			     mov     es,bx
E715  BB 7C00r			     mov     bx,offset boot_locn
E718  BA 0000			     mov     dx,0	     ;
E71B  B9 0001			     mov     cx,1	     ; сектор 1 ,	дорожка 0
E71E  B0 01			     mov     al,1	     ; считывание первого	       +
			     сектора
E720  CD 13			     int     13h
E722  59		     h2:     pop     cx		     ; восстановить	счетчик	       +
			     повторений
E723  73 05			     jnc     h4		     ; уст CF при	безуспешном	       +
			     считывании
E725  E2 E0			     loop    h1		     ; цикл	повторения

			     ;	 Загрузка с НГМД недоступна

E727			     h3:			     ; кассета
E727  E9 F996			     jmp     err01   ; отсутствует дискет загрузки

			     ;	 Загрузка завершилась успешно

E72A			     h4:				     ;
E72A  EA 00007C00sr			     jmp far ptr boot_locn   ; db 0EAh,	00h, 7Ch, 00h, 00h   ;	       +
			     (0000:7C00)   ; ###Gleb###

E72F			     boot_strap	     endp
			     ;--------------------
			     ;	 Эта	программа посылает байт в	контроллер   +
			     адаптера НГМД
			     ; после проверки корректности управления и    +
			     готовности
			     ; контроллера.
			     ;	 Программа ожидает байт состояния		       +
			     определенное время
			     ; и проверяет готовность НГМД к работе.
			     ;
			     ;	 ВВОД   (AH) - выводимый байт
			     ;
			     ;	 ВЫВОД  CY=0 - успешно,
			     ;		CY=1 - не успешно.Состояние
			     ;		НГМД анализируется.
			     ;-----------------------
E72F			     nec_output	proc near
E72F  52			     push    dx		     ; сохранить регистры
E730  51			     push    cx
E731  BA 03F4			     mov     dx,03f4h	     ; состояние порта
E734  33 C9			     xor     cx,cx	     ; счетчик времени вывода
E736			     j23:
E736  EC			     in	     al,dx	     ; получить	состояние
E737  A8 40			     test    al,040h	     ; проверка	управляющих бит
E739  74 0C			     jz	     j25	     ; биты	управления		       +
			     нормальные
E73B  E2 F9			     loop    j23
E73D			     j24:
E73D  80 0E 0041r 80		     or	     diskette_status,time_out
E742  59			     pop     cx
E743  5A			     pop     dx	     ; установить код ошибки	и	       +
			     восстановить регистры
E744  58			     pop     ax		     ; адрес возврата
E745  F9			     stc		     ;
E746  C3			     ret

E747			     j25:
E747  33 C9			     xor     cx,cx	     ; обнуление счетчика
E749			     j26:
E749  EC			     in	     al,dx	     ; получить	состояние
E74A  A8 80			     test    al,080h	     ; проверка	готовности
E74C  75 04			     jnz     j27	     ; да - идти на выход
E74E  E2 F9			     loop    j26	     ; повторить
E750  EB EB			     jmp     short j24	     ; ошибка состояния
E752			     j27:			     ; выход
E752  8A C4			     mov     al,ah	     ; получить	байт
E754  BA 03F5			     mov     dx,03f5h	     ; переслать байт данных	в     +
			     порт
E757  EE			     out     dx,al
E758  59			     pop     cx		     ; восстановить	регистры
E759  5A			     pop     dx
E75A  C3			     ret		     ;
E75B			     nec_output	     endp

			     ;___int 16_________________
			     ;
			     ;	 Программа поддержки клавиатуры
			     ;
			     ;	 Эта	программа считывает в регистр
			     ; AX код сканирования клавиши и код
			     ; ASCII из буфера клавиатуры.
			     ;
			     ;	 Программа выполняет три функции, код
			     ; которых задается в регистре AH:
			     ;
			     ;	  AH=0 - считать	следующий символ
			     ;		  из буфера.При выходе	код
			     ;		  сканирования в AH,код
			     ;		  ASCII	в AL.
			     ;	 AH=1 -	установить ZF, если код
			     ;		  ASCII	прочитан:
			     ;
			     ;		  ZF=0 - буфер заполнен,
			     ;		  ZF=1 - буфер пустой.
			     ;	 При	выходе в	AX помещен адрес вершины	       +
			     буфера клавиатуры.
			     ;	 AH=2 -	возврат текущего	состояния в регистр AL
			     ;		   из	постоянно распределенной	области +
			     памяти с
			     ;		адресом 00417H.
			     ;
			     ;	 При	выполнении программ клавиатуры	       +
			     используются флажки,
			     ; которые устанавливаются в	постоянно	       +
			     распределенной области
			     ; памяти по адресам	00417H и 00418H и имеют значение:
			     ;	 00417H
			     ;	       0 - правое	переключение регистра;
			     ;	       1 - левое переключение регистра;
			     ;		  2 - УПР;
			     ;	       3 - ДОП;
			     ;	       4 - ФСД;
			     ;	       5 - ЦИФ;
			     ;	       6 - ФПБ;
			     ;	       7 - ВСТ;
			     ;	 00418H
			     ;	       0 - состояние клавиши ЛАТ между нажатием+
			     и	отжатием;
			     ;	       1 - ЛАТ;
			     ;	       2 - Р/Л;
			     ;	       3 - пауза;
			     ;	       4 - ФСД;
			     ;	       5 - ЦИФ;
			     ;	       6 - ФПБ;
			     ;	       7 - ВСТ.
			     ;
			     ;	 Флажки, соответствующие разрядам 4-7	       +
			     постоянно	распределенной
			     ; области памяти с адресом 00417H,			       +
			     устанавливаются по нажатию
			     ; клавиш ВСТ, ФПБ, ЦИФ, ФСД и сохраняют свои      +
			     значения до сле-
			     ; дующего нажатия соответствующей клавиши.
			     ; Одноименные флажки, соответствующие	       +
			     разрядам 4-7 постоянно
			     ; распределенной области памяти	с адресом      +
			     00418H, и	флажки
			     ; ДОП, УПР, левое переключение регистра,	       +
			     правое переключение
			     ; регистра, Р/Л устанавливаются по нажатию      +
			     клавиш и сбрасываются
			     ; по отжатию.
			     ;
			     ;------------------------------
				     assume  cs:code,ds:data


E75B			     k4	     proc    near
E75B  83 C3 02			     add     bx,2
E75E  81 FB 003Er		     cmp  bx, offset kb_buffer_end	      ;	конец буфера	?
E762  75 03			     jne     k5			      ;	нет - продолжить
E764  BB 001Er			     mov     bx, offset	kb_buffer     ;	да - уст начала буфера
E767			     k5:
E767  C3			     ret
E768			     k4	     endp

E768			     error_beep	proc near
E768  50			     push    ax
E769  53			     push    bx
E76A  51			     push    cx
E76B  BB 00C0			     mov     bx,0c0h
E76E  E4 61			     in	     al,kb_ctl
E770  50			     push    ax
E771			     k65:
E771  24 FC			     and     al,0fch
E773  E6 61			     out     kb_ctl,al
E775  B9 0048			     mov     cx,48h
E778  E2 FE		     k66:    loop    k66
E77A  0C 02			     or	     al,2
E77C  E6 61			     out     kb_ctl,al
E77E  B9 0048			     mov     cx,48h
E781  E2 FE		     k67:    loop    k67
E783  4B			     dec     bx
E784  75 EB			     jnz     k65
E786  58			     pop     ax
E787  E6 61			     out     kb_ctl,al
E789  59			     pop     cx
E78A  5B			     pop     bx
E78B  58			     pop     ax
E78C  C3			     ret
E78D			     error_beep	     endp

			     ;---

E78D			     k54:
E78D  3C 3B			     cmp     al,59
E78F  72 05			     jb	     k55
E791  B0 00			     mov     al,0
E793  EB 0F				     jmp     short k57
E795  90				     nop

E796  BB E8DCr		     k55:    mov     bx,offset k10
E799  F6 06 0018r 02		     test    kb_flag_1,lat
E79E  74 57			     jz	     k99

			     ;---

E7A0			     k56:
E7A0  FE C8			     dec     al
E7A2  2E: D7			     xlat    cs:k11

			     ;---

E7A4			     k57:
E7A4  3C FF			     cmp     al,-1
E7A6  74 2A			     je	     k59
E7A8  80 FC FF			     cmp     ah,-1
E7AB  74 25			     je	     k59
			     ;---

E7AD			     k58:
E7AD  F6 06 0017r 40		     test    kb_flag,caps_state
E7B2  74 2B			     jz	     k61

			     ;---
E7B4  F6 06 0018r 02		     test    kb_flag_1,lat
E7B9  75 03			     jnz     k88
E7BB  E9 1175			     jmp     k89
E7BE			     k88:
E7BE  F6 06 0017r 03		     test    kb_flag,left_shift+right_shift
E7C3  74 10			     jz	     k60

			     ;----------

E7C5  3C 41			     cmp     al,'A'
E7C7  72 16			     jb	     k61
E7C9  3C 5A			     cmp     al,'Z'
E7CB  77 12			     ja	     k61
E7CD  04 20			     add     al,'a'-'A'
E7CF  EB 0E				     jmp     short k61
E7D1  90				     nop

E7D2			     k59:
E7D2  E9 0316			     jmp     k26


E7D5			     k60:
E7D5  3C 61			     cmp     al,'a'
E7D7  72 06			     jb	     k61
E7D9  3C 7A			     cmp     al,'z'
E7DB  77 02			     ja	     k61
E7DD  2C 20			     sub     al,'a'-'A'

E7DF			     k61:
E7DF  8B 1E 001Cr		     mov     bx,buffer_tail
E7E3  8B F3			     mov     si,bx
E7E5  E8 FF73			     call   k4
E7E8  3B 1E 001Ar		     cmp     bx,buffer_head
E7EC  74 0E			     je	     k62
E7EE  89 04			     mov     word ptr [si],ax
E7F0  89 1E 001Cr		     mov     buffer_tail,bx
E7F4  E9 02F4			     jmp     k26
E7F7  BB F8CBr		     k99:    mov     bx,offset rust
E7FA  EB A4			     jmp k56

			     ;---

E7FC			     k62:
E7FC  E8 FF69			     call    error_beep
E7FF  E9 02E9			     jmp     k26

			     ;---

E802			     k63:
E802  2C 3B			     sub     al,59
E804			     k64:
E804  2E: D7			     xlat    cs:k9
E806  8A E0			     mov     ah,al
E808  B0 00			     mov     al,0
E80A  EB 98				     jmp     short k57
E80C  22*(00)				     db	34 dup(0)

			     ;---

E82E			     keyboard_io proc	     far
E82E  FB			     sti		     ;
E82F  1E			     push    ds
E830  53			     push    bx
E831  BB 0040			     mov     bx,dat
E834  8E DB			     mov     ds,bx	     ; установить сегмент данных
E836  0A E4			     or	     ah,ah	     ; AH=0
E838  74 0B			     jz	     k1		  ; переход к считыванию	       +
			     следующего символа
E83A  FE CC			     dec     ah		     ; AH=1
E83C  74 20			     jz	     k2		  ; переход к считыванию кода    +
			     ASCII
E83E  FE CC			     dec     ah			  ; AH=2
E840  74 2D			     jz	     k3		  ; переход к получению байта    +
			     состояния
E842  5B			     pop     bx			  ; восстановить регистр
E843  1F			     pop     ds
E844  CF			     iret

			     ;	 Считывание кода сканирования	и кода ASCII из +
			     буфера клавиатуры
			     ;
E845			     k1:
E845  FB			     sti	     ; уст признака разрешения	       +
			     прерывания
E846  90			     nop		     ; задержка
E847  FA			     cli	     ; сброс признака разрешения	       +
			     прерывания
E848  8B 1E 001Ar		     mov     bx,buffer_head  ; уст вершину буфера по	       +
			     чтению
E84C  3B 1E 001Cr		     cmp     bx,buffer_tail  ; сравнить	с вершиной	       +
			     буфера по записи
E850  74 F3			     jz	     k1
E852  8B 07			     mov     ax,word ptr [bx] ;	получить код			       +
			     сканирования и код	ASCII
E854  E8 FF04			     call    k4
E857  89 1E 001Ar		     mov     buffer_head,bx  ; запомнить вершину буфера  +
			     по чтению
E85B  5B			     pop     bx		     ; восстановить	регистр
E85C  1F			     pop     ds		     ; восстановить	сегмент
E85D  CF			     iret		     ; возврат к программе

			     ;	 Считать	код ASCII

E85E			     k2:
E85E  FA			     cli	     ; Сброс признака разрешения	       +
			     прерывания
E85F  8B 1E 001Ar		     mov     bx,buffer_head  ; получить	указатель	       +
			     вершины буфера
							     ; по чтению
E863  3B 1E 001Cr		     cmp     bx,buffer_tail  ; сравнить	с вершиной	       +
			     буфера по записи
E867  8B 07			     mov     ax,word ptr [bx]
E869  FB			     sti		     ; уст признак разрешения      +
			     прерывания
E86A  5B			     pop     bx		     ; восстановить	регистр
E86B  1F			     pop     ds		     ; восстановить	сегмент
E86C  CA 0002			     ret     2

			     ;	 Получение младшего байта	состояния	       +
			     (флажков)

E86F			     k3:
E86F  A0 0017r			     mov     al,kb_flag	     ; получить	младший байт	       +
			     состояния	    на
E872  5B			     pop     bx		     ; восстановить	регистр
E873  1F			     pop     ds		     ; восстановить	сегмент
E874  CF			     iret		     ; возврат к программе
E875			     keyboard_io     endp

			     ;	 Таблица	кодов сканирования управляющих     +
			     клавиш

E875			     k6	     label   byte
E875  52			     db	     ins_key
E876  56 45 46 38 1D		     db	     caps_key,num_key,scroll_key,alt_key,ctl_key
E87B  54 55			     db	     left_key,right_key
E87D  58			     db	     inv_key_l
E87E  5A 57 5B			     db	     inv_key_r,lat_key,rus_key
      =000C		     k6l     equ     0ch

			     ;	 Таблица	масок нажатых управляющих клавиш

E881			     k7	     label   byte
E881  80			     db	     ins_shift
E882  40 20 10 08 04		     db	     caps_shift,num_shift,scroll_shift,alt_shift,ctl_shift
E887  02 01			     db	     left_shift,right_shift


			     ;	 Таблица	кодов сканирования при нажатой      +
			     клавише УПР для
			     ; кодов сканирования клавиш	меньше 59

E889  1B FF 00 FF FF FF	1E+  k8	     db	     27,-1,0,-1,-1,-1,30,-1
      FF

E891  FF FF FF 1F FF 7F	FF+	     db	     -1,-1,-1,31,-1,127,-1,17
      11

E899  17 05 12 14 19 15	09+	     db	     23,5,18,20,25,21,9,15
      0F

E8A1  10 1B 1D 0A FF 01	13	     db	     16,27,29,10,-1,1,19

E8A8  04 06 07 08 0A 0B	0C+	     db	     4,6,7,8,10,11,12,-1,-1
      FF FF

E8B1  FF FF 1C 1A 18 03	16+	     db	     -1,-1,28,26,24,3,22,2
      02

E8B9  0E 0D FF FF FF FF	FF+	     db	     14,13,-1,-1,-1,-1,-1,-1
      FF

E8C1  20 FF			     db	     ' ',-1

			     ;	 Таблица	кодов сканирования при нажатой      +
			     клавише УПР для
			     ; кодов сканирования клавиш	больше 59
E8C3			     k9	     label   byte
E8C3  5E 5F 60 61 62 63	64+	     db	     94,95,96,97,98,99,100,101
      65

E8CB  66 67 FF FF 77 FF	84+	     db	     102,103,-1,-1,119,-1,132,-1
      FF

E8D3  73 FF 74 FF 75 FF	76+	     db	     115,-1,116,-1,117,-1,118,-1
      FF

E8DB  FF			     db	     -1

			     ;	 Таблица	кодов ASCII нижнего	регистра	       +
			     клавиатуры

E8DC			     k10     label   byte
E8DC  1B 31 32 33 34 35	36+	     db	     27,'1234567890-='
      37 38 39 30 2D 3D


E8E9  08 09			     db	     08h,09h
E8EB  71 77 65 72 74 79	75+	     db	     'qwertyuiop[]',0dh,-1,'asdfghjkl;:',60h,7eh
      69 6F 70 5B 5D 0D	FF+
      61 73 64 66 67 68	6A+
      6B 6C 3B 3A 60 7E




E906  5C 7A 78 63 76 62	6E+	     db	     05ch,'zxcvbnm',',./{'
      6D 2C 2E 2F 7B

E912  2A FF 20 7D		     db	     '*',-1,' }'

			     ;	 Таблица	кодов ASCII верхнего регистра	       +
			     клавиатуры

E916			     k11     label   byte
E916  1B 21 40 23 24 25	5E+	     db	     27,'!@#$',37,05eh,'&*()_+'
      26 2A 28 29 5F 2B


E923  08 00			     db	     08h,0
E925  51 57 45 52 54 59	55+	     db	     'QWERTYUIOP',-1,-1,0dh,-1
      49 4F 50 FF FF 0D	FF


E933  41 53 44 46 47 48	4A+	     db	     'ASDFGHJKL'
      4B 4C

E93C  27 22 FF FF 7C		     db	     027h,'"',-1,-1,7ch
E941  5A 58 43 56 42 4E	4D	     db	     'ZXCVBNM'

E948  3C 3E 3F FF 00 FF	20+	     db	     '<>?',-1,0,-1,' ',-1
      FF


			     ;	 Таблица	кодов сканирования клавиш Ф11 -	Ф20   +
			     (на верхнем
			     ; регистре	Ф1 - Ф10)

E950			     k12     label   byte
E950  54 55 56 57 58 59	5A	     db	     84,85,86,87,88,89,90

E957  5B 5C 5D			     db	     91,92,93

			     ;	 Таблица	кодов сканирования одновременно   +
			     нажатых клавиш
			     ; ДОП и Ф1 - Ф10

E95A			     k13     label byte
E95A  68 69 6A 6B 6C		     db	     104,105,106,107,108
E95F  6D 6E 6F 70 71		     db	     109,110,111,112,113

			     ;	 Таблица	кодов правого				       +
			     пятнадцатиклавишного поля на верхнем
			     ; регистре

E964			     k14     label   byte
E964  37 38 39 2D 34 35	36+	     db	     '789-456+1230.'
      2B 31 32 33 30 2E



			     ;	 Таблица	кодов правого				       +
			     пятнадцатиклавишного поля на нижнем
			     ; регистре

E971			     k15     label byte
E971  47 48 49 FF 4B FF	4D	     db	     71,72,73,-1,75,-1,77

E978  FF 4F 50 51 52 53		     db	     -1,79,80,81,82,83

E97E  09*(00)				     db	9 dup(0)

			     ;----INT 9--------------------------
			     ;
			     ;	  Программа обработки	прерывания		       +
			     клавиатуры
			     ;
			     ; Программа считывает код сканирования	       +
			     клавиши в регистр AL.
			     ; Единичное состояние разряда 7 в коде	       +
			     сканирования означает,
			     ; что клавиша отжата.
			     ;	 В результате выполнения программы в	       +
			     регистре AX формируется
			     ; слово, старший байт которого (AH) содержит      +
			     код сканирования,
			     ; а младший (AL) -	код ASCII. Эта информация	       +
			     помещается в буфер
			     ; клавиатуры. После	заполнения буфера	       +
			     подается звуковой сигнал.
			     ;
			     ;-----------------------------------

E987			     kb_int proc far
E987  FB			     sti		; установка признака		       +
			     разрешения прерывания
E988  50			     push    ax
E989  53			     push    bx
E98A  51			     push    cx
E98B  52			     push    dx
E98C  56			     push    si
E98D  57			     push    di
E98E  1E			     push    ds
E98F  06			     push    es
E990  FC			     cld		    ; установить признак	       +
			     направления вперед
E991  B8 0040			     mov     ax,dat	    ; установить адресацию
E994  8E D8			     mov     ds,ax
E996  E4 60			     in	     al,kb_dat	    ; считать код сканирования
E998  50			     push    ax
E999  E4 61			     in	     al,kb_ctl	    ; считать значение порта 61
E99B  8A E0			     mov     ah,al	    ; сохранить считанное	       +
			     значение
E99D  0C 80			     or	     al,80h	    ; установить бит 7 порта 61
E99F  E6 61			     out     kb_ctl,al	    ; для работы с клавиатурой
E9A1  86 E0			     xchg    ah,al	    ; восстановить значение	       +
			     порта	61
E9A3  E6 61			     out     kb_ctl,al
E9A5  58			     pop     ax		    ; восстановить код		       +
			     сканирования
E9A6  8A E0			     mov     ah,al	    ; и сохранить его в AH

			     ;---

E9A8  3C FF			     cmp     al,0ffh  ;	сравнение с кодом заполнения  +
			     буфера
						      ;	клавиатуры
E9AA  75 03			     jnz     k16	     ; продолжить
E9AC  E9 FE4D			     jmp     k62     ; переход на звуковой сигнал по  +
			     заполнению
						     ; буфера клавиатуры

E9AF			     k16:
E9AF  24 7F			     and     al,07fh	     ; сброс бита отжатия клавиши
E9B1  0E			     push    cs
E9B2  07			     pop     es
E9B3  BF E875r			     mov     di,offset k6  ; установить адрес таблицы    +
			     сканирования
							   ; управляющих клавиш
E9B6  B9 000C			     mov     cx,k6l
E9B9  F2> AE			     repne scasb     ; сравнение полученного кода      +
			     ска-
						     ; нирования с содержимым таблицы
E9BB  8A C4			     mov     al,ah	     ; запомнить код		       +
			     сканирования
E9BD  74 1A			     je	     k17	     ; переход по совпадению
E9BF  E9 010A			     jmp     k25	     ; переход по несовпадению
E9C2			     k406:
E9C2  F6 06 0018r 02		     test    kb_flag_1,lat
E9C7  75 7F			     jnz     k26a
E9C9  F6 06 0017r 03		     test    kb_flag,left_shift+right_shift
E9CE  B8 5CF1			     mov     ax,5cf1h
E9D1  74 03			     jz	     k407
E9D3  B8 5CF0			     mov     ax,5cf0h

			     ;	 Получение маски нажатой управляющей	       +
			     клавиши

E9D6			     k407:
E9D6  E9 FDCB			     jmp     k57

E9D9  81 EF E876r	     k17:    sub     di,offset k6+1
E9DD  83 FF 08			     cmp     di,8
E9E0  72 3B			     jb	     k300
E9E2  B4 06			     mov     ah,6
E9E4  83 FF 0A			     cmp     di,0ah
E9E7  72 39			     jb	     k301
E9E9  A8 80			     test    al,80h
E9EB  74 5B			     jz	     k26a
E9ED  80 26 0018r FC		     and     kb_flag_1,not lat+lat_shift
E9F2  83 FF 0B			     cmp     di,0bh
E9F5  74 17			     je	     k401
E9F7  F6 06 0018r 04		     test    kb_flag_1,inv_shift
E9FC  74 08			     jz	     k400
E9FE  80 0E 0018r 01		     or	     kb_flag_1,lat_shift
EA03  EB 43				     jmp     short k26a
EA05  90				     nop
EA06  80 0E 0018r 03	     k400:   or	     kb_flag_1,lat+lat_shift
EA0B  EB 3B				     jmp     short k26a
EA0D  90				     nop
EA0E  F6 06 0018r 04	     k401:   test    kb_flag_1,inv_shift
EA13  74 33			     jz	     k26a
EA15  80 0E 0018r 02		     or	     kb_flag_1,lat
EA1A  EB 2C				     jmp     short k26a
EA1C  90				     nop
EA1D  2E: 8A A5	E881r	     k300:   mov     ah,cs:k7[di]
EA22			     k301:
EA22  A8 80			     test    al,80h	     ; клавиша отжата ?
EA24  75 79			     jnz     k23     ; переход, если	клавиша отжата

			     ;	 Управляющая	клавиша нажата

EA26  80 FC 10			     cmp     ah,scroll_shift ; нажата управляющая	       +
			     клавиша с
							     ;	запоминанием ?
EA29  73 20			     jae     k18	     ; переход, если	да

			     ;---
EA2B  80 FC 06			     cmp     ah,6
EA2E  74 07			     je	     k302

EA30  08 26 0017r		     or	     kb_flag,ah	     ; установка масок		       +
			     управляющих клавиш
							     ; без запоминания
EA34  E9 00B4			     jmp     k26	     ; к выходу из прерывания
EA37  80 0E 0018r 06	     k302:   or	     kb_flag_1,inv_shift+lat
EA3C  F6 06 0018r 01		     test    kb_flag_1,lat_shift
EA41  74 05			     jz	     k26a
EA43  80 26 0018r FD		     and     kb_flag_1,not lat
EA48			     k26a:
EA48  E9 00A0			     jmp     k26

			     ;	 Опрос нажатия клавиши с запоминанием

EA4B			     k18:
EA4B  F6 06 0017r 04		     test    kb_flag,ctl_shift	       ; опрос клавиши УПР
EA50  75 7A			     jnz     k25
EA52  3C 52			     cmp     al,ins_key		       ; опрос клавиши ВСТ
EA54  75 25			     jnz     k22
EA56  F6 06 0017r 08		     test    kb_flag,alt_shift	       ; опрос клавиши ДОП
EA5B  74 03			     jz	     k19
EA5D  EB 6D				     jmp     short k25
EA5F  90				     nop
EA60  F6 06 0017r 20	     k19:    test    kb_flag,num_state	; опрос клавиши ЦИФ
EA65  75 0D			     jnz     k21
EA67  F6 06 0017r 03		     test    kb_flag,left_shift+right_shift ; опрос клавиш	       +
			     левого
							  ; и правого переключения	       +
			     регистров
EA6C  74 0D			     jz	     k22

EA6E			     k20:
EA6E  B8 5230			     mov     ax,5230h
EA71  E9 FD30			     jmp     k57	   ; установка	кода нуля
EA74			     k21:
EA74  F6 06 0017r 03		     test    kb_flag,left_shift+right_shift
EA79  74 F3			     jz	     k20

EA7B			     k22:
EA7B  84 26 0018r		     test    ah,kb_flag_1
EA7F  75 6A			     jnz     k26
EA81  08 26 0018r		     or	     kb_flag_1,ah
EA85  30 26 0017r		     xor     kb_flag,ah
EA89  3C 52			     cmp     al,ins_key
EA8B  75 5E			     jne     k26
EA8D  B8 5200			     mov     ax,ins_key*256
EA90  E9 FD11			     jmp     k57

EA93			     k303:
EA93  80 26 0018r FB		     and     kb_flag_1,not inv_shift
EA98  80 36 0018r 02		     xor     kb_flag_1,lat
EA9D  EB 10			     jmp     short k304

			     ;	 Управляющая	клавиша отжата

EA9F			     k23:

EA9F  80 FC 10			     cmp     ah,scroll_shift
EAA2  73 1F			     jae     k24
EAA4  F6 D4			     not     ah
EAA6  80 FC F9			     cmp     ah,0f9h
EAA9  74 E8			     je	     k303
EAAB  20 26 0017r		     and     kb_flag,ah
EAAF			     k304:
EAAF  3C B8			     cmp     al,alt_key+80h
EAB1  75 38			     jne     k26

			     ;---

EAB3  A0 0019r			     mov     al,alt_input
EAB6  B4 00			     mov     ah,0
EAB8  88 26 0019r		     mov     alt_input,ah
EABC  3C 00			     cmp     al,0
EABE  74 2B			     je	     k26
EAC0  E9 FCEA			     jmp     k58

EAC3			     k24:
EAC3  F6 D4			     not     ah
EAC5  20 26 0018r		     and     kb_flag_1,ah
EAC9  EB 20				     jmp     short k26
EACB  90				     nop

EACC			     k25:
EACC  3C 80			     cmp     al,80h
EACE  73 1B			     jae     k26
EAD0  3C 59			     cmp     al,inf_key
EAD2  74 25			     je	     k307
EAD4  3C 5C			     cmp     al,92
EAD6  75 03			     jne     k406b
EAD8  E9 FEE7			     jmp     k406
EADB			     k406b:
EADB  F6 06 0018r 08		     test    kb_flag_1,hold_state
EAE0  74 1D			     jz	     k28
EAE2  3C 45			     cmp     al,num_key
EAE4  74 05			     je	     k26
EAE6  80 26 0018r F7		     and     kb_flag_1,not hold_state

EAEB			     k26:
EAEB  FA			     cli
EAEC  B0 20			     mov     al,eoi
EAEE  E6 20			     out     020h,al
EAF0			     k27:
EAF0  07			     pop     es
EAF1  1F			     pop     ds
EAF2  5F			     pop     di
EAF3  5E			     pop     si
EAF4  5A			     pop     dx
EAF5  59			     pop     cx
EAF6  5B			     pop     bx
EAF7  58			     pop     ax
EAF8  CF			     iret

EAF9  B8 A000		     k307:   mov     ax,0a000h
EAFC  E9 FCA5			     jmp     k57


			     ;---

EAFF			     k28:
EAFF  F6 06 0017r 08		     test    kb_flag,alt_shift
EB04  75 03			     jnz     k29
EB06  EB 6D				     jmp     short k38
EB08  90				     nop

			     ;---

EB09			     k29:
EB09  F6 06 0017r 04		     test    kb_flag,ctl_shift
EB0E  74 0F			     jz	     k31
EB10  3C 53			     cmp     al,del_key
EB12  75 0B			     jne     k31

			     ;---

EB14  C7 06 0072r 1234		     mov     reset_flag,1234h
EB1A  EA			     db	     0eah		     ;	     db	     0eah,5bh,0e0h,00h,0f0h  ; +
			     jmp far ptr start
EB1B  E06Cr F000		     dw	     offset start, cod	     ;	     ###Gleb###

			     ;---




EB1F			     k31:
EB1F  3C 39			     cmp     al,57
EB21  75 05			     jne     k32
EB23  B0 20			     mov     al,' '
EB25  E9 FC7C			     jmp     k57

			     ;---

EB28			     k32:
EB28  BF F905r			     mov     di,offset k30
EB2B  B9 000A			     mov     cx,10
EB2E  F2> AE				     repne scasb
EB30  75 12			     jne     k33
EB32  81 EF F906r		     sub     di,offset k30+1
EB36  A0 0019r			     mov     al,alt_input
EB39  B4 0A			     mov     ah,10
EB3B  F6 E4			     mul     ah
EB3D  03 C7			     add     ax,di
EB3F  A2 0019r			     mov     alt_input,al
EB42  EB A7				     jmp     short k26

			     ;---

EB44			     k33:
EB44  C6 06 0019r 00		     mov     alt_input,00h
EB49  B9 001A			     mov     cx,0026
EB4C  F2> AE				     repne scasb
EB4E  75 05			     jne     k34
EB50  B0 00			     mov     al,0
EB52  E9 FC4F			     jmp     k57

			     ;---

EB55			     k34:
EB55  3C 02			     cmp     al,2
EB57  72 0C			     jb	     k35
EB59  3C 0E			     cmp     al,14
EB5B  73 08			     jae     k35
EB5D  80 C4 76			     add     ah,118
EB60  B0 00			     mov     al,0
EB62  E9 FC3F			     jmp     k57

			     ;---

EB65			     k35:
EB65  3C 3B			     cmp     al,59
EB67  73 02			     jae     k37
EB69			     k36:
EB69  EB 80				     jmp     short k26
EB6B			     k37:
EB6B  3C 47			     cmp     al,71
EB6D  73 FA			     jae     k36
EB6F  BB E95Ar			     mov     bx,offset k13
EB72  E9 FC8D			     jmp     k63

			     ;---

EB75			     k38:
EB75  F6 06 0017r 04		     test    kb_flag,ctl_shift
EB7A  74 5B			     jz	     k44

			     ;---
			     ;---

EB7C  3C 46			     cmp     al,scroll_key
EB7E  75 18			     jne     k39
EB80  BB 001Er			     mov     bx,offset kb_buffer
EB83  89 1E 001Ar		     mov     buffer_head,bx
EB87  89 1E 001Cr		     mov     buffer_tail,bx
EB8B  C6 06 0071r 80		     mov     bios_break,80h
EB90  CD 1B			     int     1bh
EB92  B8 0000			     mov     ax,0
EB95  E9 FC0C			     jmp     k57

EB98			     k39:
EB98  3C 45			     cmp     al,num_key
EB9A  75 21			     jne     k41
EB9C  80 0E 0018r 08		     or	     kb_flag_1,hold_state
EBA1  B0 20			     mov     al,eoi
EBA3  E6 20			     out     020h,al

			     ;---

EBA5  80 3E 0049r 07		     cmp     crt_mode,7
EBAA  74 07			     je	     k40
EBAC  BA 03D8			     mov     dx,03d8h
EBAF  A0 0065r			     mov     al,crt_mode_set
EBB2  EE			     out     dx,al
EBB3			     k40:
EBB3  F6 06 0018r 08		     test    kb_flag_1,hold_state
EBB8  75 F9			     jnz     k40
EBBA  E9 FF33			     jmp     k27
EBBD			     k41:

			     ;---

EBBD  3C 37			     cmp     al,55
EBBF  75 06			     jne     k42
EBC1  B8 7200			     mov     ax,114*256
EBC4  E9 FBDD			     jmp     k57

			     ;---

EBC7			     k42:
EBC7  BB E889r			     mov     bx,offset k8
EBCA  3C 3B			     cmp     al,59
EBCC  73 03			     jae     k43
EBCE  E9 FBCF			     jmp     k56
EBD1			     k43:
EBD1  BB E8C3r			     mov     bx,offset k9
EBD4  E9 FC2B			     jmp     k63

			     ;---

EBD7			     k44:

EBD7  3C 47			     cmp     al,71
EBD9  73 3E			     jae     k48
EBDB  F6 06 0017r 03		     test    kb_flag,left_shift+right_shift
EBE0  74 0A			     jz	     k54a

			     ;---

EBE2  3C 0F			     cmp     al,15
EBE4  75 09			     jne     k45
EBE6  B8 0F00			     mov     ax,15*256
EBE9  E9 FBB8			     jmp     k57

EBEC			     k54a:
EBEC  E9 FB9E			     jmp k54

EBEF			     k45:
EBEF  3C 37			     cmp     al,55
EBF1  75 09			     jne     k46

			     ;---

EBF3  B0 20			     mov     al,eoi
EBF5  E6 20			     out     020h,al
EBF7  CD 05			     int     5h
EBF9  E9 FEF4			     jmp     k27

EBFC			     k46:
EBFC  3C 3B			     cmp     al,59
EBFE  72 06			     jb	     k47
EC00  BB E950r			     mov     bx,offset k12
EC03  E9 FBFC			     jmp     k63

EC06			     k47:
EC06  F6 06 0018r 02		     test    kb_flag_1,lat
EC0B  74 06			     jz	     k98
EC0D  BB E916r			     mov     bx,offset k11
EC10  E9 FB8D			     jmp      k56
EC13  BB E6BDr		     k98:    mov     bx,offset rust2
EC16  E9 FB87			     jmp     k56

			     ;---

EC19			     k48:
EC19  F6 06 0017r 20		     test    kb_flag,num_state
EC1E  75 23			     jnz     k52
EC20  F6 06 0017r 03		     test    kb_flag,left_shift+right_shift
EC25  75 23			     jnz     k53

			     ;---

EC27			     k49:

EC27  3C 4A			     cmp     al,74
EC29  74 0C			     je	     k50
EC2B  3C 4E			     cmp     al,78
EC2D  74 0E			     je	     k51
EC2F  2C 47			     sub     al,71
EC31  BB E971r			     mov     bx,offset k15
EC34  E9 FBCD			     jmp       k64

EC37  B8 4A2D		     k50:    mov     ax,74*256+'-'
EC3A  E9 FB67			     jmp      k57

EC3D  B8 4E2B		     k51:    mov     ax,78*256+'+'
EC40  E9 FB61			     jmp      k57

			     ;---

EC43			     k52:
EC43  F6 06 0017r 03		     test    kb_flag,left_shift+right_shift
EC48  75 DD			     jnz     k49

EC4A			     k53:
EC4A  2C 46			     sub     al,70
EC4C  BB E964r			     mov     bx,offset k14
EC4F  E9 FB4E			     jmp      k56
EC52			     kb_int  endp

EC52  07*(00)				     db	7 dup(0)

			     ;--- int 13H---------
			     ;	 Программа обслуживания накопителя на	       +
			     гибком магнитном
			     ; диске выполняет шесть	функций,	код которых  +
			     задается
			     ; в регистре AH:
			     ;	 AH=0 -	сбросить  НГМД;
			     ;	 AH=1 -	считать байт	состояния НГМД. Состояние+
			     соответствует
			     ; последней выполняемой операции и		       +
			     передается в регистр AL из
			     ; постоянно распределенной области		       +
			     оперативной памяти с адресом
			     ; 00441H;
			     ;	  AH=2H	- считать указанный сектор в память;
			     ;	  AH=3H	- записать указанный сектор из	памяти;
			     ;	  AH=4H	- верификация;
			     ;	  AH=5H	- форматизация.
			     ;	  Для выполнения функций записи,		       +
			     считывания, верификации,
			     ; форматизации	в регистрах задается		       +
			     следующая	информация:
			     ;	  DL - номер устройства (0-3, контролируемое      +
			     значение);
			     ;	  DH - номер головки (0-1, неконтролируемое	       +
			     значение);
			     ;	  CH - номер дорожки (0-39,	неконтролируемое       +
			     значение);
			     ;	  CL - номер сектора (1-8, неконтролируемое	       +
			     значение);
			     ;	  AL - количество секторов (1-8,			       +
			     неконтролируемое значение).
			     ;
			     ;	  Для выполнения форматизации необходимо    +
			     сформировать в
			     ; памяти четырехбайтную таблицу	для каждого  +
			     сектора, содержащую
			     ; следующую информацию:
			     ;	  номер дорожки;
			     ;	  номер головки;
			     ;	  номер сектора;
			     ;	  количество байт	в секторе (00 -	128 байт, 01 - 256 +
			     байт,
			     ; 02 - 512	байт, 03 - 1024 байта).
			     ;	  Адрес таблицы задается в	регистрах ES:BX.
			     ;
			     ;	  После выполнения программы в	регистре AH    +
			     находится
			     ; байт	состояния НГМД.
			     ;
			     ;	  Байт состояния НГМД имеет следующее	       +
			     значение:
			     ;	  80 - тайм-аут;
			     ;	  40 - сбой	позиционирования;
			     ;	  20 - сбой	контроллера;
			     ;	  10 - ошибка кода циклического контроля при  +
			     считывании;
			     ;	  09 - переход адреса через сегмент (64К байт);
			     ;	  08 - переполнение;
			     ;	  04 - сектор не найден;
			     ;	  03 - защита записи;
			     ;	  02 - не обнаружен маркер идентификатора       +
			     сектора;
			     ;	  01 - команда отвергнута.
			     ;	  При успешном завершении программы	       +
			     признак CF=0,  в про-
			     ; тивном случае - признак CF=1 (регистр AH	       +
			     содержит код ошибки).
			     ;	  Регистр AL содержит количество реально       +
			     считанных	секторов.
			     ;	  Адрес программы	обслуживания накопителя  +
			     на гибком магнитном
			     ; диске записывается в вектор 40H в процедуре   +
			     сброса по включению
			     ; питания.
			     ;-------------------------
				     assume  cs:code,ds:data,es:data
EC59			     diskette_io proc	     far
EC59  FB			     sti		     ; установить признак	       +
			     прерывания
EC5A  53			     push    bx		     ; сохранить адрес
EC5B  51			     push    cx
EC5C  1E			     push    ds		; сохранить сегментное	       +
			     значение регистра
EC5D  56			     push    si		; сохранить все регистры во      +
			     время	операции
EC5E  57			     push    di
EC5F  55			     push    bp
EC60  52			     push    dx
EC61  8B EC			     mov     bp,sp	; установить указатель	       +
			     вершины стека
EC63  BE 0040			     mov     si,dat
EC66  8E DE			     mov     ds,si	     ; установить область данных
EC68  E8 001C			     call    j1		     ;
EC6B  BB 0004			     mov     bx,4	     ; получить	параметры	       +
			     ожидания мотора
EC6E  E8 01E0			     call    get_parm
EC71  88 26 0040r		     mov     motor_count,ah  ; уст время отсчета	для	       +
			     мотора
EC75  8A 26 0041r		     mov     ah,diskette_status	 ; получить состояние	       +
			     операции
EC79  80 FC 01			     cmp     ah,1	     ; уст признак CF	для		       +
			     индикации
EC7C  F5			     cmc		     ; успешной	операции
EC7D  5A			     pop     dx		     ; восстановить	все регистры
EC7E  5D			     pop     bp
EC7F  5F			     pop     di
EC80  5E			     pop     si
EC81  1F			     pop     ds
EC82  59			     pop     cx
EC83  5B			     pop     bx
EC84  CA 0002			     ret     2
EC87			     diskette_io     endp
EC87			     j1	     proc    near
EC87  8A F0			     mov     dh,al	     ; сохранить количество	       +
			     секторов
EC89  80 26 003Fr 7F		     and     motor_status,07fh	 ; указать операцию	       +
			     считывания
EC8E  0A E4			     or	     ah,ah	     ; AH=0
EC90  74 27			     jz	     disk_reset
EC92  FE CC			     dec     ah		     ; AH=1
EC94  74 74			     jz	     disk_status
EC96  C6 06 0041r 00		     mov     diskette_status,0	 ; сброс состояния
EC9B  80 FA 04			     cmp     dl,4	     ; проверка	количества	       +
			     устройств
EC9E  73 13			     jae     j3		     ; переход по ошибке
ECA0  FE CC			     dec     ah		     ; AH=2
ECA2  74 6A			     jz	     disk_read
ECA4  FE CC			     dec     ah		     ; AH=3
ECA6  75 03			     jnz     j2
ECA8  E9 0096			     jmp     disk_write
ECAB			     j2:
ECAB  FE CC			     dec     ah		     ; AH=4
ECAD  74 68			     jz	     disk_verf
ECAF  FE CC			     dec     ah		     ; AH=5
ECB1  74 68			     jz	     disk_format
ECB3			     j3:
ECB3  C6 06 0041r 01		     mov     diskette_status,bad_cmd   ; неверная команда

ECB8  C3			     ret		     ; операция	не определена
ECB9			     j1	     endp

			     ;	 Сбросить НГМД

ECB9			     disk_reset	proc near
ECB9  BA 03F2			     mov     dx,03f2h
ECBC  FA			     cli		     ; сброс признака разрешения+
			     прерывания
ECBD  A0 003Fr			     mov     al,motor_status  ;	какой мотор включен
ECC0  B1 04			     mov     cl,4	     ; счетчик сдвига
ECC2  D2 E0			     sal     al,cl
ECC4  A8 20			     test    al,20h	     ; выбрать соответствующее   +
			     устройство
ECC6  75 0C			     jnz     j5		     ; переход, если	включен	       +
			     мотор	первого
							     ; устройства
ECC8  A8 40			     test    al,40h
ECCA  75 06			     jnz     j4		     ; переход, если	включен	       +
			     мотор	второго
							     ; устройства
ECCC  A8 80			     test    al,80h
ECCE  74 06			     jz	     j6		     ; переход, если	включен	       +
			     мотор	нулевого
							     ; устройства
ECD0  FE C0			     inc     al
ECD2  FE C0		     j4:     inc     al
ECD4  FE C0		     j5:     inc     al
ECD6  0C 08		     j6:     or	     al,8	     ; включить	доступность	       +
			     прерывания
ECD8  EE			     out     dx,al	     ; сброс адаптера
ECD9  C6 06 003Er 00		     mov     seek_status,0
ECDE  C6 06 0041r 00		     mov     diskette_status,0	; уст нормальное		       +
			     состояние	НГМД
ECE3  0C 04			     or	     al,4	     ; выключить сброс
ECE5  EE			     out     dx,al
ECE6  FB			     sti		     ; установить бит разрешения+
			     прерывания
ECE7  E8 0225			     call    chk_stat_2	     ; выполнить прерывание	       +
			     после	сброса
ECEA  A0 0042r			     mov     al,nec_status
ECED  3C C0			     cmp     al,0c0h	; проверка готовности		       +
			     устройства для передачи
ECEF  74 07			     jz	     j7		     ; устройство готово
ECF1  80 0E 0041r 20		     or	     diskette_status,bad_nec  ;	уст код ошибки
ECF6  EB 11			     jmp     short j8

			     ;	 Послать	команду в контроллер

ECF8			     j7:
ECF8  B4 03			     mov     ah,03h	     ; установить команду
ECFA  E8 FA32			     call    nec_output	     ; передать	команду
ECFD  BB 0001			     mov     bx,1	     ; передача	первого байта      +
			     параметров
ED00  E8 014E			     call    get_parm	     ; в контроллер
ED03  BB 0003			     mov     bx,3	     ; передача	второго байта      +
			     параметров
ED06  E8 0148			     call    get_parm	     ; в контроллер
ED09			     j8:
ED09  C3			     ret		     ; возврат к прерванной	       +
			     программе
ED0A			     disk_reset	     endp

			     ;
			     ; Считать байт состояния НГМД (AH=1)
			     ;

ED0A			     disk_status proc near
ED0A  A0 0041r			     mov     al,diskette_status
ED0D  C3			     ret
ED0E			     disk_status     endp

			     ;	 Считать	указанный сектор	в память	(AH=2)

ED0E			     disk_read proc near
ED0E  B0 46			     mov     al,046h	     ; установить команду
ED10			     j9:
ED10  E8 01B6			     call    dma_setup	     ; установить ПДП
ED13  B4 E6			     mov     ah,0e6h	 ; уст команду считывания	       +
			     контроллера
ED15  EB 36			     jmp     short rw_opn    ; переход к выполнению	       +
			     операции
ED17			     disk_read	     endp

			     ;	 Верификация	(AH=4)

ED17			     disk_verf proc near
ED17  B0 42			     mov     al,042h	     ; установить команду
ED19  EB F5			     jmp     short j9
ED1B			     disk_verf	     endp

			     ;	 Форматизация (AH=5)

ED1B			     disk_format proc near
ED1B  80 0E 003Fr 80		     or	     motor_status,80h  ; индикация операции	       +
			     записи
ED20  B0 4A			     mov     al,04ah	       ; установить команду
ED22  E8 01A4			     call    dma_setup	       ; установить ПДП
ED25  B4 4D			     mov     ah,04dh	       ; установить команду
ED27  EB 24			     jmp     short rw_opn
ED29			     j10:
ED29  BB 0007			     mov     bx,7	       ; получить значение	       +
			     сектора
ED2C  E8 0122			     call    get_parm
ED2F  BB 0009			     mov     bx,9	     ; получить	значение дорожки+
			     на секторе
ED32  E8 011C			     call    get_parm
ED35  BB 000F			     mov     bx,15	     ; получить	значение длины    +
			     интервала
ED38  E8 0116			     call    get_parm	     ; для контроллера
ED3B  BB 0011			     mov     bx,17	     ; получить	полный байт
ED3E  E9 00B8			     jmp     j16
ED41			     disk_format     endp

			     ;	 Записать указанный сектор из памяти (AH=3)

ED41			     disk_write	proc near
ED41  80 0E 003Fr 80		     or	     motor_status,80h	     ; индикация операции     +
			     записи
ED46  B0 4A			     mov     al,04ah		     ; уст код операции	       +
			     записи
ED48  E8 017E			     call    dma_setup
ED4B  B4 C5			     mov     ah,0c5h		     ; команда записи на	НГМД
ED4D			     disk_write	     endp

			     ;______________________
			     ; rw_opn
			     ;	 Программа выполнения операций
			     ;	 считывания, записи, верификации
			     ;----------------------
ED4D			     rw_opn  proc    near
ED4D  73 08			     jnc     j11	     ; проверка	ошибки ПДП
ED4F  C6 06 0041r 09		     mov     diskette_status,dma_boundary   ; установить ошибку
ED54  B0 00			     mov     al,0	     ;
ED56  C3			     ret		     ; возврат к основной	       +
			     программе
ED57			     j11:
ED57  50			     push    ax		     ; сохранить команду

			     ;	 Включить мотор и	выбрать устройство

ED58  51			     push    cx
ED59  8A CA			     mov     cl,dl	     ; уст номер устройства, как  +
			     счетчик сдвига
ED5B  B0 01			     mov     al,1	     ; маска для определения	       +
			     мотора устройства
ED5D  D2 E0			     sal     al,cl	     ; сдвиг
ED5F  FA			     cli		     ; сбросить	бит разрешения    +
			     прерывания
ED60  C6 06 0040r FF		     mov     motor_count,0ffh  ; установить счетчик
ED65  84 06 003Fr		     test    al,motor_status
ED69  75 3F			     jnz     j14
ED6B  80 26 003Fr F0		     and     motor_status,0f0h	; выключить все биты	       +
			     мотора
ED70  08 06 003Fr		     or	     motor_status,al	; включить мотор
ED74  FB			     sti		     ; установить бит разрешения+
			     прерывания
ED75  B0 10			     mov     al,10h	     ; бит маски
ED77  D2 E0			     sal     al,cl	     ; уст бит маски	для		       +
			     доступности мотора
ED79  0A C2			     or	     al,dl	     ; включить	бит выбора	       +
			     устройства
ED7B  0C 0C			     or	     al,0ch	     ; нет сброса, доступность     +
			     прерывания ПДП
ED7D  52			     push    dx
ED7E  BA 03F2			     mov     dx,03f2h	     ; установить адрес порта
ED81  EE			     out     dx,al
ED82  5A			     pop     dx		     ; восстановить	регистры
ED83  51			     push    cx		     ;задержка для включения       +
			     мотора устройства
ED84  B9 0003			     mov     cx,3
ED87  51		     x2:     push    cx
ED88  B9 0000			     mov     cx,0
ED8B  E2 FE		     x1:     loop    x1
ED8D  59			     pop     cx
ED8E  E2 F7			     loop    x2
ED90  59			     pop     cx

			     ;	 Ожидание включения мотора для операции      +
			     записи

ED91  F6 06 003Fr 80		     test    motor_status,80h  ; запись ?
ED96  74 12			     jz	     j14     ; нет -	продолжать без ожидания
ED98  BB 0014			     mov     bx,20	     ; установить ожидание	       +
			     включения	мотора
ED9B  E8 00B3			     call    get_parm	     ; получить	параметры
ED9E  0A E4			     or	     ah,ah
EDA0			     j12:
EDA0  74 08			     jz	     j14	     ; выход по окончании	       +
			     времени ожидания
EDA2  2B C9			     sub     cx,cx	     ; установить счетчик
EDA4  E2 FE		     j13:    loop    j13	     ; ожидать требуемое время
EDA6  FE CC			     dec     ah		     ; уменьшеть значение	       +
			     времени
EDA8  EB F6			     jmp     short j12	     ; повторить цикл

EDAA			     j14:
EDAA  FB			     sti		     ; уст признак разрешения      +
			     прерывания
EDAB  59			     pop     cx

			     ;	 Выполнить операцию поиска

EDAC  E8 00B8			     call    seek	     ; установить дорожку
EDAF  58			     pop     ax		     ; восстановить	команду
EDB0  8A FC			     mov     bh,ah	     ; сохранить команду в BH
EDB2  B6 00			     mov     dh,0	     ; уст 0	сектор в	случае	       +
			     ошибки
EDB4  72 4A			     jc	     j17	     ; выход, если ошибка
EDB6  BE EE00r			     mov     si,offset j17

EDB9  56			     push    si

			     ;	 Послать	параметры в контроллер

EDBA  E8 F972			     call    nec_output	     ; передача	команды
EDBD  8A 66 01			     mov     ah,byte ptr [bp+1]	 ; уст номер головки
EDC0  D0 E4			     sal     ah,1	     ; сдвиг на 2
EDC2  D0 E4			     sal     ah,1
EDC4  80 E4 04			     and     ah,4	     ; выделить	бит
EDC7  0A E2			     or	     ah,dl	     ; операция	OR с номером	       +
			     устройства
EDC9  E8 F963			     call    nec_output

			     ;	 Проверка операции форматизации

EDCC  80 FF 4D			     cmp     bh,04dh	     ; форматизация	?
EDCF  75 03			     jne     j15    ; нет - продолжать			       +
			     запись/считывание/верификацию
EDD1  E9 FF55			     jmp     j10

EDD4  8A E5		     j15:    mov     ah,ch	     ; номер цилиндра
EDD6  E8 F956			     call    nec_output
EDD9  8A 66 01			     mov     ah,byte ptr [bp+1]	 ; номер головки
EDDC  E8 F950			     call    nec_output
EDDF  8A E1			     mov     ah,cl	     ; номер сектора
EDE1  E8 F94B			     call    nec_output
EDE4  BB 0007			     mov     bx,7
EDE7  E8 0067			     call    get_parm
EDEA  BB 0009			     mov     bx,9
EDED  E8 0061			     call    get_parm
EDF0  BB 000B			     mov     bx,11
EDF3  E8 005B			     call    get_parm
EDF6  BB 000D			     mov     bx,13
EDF9			     j16:
EDF9  E8 0055			     call    get_parm
EDFC  5E			     pop     si

			     ;	 Операция запущена

EDFD  E8 0130			     call    wait_int	     ; ожидание	прерывания
EE00			     j17:
EE00  72 45			     jc	     j21	     ; поиск ошибки
EE02  E8 0166			     call    results	     ; получить	состояние	       +
			     контроллера
EE05  72 3F			     jc	     j20	     ; поиск ошибки

			     ;	 Проверка  состояния, полученного из	       +
			     контроллера

EE07  FC			     cld		     ; установить направление     +
			     коррекции
EE08  BE 0042r			     mov     si,offset nec_status
EE0B  AC			     lods    nec_status
EE0C  24 C0			     and     al,0c0h	     ; проверить нормальное	       +
			     окончание
EE0E  74 3B			     jz	     j22
EE10  3C 40			     cmp     al,040h	     ; проверить неверное	       +
			     окончание
EE12  75 29			     jnz     j18

			     ;	 Обнаруженно	неверное окончание

EE14  AC			     lods    nec_status
EE15  D0 E0			     sal     al,1
EE17  B4 04			     mov     ah,record_not_fnd
EE19  72 24			     jc	     j19
EE1B  D0 E0			     sal     al,1
EE1D  D0 E0			     sal     al,1
EE1F  B4 10			     mov     ah,bad_crc
EE21  72 1C			     jc	     j19
EE23  D0 E0			     sal     al,1
EE25  B4 08			     mov     ah,bad_dma
EE27  72 16			     jc	     j19
EE29  D0 E0			     sal     al,1
EE2B  D0 E0			     sal     al,1
EE2D  B4 04			     mov     ah,record_not_fnd
EE2F  72 0E			     jc	     j19
EE31  D0 E0			     sal     al,1
EE33  B4 03			     mov     ah,write_protect  ; проверка защиты записи
EE35  72 08			     jc	     j19
EE37  D0 E0			     sal     al,1
EE39  B4 02			     mov     ah,bad_addr_mark
EE3B  72 02			     jc	     j19

			     ;	 Контроллер вышел из строя

EE3D			     j18:
EE3D  B4 20			     mov     ah,bad_nec
EE3F			     j19:
EE3F  08 26 0041r		     or	     diskette_status,ah
EE43  E8 016A			     call    num_trans
EE46			     j20:
EE46  C3			     ret	     ; возврат к программе, вызвавшей+
			     прерывание

EE47			     j21:
EE47  E8 0121			     call    results	     ; вызов результатов в буфер
EE4A  C3			     ret

			     ;	 Операция была успешной

EE4B			     j22:
EE4B  E8 0162			     call    num_trans
EE4E  32 E4			     xor     ah,ah	     ; нет ошибок
EE50  C3			     ret
EE51			     rw_opn  endp
			     ;------------------------
			     ;get_parm
			     ;
			     ;	 ВХОД   BX - индекс байта,деленный
			     ;		     на 2,который будет
			     ;		     выбран,если младший
			     ;		     бит BX установлен,то
			     ;		     байт немедленно пере-
			     ;		     дается контроллеру.
			     ;
			     ;	 ВЫХОД  AH	- байт из	блока.
			     ;-------------------------
EE51			     get_parm proc   near
EE51  1E			     push    ds		     ; сохранить сегмент
EE52  2B C0			     sub     ax,ax	     ; AX=0
EE54  8E D8			     mov     ds,ax
				     assume  ds:abs0
EE56  C5 36 0078r		     lds     si,disk_pointer
EE5A  D1 EB			     shr     bx,1	     ; делить BX на 2, уст флаг для  +
			     выхода
EE5C  8A A0 0000r		     mov     ah,zb[si+bx]    ; получить	слово
EE60  1F			     pop     ds		     ; восстановить	сегмент
				     assume  ds:data
EE61  72 01			     jc	     nec_op	      ;если	флаг установлен,	       +
			     выход
EE63  C3			     ret	     ; возврат к программе, вызвавшей+
			     прерывание
EE64  E9 F8C8		     nec_op: jmp     nec_output
EE67			     get_parm endp
			     ;----------------------------
			     ;	 Позиционирование
			     ;
			     ;	 Эта	программа позиционирует голов-
			     ; ку обозначенного устройства на нуж-
			     ; ную дорожку. Если устройство не
			     ; было	выбрано до тех пор, пока не
			     ; была	сброшена команда,то устройство
			     ; будет рекалибровано.
			     ;
			     ;	 ВВОД
			     ;	     (DL) - номер усройства для
			     ;		    позиционирования,
			     ;	     (CH) - номер дорожки.
			     ;
			     ;	 ВЫВОД
			     ;	      CY=0 - успешно,
			     ;	      CY=1 - сбой (состояние НГМД установить
			     ;		     согласно  AX).
			     ;----------------------------
EE67			     seek    proc    near
EE67  B0 01			     mov     al,1	     ; уст маску
EE69  51			     push    cx
EE6A  8A CA			     mov     cl,dl	     ; установить номер		       +
			     устройства
EE6C  D2 C0			     rol     al,cl	     ; циклический сдвиг влево
EE6E  59			     pop     cx
EE6F  84 06 003Er		     test    al,seek_status
EE73  75 20			     jnz     j28
EE75  08 06 003Er		     or	     seek_status,al
EE79  B4 07			     mov     ah,07h
EE7B  E8 F8B1			     call    nec_output
EE7E  8A E2			     mov     ah,dl
EE80  E8 F8AC			     call    nec_output
EE83  E8 0089			     call    chk_stat_2	  ; получить и	обработать	       +
			     прерывание
EE86  B4 07			     mov     ah,07h	     ; команда рекалибровки
EE88  E8 F8A4			     call    nec_output
EE8B  8A E2			     mov     ah,dl
EE8D  E8 F89F			     call    nec_output
EE90  E8 007C			     call    chk_stat_2
EE93  72 33			     jc	     j32	     ; сбой	позиционирования


EE95			     j28:
EE95  B4 0F			     mov     ah,0fh
EE97  E8 F895			     call    nec_output
EE9A  8A E2			     mov     ah,dl	     ; номер устройства
EE9C  E8 F890			     call    nec_output
EE9F  8A E5			     mov     ah,ch	     ; номер дорожки
EEA1  90				     nop
EEA2  F6 06 0010r 04		     test    byte ptr equip_flag,4
EEA7  75 02			     jnz     j300
EEA9  02 E4			     add     ah,ah	     ; удвоение	номера дорожки
EEAB			     j300:
EEAB  E8 F881			     call    nec_output
EEAE  E8 005E			     call    chk_stat_2	     ; получить	конечное	       +
			     прерывание и
							     ; считать состояние


EEB1  9C			     pushf		     ; сохранить значение	       +
			     флажков
EEB2  BB 0012			     mov     bx,18
EEB5  E8 FF99			     call    get_parm
EEB8  51			     push    cx		     ; сохранить регистр
EEB9			     j29:
EEB9  B9 0226			     mov     cx,550	     ; организовать	цикл = 1 ms
EEBC  0A E4			     or	     ah,ah	     ; проверка	окончания	       +
			     времени
EEBE  74 06			     jz	     j31
EEC0  E2 FE		     j30:    loop    j30	     ; задержка	1ms
EEC2  FE CC			     dec     ah		     ; вычитание из счетчика
EEC4  EB F3			     jmp     short j29	     ; возврат к началу цикла
EEC6			     j31:
EEC6  59			     pop     cx		     ; восстановить	состояние
EEC7  9D			     popf
EEC8			     j32:			     ; ошибка позиционирования
EEC8  C3			     ret	     ; возврат к программе, вызвавшей+
			     прерывание
EEC9			     seek    endp
			     ;-----------------------
			     ; dma_setup
			     ;	 Программа установки ПДП для операций	       +
			     записи,считывания,верифи-
			     ; кации.
			     ;
			     ;	 ВВОД
			     ;
			     ;	     (AL) - байт режима для ПДП,
			     ;	     (ES:BX) - адрес считывания/записи		       +
			     информации.
			     ;
			     ;------------------------
EEC9			     dma_setup proc  near
EEC9  51			     push    cx		     ; сохранить регистр
EECA  E6 0C			     out     dma+12,al
EECC  E6 0B			     out     dma+11,al	     ; вывод байта состояния
EECE  8C C0			     mov     ax,es	     ; получить	значение ES
EED0  B1 04			     mov     cl,4	     ; счетчик для сдвига
EED2  D3 C0			     rol ax,cl		     ; циклический сдвиг влево
EED4  8A E8			     mov     ch,al	     ;
EED6  24 F0			     and     al,0f0h	     ;
EED8  03 C3			     add     ax,bx
EEDA  73 02			     jnc     j33
EEDC  FE C5			     inc     ch		     ; перенос означает,	что	       +
			     старшие 4 бита
							     ; должны быть прибавлены
EEDE			     j33:
EEDE  50			     push    ax		     ; сохранить начальный адрес
EEDF  E6 04			     out     dma+4,al	     ; вывод младшей половины      +
			     адреса
EEE1  8A C4			     mov     al,ah
EEE3  E6 04			     out     dma+4,al	     ; вывод старшей половины      +
			     адреса
EEE5  8A C5			     mov     al,ch	     ; получить	4 старших бита
EEE7  24 0F			     and     al,0fh
EEE9  E6 81			     out     081h,al   ; вывод 4 старших бит на регистр+
			     страниц

			     ;	 Определение	счетчика

EEEB  8A E6			     mov     ah,dh	     ; номер сектора
EEED  2A C0			     sub     al,al	     ;
EEEF  D1 E8			     shr     ax,1	     ;
EEF1  50			     push    ax
EEF2  BB 0006			     mov     bx,6	     ; получить	параметры	       +
			     байт/сектор
EEF5  E8 FF59			     call    get_parm
EEF8  8A CC			     mov     cl,ah	     ; счетчик сдига (0=128, 1=256 и т.д)
EEFA  58			     pop     ax
EEFB  D3 E0			     shl     ax,cl	     ; сдвиг
EEFD  48			     dec     ax		     ; -1
EEFE  50			     push    ax		     ; сохранить значение	       +
			     счетчика
EEFF  E6 05			     out     dma+5,al	     ; вывести младший байт	       +
			     счетчика
EF01  8A C4			     mov     al,ah
EF03  E6 05			     out     dma+5,al	     ; вывести старший байт	       +
			     счетчика
EF05  59			     pop     cx		     ; восстановить	значение       +
			     счетчика
EF06  58			     pop     ax		     ; восстановить	значение       +
			     адреса
EF07  03 C1			     add     ax,cx	     ; проверка	заполнения 64K
EF09  59			     pop     cx		     ; восстановить	регистр
EF0A  B0 02			     mov     al,2	     ; режим для 8237
EF0C  E6 0A			     out     dma+10,al	     ; инициализация канала НГМД
EF0E  C3			     ret	     ; возврат к программе, вызвавшей+
			     прерывание
EF0F			     dma_setup	     endp
			     ;-----------------------
			     ;chk_stat_2
			     ;	 Эта	программа обрабатывает прерывания ,     +
			     полученные после
			     ; рекалибровки, позиционирования или сброса  +
			     адаптера. Прерывание
			     ; ожидается, принимается, обрабатывается	и     +
			     результат	выдается программе,
			     ; вызвавшей прерывание.
			     ;
			     ;	 ВЫВОД
			     ;	       CY=0 - успешно,
			     ;	       CY=1 - сбой (ошибка в	состоянии НГМД),
			     ;--------------------------
EF0F			     chk_stat_2	proc near
EF0F  E8 001E			     call    wait_int	     ; ожидание	прерывания
EF12  72 14			     jc	     j34	     ; если	ошибка, то возврат
EF14  B4 08			     mov     ah,08h	     ; команда получения	       +
			     состояния
EF16  E8 F816			     call    nec_output
EF19  E8 004F			     call    results	     ; считать результаты
EF1C  72 0A			     jc	     j34
EF1E  A0 0042r			     mov     al,nec_status   ; получить	первый байт	       +
			     состояния
EF21  24 60			     and     al,060h	     ; выделить	биты
EF23  3C 60			     cmp     al,060h	     ; проверка
EF25  74 02			     jz	     j35	; если ошибка, то идти на метку
EF27  F8			     clc		     ; возврат
EF28			     j34:
EF28  C3			     ret	     ; возврат к программе, вызвавшей+
			     прерывание
EF29			     j35:
EF29  80 0E 0041r 40		     or	     diskette_status,bad_seek
EF2E  F9			     stc		     ; ошибка в возвращенном	коде
EF2F  C3			     ret
EF30			     chk_stat_2	     endp
			     ;---------------------------------
			     ; wait_int
			     ;	 Эта	программа ожидает прерывание,	которое +
			     возникает	во время
			     ; программы вывода.	Если устройство не	       +
			     готово, ошибка	может быть
			     ; возвращена.
			     ;
			     ;
			     ;	 ВЫВОД
			     ;		   CY=0	- успешно,
			     ;		   CY=1	- сбой(состояние НГМД			       +
			     устанавливается),
			     ;-----------------------------------
EF30			     wait_int proc   near
EF30  FB			     sti		     ; установить признак	       +
			     разрешения прерывания
EF31  53			     push    bx
EF32  51			     push    cx		     ; сохранить регистр
EF33  B3 02			     mov     bl,2	     ; количество циклов
EF35  33 C9			     xor     cx,cx	     ; длителность одного цикла  +
			     ожидания
EF37			     j36:
EF37  F6 06 003Er 80		     test    seek_status,int_flag  ; опрос	наличия		       +
			     прерывания
EF3C  75 0C			     jnz     j37
EF3E  E2 F7			     loop    j36	     ; возврат к началу цикла
EF40  FE CB			     dec     bl
EF42  75 F3			     jnz     j36
EF44  80 0E 0041r 80		     or	     diskette_status,time_out
EF49  F9			     stc		     ; возврат при ошибке
EF4A			     j37:
EF4A  9C			     pushf		     ; сохранить текущие	       +
			     признаки
EF4B  80 26 003Er 7F		     and     seek_status,not int_flag
EF50  9D			     popf		     ; восстановить	признаки
EF51  59			     pop     cx
EF52  5B			     pop     bx		     ; восстановить	регистр
EF53  C3			     ret	     ; возврат к программе, вызвавшей+
			     прерывание
EF54			     wait_int	     endp

EF54  03*(00)				     db	3 dup(0)

			     ;---------------------------
			     ;disk_int
			     ;	 Эта	программа обрабатывает прерывания       +
			     НГМД
			     ;
			     ;	 ВЫВОД  - признак прерывания			       +
			     устанавливается в SEEK_STATUS.
			     ;---------------------------
EF57			     disk_int proc   far
EF57  FB			     sti		     ; установить признак	       +
			     разрешения прерывания
EF58  1E			     push    ds
EF59  50			     push    ax
EF5A  B8 0040			     mov     ax,dat
EF5D  8E D8			     mov     ds,ax
EF5F  80 0E 003Er 80		     or	     seek_status,int_flag
EF64  B0 20			     mov     al,20h	     ; установить конец		       +
			     прерывания
EF66  E6 20			     out     20h,al	     ; послать конец прерывания  +
			     в	порт
EF68  58			     pop     ax
EF69  1F			     pop     ds
EF6A  CF			     iret		     ; возврат из прерывания
EF6B			     disk_int	     endp
			     ;----------------------------
			     ;
			     ;	 Эта	программа считывет все, что контроллер+
			     адаптера НГМД указывает
			     ; программе, следующей за прерыванием.
			     ;
			     ;
			     ;	 ВЫВОД
			     ;		CF=0 - успешно,
			     ;		CF=1 - сбой
			     ;----------------------------
EF6B			     results proc    near
EF6B  FC			     cld
EF6C  BF 0042r			     mov     di,offset nec_status
EF6F  51			     push    cx		     ; сохранить счетчик
EF70  52			     push    dx
EF71  53			     push    bx
EF72  B3 07			     mov     bl,7	     ; установить длину области  +
			     состояния


EF74			     j38:
EF74  33 C9			     xor     cx,cx	     ; длительность	одного цикла
EF76  BA 03F4			     mov     dx,03f4h	     ; адрес порта
EF79			     j39:
EF79  EC			     in	     al,dx	     ; получить	состояние
EF7A  A8 80			     test    al,080h	     ; готово ?
EF7C  75 0C			     jnz     j40a
EF7E  E2 F9			     loop    j39
EF80  80 0E 0041r 80		     or	     diskette_status,time_out
EF85			     j40:			     ; ошибка
EF85  F9			     stc		     ; возврат по ошибке
EF86  5B			     pop     bx
EF87  5A			     pop     dx
EF88  59			     pop     cx
EF89  C3			     ret

			     ;	 Проверка признака направления

EF8A  EC		     j40a:   in	     al,dx	     ; получить	регистр		       +
			     состояния
EF8B  A8 40			     test    al,040h	     ; сбой	позиционирования
EF8D  75 07			     jnz     j42     ; если	все нормально, считать      +
			     состояние
EF8F			     j41:
EF8F  80 0E 0041r 20		     or	     diskette_status,bad_nec
EF94  EB EF			     jmp     short j40	     ; ошибка

			     ;	 Считывание состояния

EF96			     j42:
EF96  42			     inc     dx		     ; указать порт
EF97  EC			     in	     al,dx	     ; ввести данные
EF98  88 05			     mov    byte ptr [di],al  ;	сохранить байт
EF9A  47			     inc     di		     ; увеличить адрес
EF9B  B9 000A			     mov     cx,000ah	     ; счетчик
EF9E  E2 FE		     j43:    loop    j43
EFA0  4A			     dec     dx
EFA1  EC			     in	     al,dx	     ; получить	состояние
EFA2  A8 10			     test    al,010h
EFA4  74 06			     jz	     j44
EFA6  FE CB			     dec     bl		     ; -1 из количества циклов
EFA8  75 CA			     jnz     j38
EFAA  EB E3			     jmp     short j41	     ; сигнал неверен

EFAC			     j44:
EFAC  5B			     pop     bx		     ; восстановить	регистры
EFAD  5A			     pop     dx
EFAE  59			     pop     cx
EFAF  C3			     ret		     ; возврат из прерывания
EFB0			     results endp
			     ;-----------------------------
			     ; num_trans
			     ;	 Эта	программа вычисляет количество	       +
			     секторов, которое действительно
			     ; было	записано или	считано с НГМД
			     ;
			     ;	 ВВОД
			     ;	      (CH) - цилиндр,
			     ;	      (CL) - сектор.
			     ;
			     ;	 ВЫВОД
			     ;	      (AL) - количество действительно		       +
			     переданных секторов.
			     ;
			     ;------------------------------
EFB0			     num_trans proc  near
EFB0  A0 0045r			     mov     al,nec_status+3  ;	получить последний	       +
			     цилиндр
EFB3  3A C5			     cmp     al,ch	     ; сравнить	со стартовым
EFB5  A0 0047r			     mov     al,nec_status+5  ;	получить последний сектор
EFB8  74 0A			     jz	     j45
EFBA  BB 0008			     mov     bx,8
EFBD  E8 FE91			     call    get_parm	     ; получить	значение EOT
EFC0  8A C4			     mov     al,ah	     ; AH в AL
EFC2  FE C0			     inc     al		     ; EOT+1
EFC4  2A C1		     j45:    sub     al,cl	 ; вычисление	стартового	       +
			     номера из конечного
EFC6  C3			     ret
EFC7			     num_trans endp

			     ;-------------------------------
			     ; disk_base
			     ;	 Эта	программа устанавливает параметры,      +
			     требуемые	для операций
			     ; НГМД.
			     ;--------------------------------

EFC7			     disk_base label byte
EFC7  CF			     db	     11001111b	     ;
EFC8  02			     db	     2		     ;
EFC9  25			     db	     motor_wait	     ;
EFCA  02			     db	     2		     ;
EFCB  08			     db	     8		     ;
EFCC  2A			     db	     02ah	     ;
EFCD  FF			     db	     0ffh	     ;
EFCE  50			     db	     050h	     ;
EFCF  F6			     db	     0f6h	     ;
EFD0  19			     db	     25		     ;
EFD1  04			     db	     4		     ;
			     ;--- int 17-------------------
			     ;	 Программа связи с печатающим устройством
			     ;
			     ;	 Эта	программа выполняет три функции, код    +
			     которых задается
			     ; в регистре AH:
			     ;	 AH=0 -	печать знака, заданного в регистре	AL.    +
			     Если в
			     ; результате выполнения функции	знак не	       +
			     напечатается, то в регистре
			     ; AL устанавливается "1" (тайм-аут);
			     ;	 AH=1 -	инициализация порта печати. После	       +
			     выполнения функции
			     ; в регистре AH находится байт состояния	       +
			     печатающего устройства;
			     ;	 AH=2H - считывание байта состояния		       +
			     печатающего устройства.
			     ;	 В регистре DX	необходимо задать ноль.
			     ;	 Значение разрядов байта состояния	       +
			     печатающего устройства:
			     ;	 0 - тайм-аут;
			     ;	 3 - ошибка ввода-вывода;
			     ;	 4 - выбран (SLCT);
			     ;	 5 - конец	бумаги (PE);
			     ;	 6 - подтверждение;
			     ;	 7 - занято.
			     ;------------------------------

				     assume  cs:code,ds:data
EFD2			     printer_io	proc far
EFD2  FB			     sti		     ; установить признак	       +
			     разрешения прерывания
EFD3  1E			     push    ds		     ; сохранить сегмент
EFD4  52			     push    dx
EFD5  56			     push    si
EFD6  51			     push    cx
EFD7  53			     push    bx
EFD8  BE 0040			     mov     si,dat
EFDB  8E DE			     mov     ds,si	     ; установить сегмент
EFDD  8B F2			     mov     si,dx
EFDF  D1 E6			     shl     si,1
EFE1  8B 94 0008r		     mov     dx,printer_base[si]  ; получить базовый адрес
								  ; печатающего устройства
EFE5  0B D2			     or	     dx,dx		; печать подключена ?
EFE7  74 0C			     jz	     b1			; нет, возврат
EFE9  0A E4			     or	     ah,ah		; AH=0 ?
EFEB  74 0E			     jz	     b2			; да,	переход к печати	       +
			     знака
EFED  FE CC			     dec     ah			; AH=1 ?
EFEF  74 42			     jz	     b8			; да,	переход к		       +
			     инициализации
EFF1  FE CC			     dec     ah			; AH=2 ?
EFF3  74 2A			     jz	     b5		; да,	переход к считыванию	       +
			     байта	состояния

			     ;	  Выход из программы

EFF5			     b1:
EFF5  5B			     pop     bx		     ; восстановить	регистры
EFF6  59			     pop     cx
EFF7  5E			     pop     si
EFF8  5A			     pop     dx
EFF9  1F			     pop     ds
EFFA  CF			     iret

			     ;	 Печать знака, заданного в	AL

EFFB			     b2:
EFFB  50			     push    ax
EFFC  B3 0A			     mov     bl,10	     ; количество циклов	       +
			     ожидания
EFFE  33 C9			     xor     cx,cx	     ; длительность	одного цикла
F000  EE			     out     dx,al	     ; вывести символ в порт
F001  42			     inc     dx		     ; -1 из адреса порта
F002			     b3:			     ; ожидание	BUSY
F002  EC			     in	     al,dx	     ; получить	состояние
F003  8A E0			     mov     ah,al	     ; переслать состояние в	AH
F005  A8 80			     test    al,80h	     ; печать занята ?
F007  75 0E			     jnz     b4		     ; переход, если	да
F009  E2 F7			     loop    b3		     ; цикл	ожидания закончился ?
F00B  FE CB			     dec     bl		     ; да, -1	из количества циклов
F00D  75 F3			     jnz     b3		     ; время ожидания истекло ?
F00F  80 CC 01			     or	     ah,1	     ; да, уст бит "тайм-аут"
F012  80 E4 F9			     and     ah,0f9h	     ;
F015  EB 14			     jmp     short b7
F017			     b4:			     ; OUT_STROBE
F017  B0 0D			     mov     al,0dh	     ; установить высокий строб
F019  42			     inc     dx	     ; стробирование битом 0 порта C    +
			     для 8255
F01A  EE			     out     dx,al
F01B  B0 0C			     mov     al,0ch	     ; установить низкий строб
F01D  EE			     out     dx,al
F01E  58			     pop     ax		     ;

			     ;	 Считывание байта состояния печатающего     +
			     устройства

F01F			     b5:
F01F  50			     push    ax		     ; сохранить регистр
F020			     b6:
F020  8B 94 0008r		     mov     dx,printer_base[si]  ; получить адрес	печати
F024  42			     inc     dx
F025  EC			     in	     al,dx	     ; получить	состояние печати
F026  8A E0			     mov     ah,al
F028  80 E4 F8			     and     ah,0f8h
F02B			     b7:
F02B  5A			     pop     dx
F02C  8A C2			     mov     al,dl
F02E  80 F4 48			     xor     ah,48h
F031  EB C2			     jmp     short b1	     ; к выходу из программы

			     ;	 Инициализация порта печатающего		       +
			     устройства

F033			     b8:
F033  50			     push    ax
F034  83 C2 02			     add     dx,2	     ; указать порт
F037  B0 08			     mov     al,8
F039  EE			     out     dx,al
F03A  B8 03E8			     mov     ax,1000	      ;	время задержки
F03D			     b9:
F03D  48			     dec     ax		      ;	цикл задержки
F03E  75 FD			     jnz     b9
F040  B0 0C			     mov     al,0ch
F042  EE			     out     dx,al
F043  EB DB			     jmp     short b6	 ; переход к считыванию байта   +
			     состояния
F045			     printer_io	     endp
			     ;--- int 10------------------
			     ;
			     ;	 Программа обработки прерывания ЭЛИ
			     ;
			     ;	 Эта	программа обеспечивает выполнение       +
			     функций обслуживания
			     ; адаптера	ЭЛИ,	код которых задается в	       +
			     регистре AH:
			     ;
			     ;	  AH=0	 - установить	режим работы	адаптера       +
			     ЭЛИ. В	результате
			     ; выполнения функции в регистре AL могут	       +
			     устанавливаться следу-
			     ; ющие	режимы:
			     ;	  0 - 40х25, черно-белый, алфавитно-цифровой;
			     ;	  1 - 40х25, цветной, алфавитно-цифровой;
			     ;	  2 - 80х25, черно-белый, алфавитно-цифровой;
			     ;	  3 - 80х25, цветной, алфавитно-цифровой;
			     ;	  4 - 320х200,	цветной,	графический;
			     ;	  5 - 320х200,	черно-белый, графический;
			     ;	  6 - 640х200,	черно-белый, графический;
			     ;	  7 - 80х25, черно-белый, алфавитно-цифровой.
			     ;	  Режимы 0 - 6 используются для ЭМ адаптера     +
			     ЭЛИ, режим	7
			     ; используется	для монохромного	черно-белого+
			     80х25 адаптера.
			     ;
			     ;	  AH=1	 - установить	размер курсора. Функция    +
			     задает размер кур-
			     ; сора	и управление	им.
			     ;	 Разряды	0 - 4 регистра CL определяют конечную+
			     границу курсора,
			     ; разряды 0	- 4 регистра CH	- начальную границу    +
			     курсора.
			     ;	  Разряды 6 и 5	задают управление курсором:
			     ;	  00 - курсор мерцает с частотой,	задаваемой   +
			     аппаратурно;
			     ;	  01 - курсор отсутствует.
			     ;	  Аппаратурно всегда вызывается мерцание    +
			     курсора с частотой,
			     ; равной 1/16 частоты	кадровой развертки.
			     ;
			     ;	  AH=2	 - установить	текущую позицию курсора.  +
			     Для выполнения
			     ; функции необходимо задать	следующие	       +
			     координаты курсора:
			     ;	  BH - страница;
			     ;	  DX - строка и колонка.
			     ; При графическом режиме регистр BH=0.
			     ;
			     ;	  AH=3	 - считать текущее положение курсора.    +
			     Функция вос-
			     ; станавливает	текущее положение курсора.      +
			     Перед	выполнением
			     ; функции в регистре BH необходимо задать	       +
			     страницу.
			     ;	  После выполнения программы регистры	       +
			     содержат следующую
			     ; информацию:
			     ;	  DH - строка;
			     ;	  DL - колонка;
			     ;	  CX - размер курсора и управление им.
			     ;
			     ;	  AH=5	- установить активную	страницу буфера  +
			     адаптера.
			     ; Функция используется только в			       +
			     алфавитно-цифровом режиме.
			     ; Для ее выполнения	необходимо в	регистре AL    +
			     задать страницу:
			     ;	  0-7 -	для режимов 0	и 1;
			     ;	  0-3 -	для режимов 2	и 3.
			     ;	  Значения режимов те же, что и для функции   +
			     AH=0.
			     ;
			     ;	  AH=6	 - переместить блок символов вверх по    +
			     экрану.
			     ; Функция перемещает символы в пределах	       +
			     заданной области вверх
			     ; по экрану, заполняя нижние	строки пробелами+
			     с	заданным атрибу-
			     ; том.
			     ;	  Для выполнения функции необходимо задать +
			     следующие	пара-
			     ; метры;
			     ;	  AL - количество перемещаемых строк. Для	       +
			     очистки блока AL=0;
			     ;	  CX - координаты левого верхнего угла блока  +
			     (строка,колонка);
			     ;	  DX - координаты правого нижнего угла блока;
			     ;	  BH - атрибут символа пробела.
			     ;
			     ;	  AH=7	 - переместить блок символов вниз.	       +
			     Функция перемещает
			     ; символы в пределах заданной области вниз по+
			     экрану, заполняя
			     ; верхние строки пробелами с заданным	       +
			     атрибутом.
			     ;	  Для выполнения функции необходимо задать +
			     те же параметры,
			     ; что и для	функции AH=6H.
			     ;
			     ;	  AH=8	 - считать атрибут и код символа,	       +
			     находящегося в теку-
			     ; щей позиции курсора. Функция считывает	       +
			     атрибут и код символа
			     ; и помещает их	в регистр AX (AL - код символа, AH - +
			     атрибут
			     ; символа).
			     ;	  Для выполнения функции необходимо в	       +
			     регистре BH задать
			     ; страницу	(только для алфавитно-цифрового     +
			     режима).
			     ;
			     ;	  AH=9	 - записать атрибут и код символа в	       +
			     текущую позицию
			     ; курсора. Функция помещает код символа и	его +
			     атрибут в текущую
			     ; позицию курсора.
			     ;	  Для выполнения функции необходимо задать +
			     следующие	параметры:
			     ;	  BH - отображаемая	страница (только для	       +
			     алфавитно-цифрового
			     ; режима;
			     ;	  CX - количество записываемых символов;
			     ;	  AL - код символа;
			     ;	  BL - атрибут символа для				       +
			     алфавитно-цифрового режима	или
			     ; цвет	знака для графики. При записи точки       +
			     разряд 7 регистра BL=1.    =1
			     ;
			     ;	  AH=10	- записать символ	в текущую позицию       +
			     курсора. Атрибут
			     ; не изменяется.
			     ;	  Для выполнения функции необходимо задать +
			     следующие	параметры:
			     ;	  BH - отображаемая	страница (только для	       +
			     алфавитно-цифрового
			     ; режима);
			     ;	  CX - количество повторений символа;
			     ;	  AL - код записываемого символа.		       +
			     ся
			     ;									   -
			     ;	  AH=11	- установить цветовую	палитру.		       +
			     ь
			     ;	  При выполнении функции используются два   +
			     варианта.
			     ;	  Для первого	варианта в регистре BH		       +
			     задается ноль,а в регистре
			     ; BL - значения пяти младших разрядов,		       +
			     используемых для выбора
			     ; цветовой	палитры (цвет заднего	плана для      +
			     цветного графического
			     ; режима 320х200 или цвет каймы	для цветного	       +
			     графического режима
			     ; 40х25).
			     ;	  Для второго	варианта в регистре BH		       +
			     задается "1", а в регистре
			     ; BL - номер цветовой	палитры (0 или 1).
			     ;	  Палитра 0 состоит из зеленого	(1), красного  +
			     (2) и желтого (3)
			     ; цветов, палитра 1 -	из голубого (1),		       +
			     фиолетового (2)	и белого	(3).
			     ; При работе с видеомонитором цвета палитры   +
			     заменяются соответству-
			     ; ющими градациями цвета.
			     ;	  Результатом выполнения функции является  +
			     установка	цветовой       )
			     ; палитры в регистре выбора цвета (3D9).
			     ;
			     ;	  AH=12	 - записать точку.	Функция определяет    +
			     относительный
			     ; адрес байта внутри буфера ЭЛИ, по которому   +
			     должна быть записана
			     ; точка с заданными	координатами.
			     ;	  Для выполнения функции необходимо задать +
			     следующие	параметры:    ,
			     ;	  DX - строка;
			     ;	  CX - колонка;
			     ;	  AL - цвет	выводимой точки. Если	разряд 7	       +
			     регистра AL уста-	 3)
			     ; новлен в "1", то выполняется	операция XOR над    +
			     значением	точки
			     ; из буфера и значением точки из регистра	AL.
			     ;
			     ;	  AH=13	- считать точку. Функция определяет       +
			     относительный
			     ; адрес байта внутри буфера ЭЛИ, по которому   +
			     должна быть считана
			     ; точка с заданными	координатами.
			     ;	  Перед выполнением программы в регистрах   +
			     задаются те же	парамет-
			     ; ры, что и для функции AH=12.
			     ;	 После выполнения программы в регистре	AL     +
			     находится	значение
			     ; считанной точки.
			     ;
			     ;	  AH=14	- записать телетайп. Функция выводит     +
			     символ в буфер
			     ; ЭЛИ с одновременной установкой позиции	       +
			     курсора и передвижением
			     ; курсора на экране.
			     ;	  После записи символа в последнюю позицию  +
			     строки выполняется
			     ; автоматический переход на	новую строку.       +
			     Если страница экрана
			     ; заполнена, выполняется перемещение на одну +
			     строку вверх. Осво-
			     ; бодившаяся строка заполняется	значением     +
			     атрибута символа для
			     ; алфавитно-цифрового режима или нулями -	для +
			     графики.
			     ;	  После записи очередного символа курсор     +
			     устанавливается
			     ; в следующую позицию.
			     ;	  Для выполнения программы необходимо	       +
			     задать следующие параметры:
			     ;	  AL - код выводимого символа;
			     ;	  BL - цвет	переднего плана (для графического +
			     режима).
			     ;	  Программа обрабатывает следующие	       +
			     служебные	символы:
			     ;	  0BH -	сдвиг курсора на одну	позицию (без	       +
			     очистки);
			     ;	  0DH -	перемещение курсора в начало строки;
			     ;	  0AH -	перемещение курсора на следующую	       +
			     строку;
			     ;	  07H -	звуковой сигнал.
			     ;
			     ;	  AH=15	- получить текущее состояние ЭЛИ.	       +
			     Функция считывает
			     ; текущее состояние ЭЛИ	из памяти и размещает+
			     его в следующих
			     ; регистрах;
			     ;	  AH - количество колонок (40 или 80);
			     ;	  AL - текущий режим (0-7).	Значения режимов	те   +
			     же, что и для
			     ; функции AH=0;
			     ;	  BH - номер активной страницы.
			     ;
			     ;	 AH=17 - загрузить знакогенератор		       +
			     пользователя. Функция дает
			     ; возможность пользователю загружать	       +
			     знакогенератор любым, необ-
			     ; ходимым ему алфавитом.
			     ;	  Для выполнения программы необходимо	       +
			     задать следующие параметры:
			     ;	  ES:BP	- адрес таблицы, сформированной	       +
			     пользователем;
			     ;	  CX	- количество передаваемых	символов;
			     ;	  BL	- код символа, начиная	с которого	       +
			     загружается таблица
			     ; пользователя;
			     ;	  BH - количество байт на знакоместо;
			     ;	  DL - идентификатор таблицы пользователя;
			     ;	  AL - режим:
			     ;		       AL=0   -	 загрузить знакогенератор
			     ;		       AL=1   -	 выдать идентификатор таблицы
			     ;		       AL=3   -	 загрузить вторую половину      +
			     знакогенератора:
			     ;				 BL=0 -	загрузить вторую		       +
			     половину знакогене
			     ;				 ратора из ПЗУ кодовой таблицы+
			     с	русским
			     ;				 алфавитом,
			     ;				 BL=1 -	загрузить вторую		       +
			     половину знакогене
			     ;				 ратора из ПЗУ стандартной       +
			     кодовой таблицей
			     ;				 ASCII (USA)
			     ;	 На выходе:
			     ;	     AH	  -  количество байт на	знакоместо
			     ;	     AL	  -  идентификатор	таблицы пользователя
			     ;	     CF=1   -	операция завершена успешно
			     ;
			     ;	  AH=19	- переслать цепочку символов. Функция   +
			     позволяет	пере-
			     ; сылать символы четырьмя способами,	тип	       +
			     которых задается в
			     ; регистре	AL:
			     ;	  AL=0 - символ, символ, символ, ...
			     ; В регистре BL задается атрибут, курсор не       +
			     движется;
			     ;	  AL=1 - символ, символ, символ, ...
			     ; В регистре BL задается атрибут, курсор	       +
			     движется;
			     ;	  AL=2H	- символ,	атрибут,	символ, атрибут, ...
			     ; Курсор не движется;
			     ;	  AL=3H	- символ,	атрибут,	символ, атрибут, ...
			     ; Курсор движется.
			     ;	   Кроме того необходимо задать в регистрах:
			     ;	  ES:BP	- начальный адрес	цепочки символов;
			     ;	  CX	- количество символов;
			     ;	  DH,DL	- строку и колонку для	начала записи;
			     ;	  BH	- номер страницы.
			     ;-----------------------------------------------------------

				     assume cs:code,ds:data,es:video_ram

F045			     m1	     label   word	     ; таблица функций адаптера  +
			     ЭЛИ
F045  F0FCr			     dw	     offset  set_mode
F047  F1CFr			     dw	     offset  set_ctype
F049  F1F0r			     dw	     offset  set_cpos
F04B  F21Ar			     dw	     offset  read_cursor
F04D  F7A9r			     dw	     offset  read_lpen
F04F  F230r			     dw	     offset  act_disp_page
F051  F29Cr			     dw	     offset  scroll_up
F053  F341r			     dw	     offset  scroll_down
F055  F37Dr			     dw	     offset  read_ac_current
F057  F3C3r			     dw	     offset  write_ac_current
F059  F3F6r			     dw	     offset  write_c_current
F05B  F254r			     dw	     offset  set_color
F05D  F438r			     dw	     offset  write_dot
F05F  F427r			     dw	     offset  read_dot
F061  F966r			     dw	     offset  write_tty2
F063  F27Ar			     dw	     offset  video_state
      =0020		     m1l     equ     20h

F065			     video_io proc   near
F065  FB			     sti		 ; установить	признак		       +
			     разрешения прерывания
F066  FC			     cld
F067  06			     push    es
F068  1E			     push    ds
F069  52			     push    dx
F06A  51			     push    cx
F06B  53			     push    bx
F06C  56			     push    si
F06D  57			     push    di
F06E  50			     push    ax		     ; сохранить значение AX
F06F  8A C4			     mov     al,ah	     ; переслать AH в	AL
F071  32 E4			     xor     ah,ah	     ; обнулить	старший байт
F073  D1 E0			     sal     ax,1	     ; умножить	на 2
F075  8B F0			     mov     si,ax	     ; поместить в SI
F077  3D 0020			     cmp     ax,m1l	     ; проверка	длины таблицы      +
			     функций
F07A  72 04			     jb	     m2		     ; адаптера	ЭЛИ
F07C  58			     pop     ax		     ; восстановить	AX
F07D  E9 0147			     jmp     video_return    ; выход, если AX неверно
F080  B8 0040		     m2:     mov     ax,dat
F083  8E D8			     mov     ds,ax
F085  B8 B800			     mov     ax,0b800h	     ; сегмент для цветного	       +
			     адаптера
F088  8B 3E 0010r		     mov     di,equip_flag   ; получить	тип адаптера
F08C  81 E7 0030		     and     di,30h	     ; выделить	биты режима ;	db 81h,+
			     0E7h,30h,00h  ; ###Gleb###
F090  83 FF 30			     cmp     di,30h	     ; есть	установка ч/б	       +
			     адаптера ?
F093  75 03			     jne     m3
F095  B8 B000			     mov     ax,0b000h	     ; уст адреса буфера	для ч/б   +
			     адаптера
F098  8E C0		     m3:     mov     es,ax
F09A  58			     pop     ax		     ; восстановить	значение
F09B  8A 26 0049r		     mov     ah,crt_mode     ; получить	текущий режим в AH
F09F  2E: FF A4	F045r		     jmp   cs:m1[si]
F0A4			     video_io	     endp
			     ;-------------------------
			     ; set mode

			     ;	 Эта	программа устанавливает режим работы  +
			     адаптера ЭЛИ
			     ;
			     ;	 ВХОД
			     ;		(AL) - содержит	значение режима.
			     ;
			     ;--------------------------

			     ;	 Таблицы	параметров ЭЛИ

F0A4			     video_parms label	     byte

			     ;	 Таблица	инициализации

F0A4  38 28 2D 0A 1F 06	19	     db	     38h,28h,2dh,0ah,1fh,6,19h	 ; уст для 40х25

F0AB  1C 02 07 06 07		     db	     1ch,2,7,6,7
F0B0  00 00 00 00		     db	     0,0,0,0
      =0010		     m4	     equ     10h

F0B4  71 50 5A 0A 1F 06	19	     db	     71h,50h,5ah,0ah,1fh,6,19h	 ; уст для 80х25

F0BB  1C 02 07 06 07		     db	     1ch,2,7,6,7
F0C0  00 00 00 00		     db	     0,0,0,0

F0C4  38 28 2D 0A 7F 06	64	     db	     38h,28h,2dh,0ah,7fh,6,64h	 ; уст для графики

F0CB  70 02 01 06 07		     db	     70h,2,1,6,7
F0D0  00 00 00 00		     db	     0,0,0,0

F0D4  62 50 50 0F 19 06	19	     db	     62h,50h,50h,0fh,19h,6,19h	 ; уст для 80х25	ч/б	       +
			     адаптера

F0DB  19 02 0D 0B 0C		     db	     19h,2,0dh,0bh,0ch
F0E0  00 00 00 00		     db	     0,0,0,0

F0E4			     m5	     label   word	     ; таблица для			       +
			     восстановления длины
F0E4  0800			     dw	     2048
F0E6  1000			     dw	     4096
F0E8  4000			     dw	     16384
F0EA  4000			     dw	     16384

			     ;	 Колонки
F0EC			     m6	     label   byte
F0EC  28 28 50 50 28 28	50+	     db	     40,40,80,80,40,40,80,80
      50


			     ;--- c_reg_tab
F0F4			     m7	     label   byte	     ; таблица установки режима
F0F4  2C 28 2D 29 2A 2E	1E+	     db	     2ch,28h,2dh,29h,2ah,2eh,1eh,29h
      29


F0FC			     set_mode proc   near
F0FC  BA 03D4			     mov     dx,03d4h	     ; адрес цветного адаптера
F0FF  B3 00			     mov     bl,0     ;	уст значение	для цветного	       +
			     адаптера
F101  83 FF 30			     cmp     di,30h	     ; установлен ч/б адаптер ?
F104  75 07			     jne     m8		     ; переход, если	указан	       +
			     цветной
F106  B0 07			     mov     al,7	     ; указать ч/б режим
F108  BA 03B4			     mov     dx,03b4h	     ; адрес для ч/б адаптера
F10B  FE C3			     inc     bl		     ; установить режим для ч/б    +
			     адаптера
F10D  8A E0		     m8:     mov     ah,al	     ; сохранить режим в	AH
F10F  A2 0049r			     mov     crt_mode,al
F112  89 16 0063r		     mov     addr_6845,dx    ; сохранить адрес		       +
			     управляющего порта
							     ; для активного дисплея
F116  1E			     push    ds
F117  50			     push    ax		     ; сохранить режим
F118  52			     push    dx		     ; сохранить значение порта  +
			     вывода
F119  83 C2 04			     add     dx,4	     ; указать адрес регистра      +
			     управления
F11C  8A C3			     mov     al,bl	     ; получить	режим для	       +
			     адаптера
F11E  EE			     out     dx,al	     ; сброс экрана
F11F  5A			     pop     dx		     ; восстановить	DX
F120  2B C0			     sub     ax,ax
F122  8E D8			     mov     ds,ax	     ; установить адрес таблицы  +
			     векторов
				     assume  ds:abs0
F124  C5 1E 0074r		     lds     bx,parm_ptr ; получить значение		       +
			     параметров адаптера ЭЛИ
F128  58			     pop     ax		     ; восстановить	AX
				     assume  ds:code
F129  B9 0010			     mov     cx,m4	; установить длину таблицы       +
			     параметров
F12C  80 FC 02			     cmp     ah,2	     ; определение режима
F12F  72 10			     jc	     m9		     ; режим 0 или 1 ?
F131  03 D9			     add     bx,cx	     ; уст начало таблицы	       +
			     параметров
F133  80 FC 04			     cmp     ah,4
F136  72 09			     jc	     m9		     ; режим 2 или 3
F138  03 D9			     add     bx,cx	     ; начало таблицы для графики
F13A  80 FC 07			     cmp     ah,7
F13D  72 02			     jc	     m9		     ; режимы 4, 5 или	6 ?
F13F  03 D9			     add     bx,cx	     ; уст начало таблицы для ч/б +
			     адаптера

			     ;	 BX указывает на строку таблицы			       +
			     инициализации

F141			     m9:			     ; OUT_INIT
F141  50			     push    ax		     ; сохранить режим в	AH
F142  32 E4			     xor     ah,ah	     ;

			     ;	 Цикл таблицы, устанавливающий адреса	       +
			     регистров	и выводящий значения
			     ; из таблицы

F144			     m10:
F144  8A C4			     mov     al,ah	     ;
F146  EE			     out     dx,al
F147  42			     inc     dx		     ; указать адрес порта
F148  FE C4			     inc     ah		     ;
F14A  8A 07			     mov     al,byte ptr [bx]	; получить значение	       +
			     таблицы
F14C  EE			     out     dx,al	     ; послать строку из	таблицы +
			     в	порт
F14D  43			     inc     bx		     ; +1 к адресу таблицы
F14E  4A			     dec     dx		     ; -1 из адреса порта
F14F  E2 F3			     loop    m10	     ; передана	вся таблица ?
F151  58			     pop     ax		     ; вернуть режимы
F152  1F			     pop     ds		     ; вернуть сегмент
				     assume  ds:data

			     ;	 Инициализация буфера дисплея

F153  33 FF			     xor     di,di	     ; DI=0
F155  89 3E 004Er		     mov     crt_start,di    ; сохранить начальный адрес
F159  C6 06 0062r 00		     mov     active_page,0   ; установить активную	       +
			     страницу
F15E  B9 2000			     mov     cx,8192	     ; количество слов в	цветном +
			     адаптере
F161  80 FC 04			     cmp     ah,4	     ; опрос графики
F164  72 0C			     jc	     m12	     ; нет инициализации графики
F166  80 FC 07			     cmp     ah,7	     ; опрос ч/б	адаптера
F169  74 04			     je	     m11	     ; инициализация ч/б	адаптера
F16B  33 C0			     xor     ax,ax	     ; для графического режима
F16D  EB 06			     jmp     short m13	     ; очистить	буфер
F16F			     m11:			     ; инициализация ч/б	адаптера
F16F  B9 0800			     mov     cx,2048	     ; об'ем буфера ч/б адаптера
F172			     m12:
F172  B8 0720			     mov     ax,' '+7*256    ; заполнить характеристики +
			     для альфа
F175			     m13:			     ; очистить	буфер
F175  F3> AB			     rep     stosw	     ; заполнить область буфера  +
			     пробелами

			     ;	 Формирование порта управления режимом

F177  C7 06 0060r 0067		     mov     cursor_mode,67h   ; установить режим	       +
			     текущего курсора (ERROR - MUS BE 607h)
F17D  A0 0049r			     mov     al,crt_mode     ; получить	режим в регистре +
			     AX
F180  32 E4			     xor     ah,ah
F182  8B F0			     mov     si,ax	     ; таблица указателей режима
F184  8B 16 0063r		     mov     dx,addr_6845    ; подготовить адрес порта    +
			     для вывода
F188  83 C2 04			     add     dx,4
F18B  2E: 8A 84	F0F4r		     mov al,cs:m7[si]
F190  EE			     out     dx,al
F191  A2 0065r			     mov     crt_mode_set,al

			     ;	 Форморование количества колонок

F194  2E: 8A 84	F0ECr		     mov al,cs:m6[si]
F199  32 E4			     xor     ah,ah
F19B  A3 004Ar			     mov     crt_cols,ax     ; коичество колонок на	       +
			     экране

			     ;	 Установить позицию курсора

F19E  81 E6 000E		     and     si,0eh	     ; db 81h,0E6h,0Eh,00h   ; ###Gleb###
F1A2  2E: 8B 8C	F0E4r		     mov cx,cs:m5[si]  ; длина для очистки
F1A7  89 0E 004Cr		     mov     crt_len,cx
F1AB  B9 0008			     mov     cx,8	     ; очистить	все позиции	       +
			     курсора
F1AE  BF 0050r			     mov     di,offset cursor_posn
F1B1  1E			     push    ds		     ; восстановить	сегмент
F1B2  07			     pop     es
F1B3  33 C0			     xor     ax,ax
F1B5  F3> AB			     rep     stosw	     ; заполнить нулями

			     ;	 Установка регистра сканирования

F1B7  42			     inc     dx		     ; уст порт сканирования	по   +
			     умолчанию
F1B8  B0 30			     mov     al,30h	     ; значение	30H для всех	       +
			     режимов,
							     ; исключая	640х200
F1BA  80 3E 0049r 06		     cmp     crt_mode,6	     ; режим ч/б	640х200
F1BF  75 02			     jnz     m14	     ; если	не 640х200
F1C1  B0 3F			     mov     al,3fh	     ; если	640х200, то поместить в 3FH
F1C3  EE		     m14:    out     dx,al	     ; вывод правильного	       +
			     значения в порт 3D9
F1C4  A2 0066r			     mov     crt_pallette,al   ; сохранить значение для    +
			     использования

			     ;	 Нормальный возврат

F1C7			     video_return:
F1C7  5F			     pop     di
F1C8  5E			     pop     si
F1C9  5B			     pop     bx
F1CA			     m15:
F1CA  59			     pop     cx		     ; восстановление регистров
F1CB  5A			     pop     dx
F1CC  1F			     pop     ds
F1CD  07			     pop     es
F1CE  CF			     iret		     ; возврат из прерывания
F1CF			     set_mode	     endp
			     ;--------------------
			     ; set_ctype
			     ;
			     ;	 Эта	программа устанавливает размер	       +
			     курсора и управление им
			     ;
			     ;	 ВХОД
			     ;		(CX) - содержит	размер курсора. (CH -	       +
			     начальная	граница,
			     ;		       CL - конечная граница)
			     ;
			     ;--------------------
F1CF			     set_ctype proc  near
F1CF  B4 0A			     mov     ah,10	     ; установить регистр 6845	для +
			     курсора
F1D1  89 0E 0060r		     mov     cursor_mode,cx   ;	сохранить в области	       +
			     данных
F1D5  E8 0002			     call    m16	     ; вывод регистра CX
F1D8  EB ED			     jmp     short video_return

F1DA			     m16:
F1DA  8B 16 0063r		     mov     dx,addr_6845    ; адрес регистра
F1DE  8A C4			     mov     al,ah	     ; получить	значение
F1E0  EE			     out     dx,al	     ; установить регистр
F1E1  42			     inc     dx		     ; регистр данных
F1E2  8A C5			     mov     al,ch	     ; данные
F1E4  EE			     out     dx,al
F1E5  4A			     dec     dx
F1E6  8A C4			     mov     al,ah
F1E8  FE C0			     inc     al		     ; указать другой регистр      +
			     данных
F1EA  EE			     out     dx,al	     ; установить второй регистр
F1EB  42			     inc     dx
F1EC  8A C1			     mov     al,cl	     ; второе значение данных
F1EE  EE			     out     dx,al
F1EF  C3			     ret		     ; возврат
F1F0			     set_ctype	     endp
			     ;----------------------------
			     ; set_cpos
			     ;
			     ;	 Установить текущую позицию курсора
			     ;
			     ;	 ВХОД
			     ;		DX - строка, колонка,
			     ;		BH - номер	страницы.
			     ;
			     ;-----------------------------
F1F0			     set_cpos proc   near
F1F0  8A CF			     mov     cl,bh
F1F2  32 ED			     xor     ch,ch	     ; установить счетчик
F1F4  D1 E1			     sal     cx,1	     ; сдвиг слова
F1F6  8B F1			     mov     si,cx
F1F8  89 94 0050r		     mov word ptr [si +	offset cursor_posn],dx	;сохранить	       +
			     указатель
F1FC  38 3E 0062r		     cmp     active_page,bh
F200  75 05			     jnz     m17
F202  8B C2			     mov     ax,dx	     ; получить	строку/колонку в +
			     AX
F204  E8 0002			     call    m18	     ; установить курсор
F207			     m17:
F207  EB BE			     jmp     short video_return	 ; возврат
F209			     set_cpos	     endp

			     ;	 Установить позицию курсора, AX	содержит       +
			     строку/колонку

F209			     m18     proc    near
F209  E8 007F			     call    position
F20C  8B C8			     mov     cx,ax
F20E  03 0E 004Er		     add     cx,crt_start    ; сложить с начальным	       +
			     адресом страницы
F212  D1 F9			     sar     cx,1	     ; делить на 2
F214  B4 0E			     mov     ah,14
F216  E8 FFC1			     call    m16
F219  C3			     ret
F21A			     m18     endp
			     ;---------------------------
			     ; read_cursor
			     ;
			     ;	 Считать	текущее положение курсора
			     ;
			     ;	 Эта	программа восстанавливает текущее       +
			     положение	курсора
			     ;
			     ;	 ВХОД
			     ;		BH - номер	страницы
			     ;
			     ;	 ВЫХОД
			     ;		DX - строка/колонка текущей	позиции	       +
			     курсора,
			     ;		CX - размер курсора и управление им
			     ;
			     ;---------------------------
F21A			     read_cursor proc near
F21A  8A DF			     mov     bl,bh
F21C  32 FF			     xor     bh,bh
F21E  D1 E3			     sal     bx,1
F220  8B 97 0050r		     mov dx,word ptr [bx+offset	cursor_posn]
F224  8B 0E 0060r		     mov     cx,cursor_mode
F228  5F			     pop     di		     ; восстановить	регистры
F229  5E			     pop     si
F22A  5B			     pop     bx
F22B  58			     pop     ax
F22C  58			     pop     ax
F22D  1F			     pop     ds
F22E  07			     pop     es
F22F  CF			     iret
F230			     read_cursor     endp
			     ;-----------------------------
			     ; act_disp_page
			     ;
			     ;	  Эта программа устанавливает активную	       +
			     страницу буфера адаптера ЭЛИ
			     ;
			     ;	 ВХОД
			     ;		AL - страница.
			     ;
			     ;	 ВЫХОД
			     ;		Выполняется сброс контроллера для	       +
			     установки	новой страницы.
			     ;
			     ;-----------------------------
F230			     act_disp_page proc	     near
F230  A2 0062r			     mov     active_page,al  ; сохранить значение	       +
			     активной страницы
F233  8B 0E 004Cr		     mov     cx,crt_len	     ; получить	длину области      +
			     буфера
F237  98			     cbw		     ; преобразовать AL
F238  50			     push    ax		     ; сохранить значение	       +
			     страницы
F239  F7 E1			     mul     cx
F23B  A3 004Er			     mov     crt_start,ax    ; сохранить начальный адрес
							     ; для следующего требования
F23E  8B C8			     mov     cx,ax	     ; переслать начальный адрес+
			     в	CX
F240  D1 F9			     sar     cx,1	     ; делить на 2
F242  B4 0C			     mov     ah,12
F244  E8 FF93			     call    m16
F247  5B			     pop     bx		     ; восстановить	значение       +
			     страницы
F248  D1 E3			     sal     bx,1
F24A  8B 87 0050r		     mov ax,word ptr [bx+offset	cursor_posn]   ; получить курсор
F24E  E8 FFB8			     call    m18	     ; установить позицию	       +
			     курсора
F251  E9 FF73			     jmp     video_return
F254			     act_disp_page   endp
			     ;------------------------------
			     ; set color
			     ;
			     ;	 Эта	программа устанавливает цветовую	       +
			     палитру.
			     ;
			     ;	 ВХОД
			     ;		BH=0
			     ;		     BL	- значение пяти младших бит,	       +
			     используемых для выбора
			     ;			  цветовой палитры (цвет заднего     +
			     плана	для цветной
			     ;			  графики 320х200 или цвет каймы для    +
			     цветного 40х25)
			     ;		BH=1
			     ;		     BL	- номер цветовой палитры
			     ;			  BL=0 - зеленый(1), красный(2), желтый(3),
			     ;			  BL=1 - голубой(1), фиолетовый(2), белый+
			     (3)
			     ;
			     ;	 ВЫХОД
			     ;		Установленная цветовая палитра в	       +
			     порту	3D9.
			     ;------------------------------
F254			     set_color proc  near
F254  8B 16 0063r		     mov     dx,addr_6845    ; порт	для палитры
F258  83 C2 05			     add     dx,5	     ; установить порт
F25B  A0 0066r			     mov     al,crt_pallette   ; получить текущее	       +
			     значение палитры
F25E  0A FF			     or	     bh,bh	     ; цвет	0 ?
F260  75 0E			     jnz     m20	     ; вывод цвета 1

			     ;	 Обработка цветовой палитры 0

F262  24 E0			     and     al,0e0h	     ; сбросить	5 младших бит
F264  80 E3 1F			     and     bl,01fh	     ; сбросить	3 старших бита
F267  0A C3			     or	     al,bl
F269			     m19:
F269  EE			     out     dx,al	      ;	вывод выбранного	цвета в  +
			     порт 3D9
F26A  A2 0066r			     mov     crt_pallette,al  ;	сохранить значение цвета
F26D  E9 FF57			     jmp     video_return

			     ;	 Обработка цветовой палитры 1

F270			     m20:
F270  24 DF			     and     al,0dfh	     ;
F272  D0 EB			     shr     bl,1	     ; проверить младший бит	BL
F274  73 F3			     jnc     m19
F276  0C 20			     or	     al,20h	     ;
F278  EB EF			     jmp     short m19	     ; переход
F27A			     set_color	     endp
			     ;--------------------------
			     ; video state
			     ;
			     ;	 Эта	программа получает текущее состояние  +
			     ЭЛИ в AX.
			     ;
			     ;		AH - количество колонок,
			     ;		AL - текущий режим,
			     ;		BH - номер	активной страницы.
			     ;
			     ;---------------------------
F27A			     video_state proc	     near
F27A  8A 26 004Ar		     mov     ah,byte ptr crt_cols   ; получить количество    +
			     колонок
F27E  A0 0049r			     mov     al,crt_mode	     ; текущий режим
F281  8A 3E 0062r		     mov     bh,active_page  ; получить	текущую активную+
			     страницу
F285  5F			     pop     di		     ; восстановить	регистры
F286  5E			     pop     si
F287  59			     pop     cx
F288  E9 FF3F			     jmp     m15	     ; возврат к программе
F28B			     video_state     endp
			     ;---------------------------
			     ; position
			     ;
			     ;	 Эта	программа вычисляет адрес буфера	       +
			     символа в режиме альфа.
			     ;
			     ;	 ВХОД
			     ;		AX - номер	строки, номер колонки,
			     ;
			     ;	 ВЫХОД
			     ;		AX - смещение символа с	координатами (AH,  +
			     AL) относительно
			     ;		     начала страницы. Смещение		       +
			     измеряется в байтах.
			     ;
			     ;----------------------------
F28B			     position proc   near
F28B  53			     push    bx		     ; сохранить регистр
F28C  8B D8			     mov     bx,ax
F28E  8A C4			     mov     al,ah	     ; строки в AL
F290  F6 26 004Ar		     mul     byte ptr crt_cols
F294  32 FF			     xor     bh,bh
F296  03 C3			     add     ax,bx	     ; добавить	к значению	       +
			     колонки
F298  D1 E0			     sal     ax,1	     ; * 2 для байтов атрибута
F29A  5B			     pop     bx
F29B  C3			     ret
F29C			     position	     endp
			     ;-------------------------------
			     ;scroll up
			     ;
			     ;	 Эта	программа перемещает	блок символов      +
			     вверх	по экрану.
			     ;
			     ;	 ВХОД
			     ;		AH - текуший режим,
			     ;		AL - количество перемещаемых строк
			     ;		CX - координаты левого верхнего	угла       +
			     блока
			     ;		     (строка, колонка),
			     ;		DX - координаты правого нижнего	угла
			     ;		BH - атрибут символа пробела (для	       +
			     опробеливания	освобожда-
			     ;		     емых строк),
			     ;
			     ;	 ВЫХОД
			     ;		Модифицированный буфер дисплея.
			     ;
			     ;-----------------------------------
				     assume cs:code,ds:data,es:data
F29C			     scroll_up proc  near
F29C  8A D8			     mov     bl,al	 ; сохранить количество	       +
			     перемещаемых строк
F29E  80 FC 04			     cmp     ah,4	     ; проверка	графического       +
			     режима
F2A1  72 08			     jc	     n1
F2A3  80 FC 07			     cmp     ah,7	     ; проверка	ч/б адаптера
F2A6  74 03			     je	     n1
F2A8  E9 01F3			     jmp     graphics_up
F2AB			     n1:
F2AB  53			     push    bx		     ; сохранить полный атрибут  +
			     в	BH
F2AC  8B C1			     mov     ax,cx	     ; координаты левого	       +
			     верхнего угла
F2AE  E8 0039			     call    scroll_position
F2B1  74 33			     jz	     n7
F2B3  03 F0			     add     si,ax
F2B5  8A E6			     mov     ah,dh	     ; строка
F2B7  2A E3			     sub     ah,bl
F2B9			     n2:
F2B9  E8 0075			     call    n10	     ; сдвинуть	одну строку
F2BC  03 F5			     add     si,bp
F2BE  03 FD			     add     di,bp	     ; указать на следующую	       +
			     строку в блоке
F2C0  FE CC			     dec     ah		     ; счетчик строк для	сдвига
F2C2  75 F5			     jnz     n2		     ; цикл	строки
F2C4			     n3:			     ; очистка входа
F2C4  58			     pop     ax		     ; восстановить	атрибут в AH
F2C5  B0 20			     mov     al,' '	     ; заполнить пробелами
F2C7			     n4:			     ; очистка счетчика
F2C7  E8 0070			     call    n11	     ; очистка строки
F2CA  03 FD			     add     di,bp	     ; указать следующую строку
F2CC  FE CB			     dec     bl		     ; счетчик строк для	сдвига
F2CE  75 F7			     jnz     n4		     ; очистка счетчика
F2D0			     n5:			     ; конец сдвига
F2D0  B8 0040			     mov     ax,dat
F2D3  8E D8			     mov     ds,ax
F2D5  80 3E 0049r 07		     cmp     crt_mode,7	     ; ч/б адаптер ?
F2DA  74 07			     je	     n6		     ; если	да - пропуск режима     +
			     сброса
F2DC  A0 0065r			     mov     al,crt_mode_set
F2DF  BA 03D8			     mov     dx,03d8h	     ; установить порт цветного  +
			     адаптера
F2E2  EE			     out     dx,al
F2E3			     n6:
F2E3  E9 FEE1			     jmp     video_return
F2E6			     n7:
F2E6  8A DE			     mov     bl,dh
F2E8  EB DA			     jmp     short n3	     ; очистить
F2EA			     scroll_up	     endp

			     ;	 Обработка сдвига

F2EA			     scroll_position proc    near
F2EA  80 3E 0049r 02		     cmp     crt_mode,2
F2EF  72 19			     jb	     n9		     ; обработать 80х25 отдельно
F2F1  80 3E 0049r 03		     cmp     crt_mode,3
F2F6  77 12			     ja	     n9

			     ;	 Сдиг для цветного адаптера в режиме 80х25

F2F8  52			     push    dx
F2F9  BA 03DA			     mov     dx,3dah	     ; обработка цветного	       +
			     адаптера
F2FC  50			     push    ax
F2FD			     n8:			     ; ожидание	доступности	       +
			     дисплея
F2FD  EC			     in	     al,dx
F2FE  A8 08			     test    al,8
F300  74 FB			     jz	     n8		     ; ожидание	доступности	       +
			     дисплея
F302  B0 25			     mov     al,25h
F304  BA 03D8			     mov     dx,03d8h
F307  EE			     out     dx,al	     ; выключить ЭЛИ
F308  58			     pop     ax
F309  5A			     pop     dx
F30A  E8 FF7E		     n9:     call    position
F30D  03 06 004Er		     add     ax,crt_start    ; смещение	активной	       +
			     страницы
F311  8B F8			     mov     di,ax	     ; для адреса сдвига
F313  8B F0			     mov     si,ax
F315  2B D1			     sub     dx,cx	     ; DX=строка
F317  FE C6			     inc     dh
F319  FE C2			     inc     dl		     ; прибавление к началу
F31B  32 ED			     xor     ch,ch	     ; установить старший байт    +
			     счетчика в 0
F31D  8B 2E 004Ar		     mov     bp,crt_cols     ; получить	число колонок      +
			     дисплея
F321  03 ED			     add     bp,bp	     ; увеличить на 2 байт	       +
			     атрибута
F323  8A C3			     mov     al,bl	     ; получить	счетчик строки
F325  F6 26 004Ar		     mul     byte ptr crt_cols	 ; определить	смещение из  +
			     адреса,
F329  03 C0			     add     ax,ax     ; умноженного	на 2,	для байта      +
			     атрибута
F32B  06			     push    es	     ; установить адресацию для	       +
			     области буфера
F32C  1F			     pop     ds
F32D  80 FB 00			     cmp     bl,0	     ; 0 означает очистку блока
F330  C3			     ret		     ; возврат с установкой	       +
			     флажков
F331			     scroll_position endp

			     ;	 Перемещение	строки

F331			     n10     proc    near
F331  8A CA			     mov     cl,dl	     ; получить	колонки для	       +
			     передачи
F333  56			     push    si
F334  57			     push    di		     ; сохранить начальный адрес
F335  F3> A5			     rep     movsw	     ; передать	эту строку на       +
			     экран
F337  5F			     pop     di
F338  5E			     pop     si		     ; восстановить	адресацию
F339  C3			     ret
F33A			     n10     endp

			     ;	 очистка	строки

F33A			     n11     proc    near
F33A  8A CA			     mov     cl,dl	     ; получить	колонки для	       +
			     очистки
F33C  57			     push    di
F33D  F3> AB			     rep     stosw	     ; запомнить полный знак
F33F  5F			     pop     di
F340  C3			     ret
F341			     n11     endp
			     ;------------------------
			     ; scroll_down
			     ;
			     ;	 Эта	программа перемещает	блок символов      +
			     вниз по
			     ; экрану, заполняя верхние строки пробелом с  +
			     заданным атрибутом
			     ;
			     ;	 ВХОД
			     ;		AH - текущий режим,
			     ;		AL - количество строк,
			     ;		CX - верхний левый угол	блока,
			     ;		DX - правый нижний угол	блока,
			     ;		BH - атрибут символа-заполнителя	       +
			     (пробела),
			     ;
			     ;-------------------------
F341			     scroll_down proc near
F341  FD			     std		     ; уст направление сдвига      +
			     вниз
F342  8A D8			     mov     bl,al	     ; количество строк в BL
F344  80 FC 04			     cmp     ah,4	     ; проверка	графики
F347  72 08			     jc	     n12
F349  80 FC 07			     cmp     ah,7	     ; проверка	ч/б адаптера
F34C  74 03			     je	     n12
F34E  E9 01A6			     jmp     graphics_down
F351			     n12:
F351  53			     push    bx		     ; сохранить атрибут в BH
F352  8B C2			     mov     ax,dx	     ; нижний правый угол
F354  E8 FF93			     call    scroll_position
F357  74 20			     jz	     n16
F359  2B F0			     sub     si,ax	     ; SI для адресации
F35B  8A E6			     mov     ah,dh
F35D  2A E3			     sub     ah,bl	     ; передать	количество строк
F35F			     n13:
F35F  E8 FFCF			     call    n10	     ; передать	одну строку
F362  2B F5			     sub     si,bp
F364  2B FD			     sub     di,bp
F366  FE CC			     dec     ah
F368  75 F5			     jnz     n13
F36A			     n14:
F36A  58			     pop     ax		     ; восстановить	атрибут в AH
F36B  B0 20			     mov     al,' '
F36D			     n15:
F36D  E8 FFCA			     call    n11	     ; очистка одной строки
F370  2B FD			     sub     di,bp	     ; перейти к следующей строке
F372  FE CB			     dec     bl
F374  75 F7			     jnz     n15
F376  E9 FF57			     jmp     n5		     ; конец сдвига
F379			     n16:
F379  8A DE			     mov     bl,dh
F37B  EB ED			     jmp     short n14
F37D			     scroll_down  endp
			     ;--------------------
			     ; read_ac_current
			     ;
			     ;	 Эта	программа считывает атрибут и	код	       +
			     символа, находящегося в теку-
			     ; щем положении курсора
			     ;
			     ;	 ВХОД
			     ;		AH - текущий режим,
			     ;		BH - номер	страницы (только для режима     +
			     альфа),
			     ;
			     ;	 ВЫХОД
			     ;		AL - код символа,
			     ;		AH - атрибут символа.
			     ;
			     ;---------------------
				     assume cs:code,ds:data,es:data
F37D			     read_ac_current proc near
F37D  80 FC 04			     cmp     ah,4	     ; это графика ?
F380  72 08			     jc	     p1
F382  80 FC 07			     cmp     ah,7	     ; ч/б адаптер ?
F385  74 03			     je	     p1
F387  E9 02A9			     jmp     graphics_read
F38A			     p1:			     ;
F38A  E8 001A			     call    find_position
F38D  8B F3			     mov     si,bx	     ; установить адресацию в SI


F38F  8B 16 0063r		     mov     dx,addr_6845    ; получить	базовый адрес
F393  83 C2 06			     add     dx,6	     ; порт	состояния
F396  06			     push    es
F397  1F			     pop     ds		     ; получить	сегмент
F398			     p2:
F398  EC			     in	     al,dx	     ; получить	состояние
F399  A8 01			     test    al,1
F39B  75 FB			     jnz     p2		     ; ожидание
F39D  FA			     cli		; сброс признака разрешения     +
			     прерывания
F39E			     p3:
F39E  EC			     in	     al,dx	     ; получить	состояние
F39F  A8 01			     test    al,1
F3A1  74 FB			     jz	     p3		     ; ожидание
F3A3  AD			     lodsw		     ; получить	символ/атрибут
F3A4  E9 FE20			     jmp     video_return
F3A7			     read_ac_current endp

F3A7			     find_position proc	near
F3A7  8A CF			     mov     cl,bh	     ; поместить страницу в CX
F3A9  32 ED			     xor     ch,ch
F3AB  8B F1			     mov     si,cx	     ; передать	в SI индекс,	       +
			     умноженный на 2
F3AD  D1 E6			     sal     si,1	     ; для слова смещения
F3AF  8B 84 0050r		     mov ax,word ptr [si+offset	cursor_posn]   ; получить	       +
			     строку/ко-
							     ; лонку этой страницы
F3B3  33 DB			     xor     bx,bx	     ; установить начальный	       +
			     адрес	в 0
F3B5  E3 06			     jcxz    p5
F3B7			     p4:
F3B7  03 1E 004Cr		     add     bx,crt_len	     ; длина буфера
F3BB  E2 FA			     loop    p4
F3BD			     p5:
F3BD  E8 FECB			     call    position
F3C0  03 D8			     add     bx,ax
F3C2  C3			     ret
F3C3			     find_position   endp
			     ;---------------------
			     ;write_ac_current
			     ;
			     ;	 Эта	программа записывает	атрибут и код       +
			     символа в текущую позицию
			     ; курсора
			     ;
			     ;	 ВХОД
			     ;		AH - текущий режим,
			     ;		BH - номер	страницы,
			     ;		CX - счетчик (количество повторений	       +
			     символов),
			     ;		AL - код символа,
			     ;		BL - атрибут символа (для режимов альфа)  +
			     или цвет символа
			     ;		     для графики.
			     ;
			     ;----------------------
F3C3			     write_ac_current proc near
F3C3  80 FC 04			     cmp     ah,4	     ; это графика ?
F3C6  72 08			     jc	     p6
F3C8  80 FC 07			     cmp     ah,7	     ; это ч/б адаптер ?
F3CB  74 03			     je	     p6
F3CD  E9 01B1			     jmp     graphics_write
F3D0			     p6:
F3D0  8A E3			     mov     ah,bl	     ; получить	атрибут в AH
F3D2  50			     push    ax		     ; хранить
F3D3  51			     push    cx		     ; хранить счетчик
F3D4  E8 FFD0			     call    find_position
F3D7  8B FB			     mov     di,bx	     ; адрес в DI
F3D9  59			     pop     cx		     ; вернуть счетчик
F3DA  5B			     pop     bx		     ; и символ
F3DB			     p7:			     ; цикл	записи


F3DB  8B 16 0063r		     mov     dx,addr_6845    ; получить	базовый адрес
F3DF  83 C2 06			     add     dx,6	     ; указать порт состояния
F3E2			     p8:
F3E2  EC			     in	     al,dx	     ; получить	состояние
F3E3  A8 01			     test    al,1
F3E5  75 FB			     jnz     p8		     ; ожидать
F3E7  FA			     cli		  ; сброс признака	разрешения   +
			     прерывания
F3E8			     p9:
F3E8  EC			     in	     al,dx	     ; получить	состояние
F3E9  A8 01			     test    al,1
F3EB  74 FB			     jz	     p9		     ; ожидать
F3ED  8B C3			     mov     ax,bx
F3EF  AB			     stosw		     ; записать	символ и	атрибут
F3F0  FB			     sti		     ; уст признак разрешения      +
			     прерывания
F3F1  E2 E8			     loop    p7
F3F3  E9 FDD1			     jmp     video_return
F3F6			     write_ac_current  endp
			     ;---------------------
			     ;write_c_current
			     ;
			     ;	 Эта	программа записывает	символ в	текущую +
			     позицию курсора.
			     ;
			     ;	 ВХОД
			     ;		BH - номер	страницы (только для альфа       +
			     режимов),
			     ;		CX - счетчик (количество повторений	       +
			     символа),
			     ;		AL - код символа,
			     ;
			     ;-----------------------
F3F6			     write_c_current proc near
F3F6  80 FC 04			     cmp     ah,4	     ; это графика ?
F3F9  72 08			     jc	     p10
F3FB  80 FC 07			     cmp     ah,7	     ; это ч/б адаптер ?
F3FE  74 03			     je	     p10
F400  E9 017E			     jmp     graphics_write
F403			     p10:
F403  50			     push    ax		     ; сохранить в стеке
F404  51			     push    cx		     ; сохранить количество	       +
			     повторений
F405  E8 FF9F			     call    find_position
F408  8B FB			     mov     di,bx	     ; адрес в DI
F40A  59			     pop     cx		     ; вернуть количество	       +
			     повторений
F40B  5B			     pop     bx		     ; BL - код символа
F40C			     p11:


F40C  8B 16 0063r		     mov     dx,addr_6845    ; получить	базовый адрес
F410  83 C2 06			     add     dx,6	     ; указать порт состояния
F413			     p12:
F413  EC			     in	     al,dx	     ; получить	состояние
F414  A8 01			     test    al,1
F416  75 FB			     jnz     p12	     ; ожидать
F418  FA			     cli		     ; сброс признака разрешения+
			     прерывания
F419			     p13:
F419  EC			     in	     al,dx	     ; получить	состояние
F41A  A8 01			     test    al,1
F41C  74 FB			     jz	     p13	     ; ожидание
F41E  8A C3			     mov     al,bl	     ; восстановить	символ
F420  AA			     stosb		     ; записать	символ
F421  47			     inc     di
F422  E2 E8			     loop    p11	     ; цикл
F424  E9 FDA0			     jmp     video_return
F427			     write_c_current endp
			     ;---------------------
			     ; read dot	- write	dot
			     ;
			     ;	 Эта	программа считывает/записывает точку.
			     ;
			     ;	 ВХОД
			     ;		DX - строка (0-199),
			     ;		CX - колонка (0-639),
			     ;		AL - цвет выводимой точки.
			     ;		     Если бит 7=1, то выполняется операция
			     ;		     XOR над	значением точки из буфера	       +
			     дисплея и значением
			     ;		     точки	из регистра AL (при записи	       +
			     точки).
			     ;
			     ;	 ВЫХОД
			     ;		AL - значение считанной точки
			     ;
			     ;----------------------
				     assume cs:code,ds:data,es:data
F427			     read_dot proc   near
F427  E8 0031			     call    r3		     ; определить положение	       +
			     точки
F42A  26: 8A 04			     mov     al,es:[si]	     ; получить	байт
F42D  22 C4			     and     al,ah	     ; размаскировать другие       +
			     биты в байте
F42F  D2 E0			     shl     al,cl	     ;
F431  8A CE			     mov     cl,dh	     ; получить	число бит	       +
			     результата
F433  D2 C0			     rol     al,cl
F435  E9 FD8F			     jmp     video_return    ; выход из прерывания
F438			     read_dot	     endp

F438			     write_dot proc  near
F438  50			     push    ax		     ; сохранить значение точки
F439  50			     push    ax		     ; еще раз
F43A  E8 001E			     call    r3		     ; определить положение	       +
			     точки
F43D  D2 E8			     shr     al,cl	     ; сдвиг для установки бит     +
			     при выводе
F43F  22 C4			     and     al,ah	     ; сбросить	другие биты
F441  26: 8A 0C			     mov     cl,es:[si]	     ; получить	текущий байт
F444  5B			     pop     bx
F445  F6 C3 80			     test    bl,80h
F448  75 0D			     jnz     r2
F44A  F6 D4			     not     ah	       ; установить маску для		       +
			     передачи указанных бит
F44C  22 CC			     and     cl,ah
F44E  0A C1			     or	     al,cl
F450			     r1:
F450  26: 88 04			     mov es:[si],al	     ; восстановить	байт в памяти
F453  58			     pop     ax
F454  E9 FD70			     jmp     video_return    ; к выходу из программы
F457			     r2:
F457  32 C1			     xor     al,cl	     ; исключающее ИЛИ над	       +
			     значениями точки
F459  EB F5			     jmp     short r1	     ; конец записи
F45B			     write_dot	     endp

			     ;-------------------------------------
			     ;
			     ;	 Эта	программа определяет	относительный     +
			     адрес	байта (внутри буфера
			     ; дисплея),	из которого должна быть		       +
			     считана/записана точка,с заданными
			     ; координатами.
			     ;
			     ;	 ВХОД
			     ;		DX - строка (0-199),
			     ;		CX - колонка (0-639).
			     ;
			     ;	 ВЫХОД
			     ;		SI - относительный	адрес байта,		       +
			     содержащего точку внутри
			     ;		     буфера дисплея,
			     ;		AH - маска	для выделения значения	       +
			     заданной точки внутри байта
			     ;		CL - константа	сдвига маски	в AH в крайнюю+
			     левую	позицию,
			     ;		DH - число	бит,	определяющих значение      +
			     точки.
			     ;
			     ;--------------------------------------

F45B			     r3	     proc    near
F45B  53			     push    bx		     ; сохранить BX
F45C  50			     push    ax		     ; сохранить AL

			     ;	 Вычисление первого байта	указанной строки+
			     умножением на 40.
			     ; Наименьший бит строки	определяет		       +
			     четно/нечетную 80-байтовую строку.

F45D  B0 28			     mov     al,40
F45F  52			     push    dx		     ; сохранить значение строки
F460  80 E2 FE			     and     dl,0feh	     ; сброс четно/нечетного	бита
F463  F6 E2			     mul     dl	  ; AX содержит	адрес первого байта   +
			     указанной	строки
F465  5A			     pop     dx		     ; восстановить	его
F466  F6 C2 01			     test    dl,1	     ; проверить			       +
			     четность/нечетность
F469  74 03			     jz	     r4		     ; переход,если строка четная
F46B  05 2000			     add     ax,2000h	     ; смещение	для нахождения    +
			     нечетных строк
F46E			     r4:			     ; четная строка
F46E  8B F0			     mov     si,ax	     ; передать	указатель в SI
F470  58			     pop     ax		     ; восстановить	значение AL
F471  8B D1			     mov     dx,cx	     ; значение	колонки в DX

			     ;	 Определение	действительных графических    +
			     режимов
			     ;
			     ;	 Установка регистров согласно	режимaм
			     ;
			     ;	       BH - количество бит, определяющее точку,
			     ;	       BL - константа выделения точки из левых   +
			     бит байта,
			     ;	       CH - константа для выделения из номера     +
			     колонки номера позиции
			     ;		    первого бита, определяющего	точку в  +
			     байте, т.е.	получение
			     ;		    остатка от	деления номера на 8 (для     +
			     режима 640х200) или
			     ;		    номера на 4	(для	режима 320х200),
			     ;	       CL - константа сдвига (для выполнения       +
			     деления на 8 или на 4).

F473  BB 02C0			     mov     bx,2c0h
F476  B9 0302			     mov     cx,302h	     ; установка параметров
F479  80 3E 0049r 06		     cmp     crt_mode,6
F47E  72 06			     jc	     r5		     ;
F480  BB 0180			     mov     bx,180h
F483  B9 0703			     mov     cx,703h	     ; уст параметры для		       +
			     старшего регистра

			     ;	 Определение	бита смещения в байте	по маске
F486			     r5:
F486  22 EA			     and     ch,dl	     ;

			     ;	 Определение	байта смещения в колонке

F488  D3 EA			     shr     dx,cl	     ; сдвиг для коррекции
F48A  03 F2			     add     si,dx	     ; получить	указатель
F48C  8A F7			     mov     dh,bh   ; получить	указатель битов	       +
			     результата в DH

			     ;	 Умножение BH (количество бит в байте) на	CH     +
			     (бит смещения)

F48E  2A C9			     sub     cl,cl
F490			     r6:
F490  D0 C8			     ror     al,1    ; левое крайнее значение в AL	для +
			     записи
F492  02 CD			     add     cl,ch	     ; прибавить значение бита    +
			     смещения
F494  FE CF			     dec     bh		     ; счетчик контроля
F496  75 F8			     jnz     r6	     ; на выходе CL содержит счетчик    +
			     сдвига для
							     ; восстановления
F498  8A E3			     mov     ah,bl	     ; получить	маску в AH
F49A  D2 EC			     shr     ah,cl	     ; передать	маску в ячейку
F49C  5B			     pop     bx		     ; восстановить	регистр
F49D  C3			     ret		     ; возврат с восстановлением
F49E			     r3	     endp

			     ;----------------------------------------
			     ;
			     ;
			     ;	  Программа перемещает блок символов вверх +
			     в	режиме графики
			     ;
			     ;-----------------------------------------

F49E			     graphics_up proc near
F49E  8A D8			     mov     bl,al	     ; сохранить количество	       +
			     символов
F4A0  8B C1			     mov     ax,cx	     ; получить	верхний левый      +
			     угол в AX


F4A2  E8 026A			     call    graph_posn
F4A5  8B F8			     mov     di,ax	     ; сохранить результат

			     ;	 Определить размеры блока

F4A7  2B D1			     sub     dx,cx
F4A9  81 C2 0101		     add     dx,101h
F4AD  D0 E6			     sal     dh,1
F4AF  D0 E6			     sal     dh,1

F4B1  80 3E 0049r 06		     cmp     crt_mode,6
F4B6  73 04			     jnc     r7

F4B8  D0 E2			     sal     dl,1
F4BA  D1 E7			     sal     di,1	     ;

			     ;	 Определение	адреса источника	в буфере
F4BC			     r7:
F4BC  06			     push    es
F4BD  1F			     pop     ds
F4BE  2A ED			     sub     ch,ch	     ; обнулить	старший байт	       +
			     счетчика
F4C0  D0 E3			     sal     bl,1	     ; умножение числа строк	на 4
F4C2  D0 E3			     sal     bl,1
F4C4  74 2D			     jz	     r11	     ; если	0, занести пробелы
F4C6  8A C3			     mov     al,bl	     ; получить	число строк в AL
F4C8  B4 50			     mov     ah,80	     ; 80 байт/строк
F4CA  F6 E4			     mul     ah		     ; определить смещение	       +
			     источника
F4CC  8B F7			     mov     si,di	     ; установить источник
F4CE  03 F0			     add     si,ax	     ; сложить источник с ним
F4D0  8A E6			     mov     ah,dh	     ; количество строк
F4D2  2A E3			     sub     ah,bl	     ; определить число		       +
			     перемещений

F4D4			     r8:
F4D4  E8 0080			     call    r17	     ; перемещение одной строки
F4D7  81 EE 1FB0		     sub     si,2000h-80     ; перемещение в следующую    +
			     строку
F4DB  81 EF 1FB0		     sub     di,2000h-80
F4DF  FE CC			     dec     ah		     ; количество строк для	       +
			     перемещения
F4E1  75 F1			     jnz     r8	     ; продолжать, пока все строки не +
			     переместятся

			     ;	 Заполнение освобожденных строк
F4E3			     r9:
F4E3  8A C7			     mov     al,bh
F4E5			     r10:
F4E5  E8 0088			     call    r18	     ; очистить	эту строку
F4E8  81 EF 1FB0		     sub     di,2000h-80     ; указать на следующую
F4EC  FE CB			     dec     bl		     ; количество строк для	       +
			     заполнения
F4EE  75 F5			     jnz     r10	     ; цикл	очистки
F4F0  E9 FCD4			     jmp     video_return    ; к выходу из программы

F4F3			     r11:
F4F3  8A DE			     mov     bl,dh	     ; установить количество       +
			     пробелов
F4F5  EB EC			     jmp     short r9	     ; очистить
F4F7			     graphics_up     endp

			     ;---------------------------------
			     ;
			     ;	 Программа перемещает блок символов вниз в +
			     режиме графики
			     ;
			     ;----------------------------------

F4F7			     graphics_down proc	     near
F4F7  FD			     std		     ; установить направление
F4F8  8A D8			     mov     bl,al	     ; сохранить количество	       +
			     строк
F4FA  8B C2			     mov     ax,dx	     ; получить	нижнюю правую      +
			     позицию в AX


F4FC  E8 0210			     call    graph_posn
F4FF  8B F8			     mov     di,ax	     ; сохранить результат

			     ;	 Определение	размера блока

F501  2B D1			     sub     dx,cx
F503  81 C2 0101		     add     dx,101h
F507  D0 E6			     sal     dh,1
F509  D0 E6			     sal     dh,1


F50B  80 3E 0049r 06		     cmp     crt_mode,6
F510  73 05			     jnc     r12

F512  D0 E2			     sal     dl,1
F514  D1 E7			     sal     di,1
F516  47			     inc     di

			     ;	 Определение	адреса источника	в буфере
F517			     r12:
F517  06			     push    es
F518  1F			     pop     ds
F519  2A ED			     sub     ch,ch	     ; обнулить	старший байт	       +
			     счетчика
F51B  81 C7 00F0		     add     di,240	     ; указать последнюю строку
F51F  D0 E3			     sal     bl,1	     ; умножить	количество строк+
			     на 4
F521  D0 E3			     sal     bl,1
F523  74 2E			     jz	     r16	     ; если	0, заполнить пробелом
F525  8A C3			     mov     al,bl	     ; получить	количество строк+
			     в	AL
F527  B4 50			     mov     ah,80	     ; 80 байт/строк
F529  F6 E4			     mul     ah		     ; определить смещение	       +
			     источника
F52B  8B F7			     mov     si,di	     ; установить источник
F52D  2B F0			     sub     si,ax	     ; вычесть смещение
F52F  8A E6			     mov     ah,dh	     ; количество строк
F531  2A E3			     sub     ah,bl	     ; определить число для	       +
			     перемещения

F533			     r13:
F533  E8 0021			     call    r17	     ; переместить одну строку
F536  81 EE 2050		     sub     si,2000h+80     ; установить следующую	       +
			     строку
F53A  81 EF 2050		     sub     di,2000h+80
F53E  FE CC			     dec     ah		     ; количество строк для	       +
			     перемещения
F540  75 F1			     jnz     r13	     ; продолжать, пока все не      +
			     переместятся

			     ;	 Заполнение освобожденных строк
F542			     r14:
F542  8A C7			     mov     al,bh	     ; атрибут заполнения
F544			     r15:
F544  E8 0029			     call    r18	     ; очистить	строку
F547  81 EF 2050		     sub     di,2000h+80     ; указать следующую строку
F54B  FE CB			     dec     bl		     ; число строк для заполнения
F54D  75 F5			     jnz     r15
F54F  FC			     cld		     ; сброс признака		       +
			     направления
F550  E9 FC74			     jmp     video_return    ; к выходу из программы

F553			     r16:
F553  8A DE			     mov     bl,dh
F555  EB EB			     jmp     short r14	     ; очистить
F557			     graphics_down endp

			     ;	 Программа перемещения одной строки

F557			     r17     proc    near
F557  8A CA			     mov     cl,dl	     ; число байт в строке
F559  56			     push    si
F55A  57			     push    di		     ; хранить указатели
F55B  F3> A4			     rep     movsb	     ; переместить четное поле
F55D  5F			     pop     di
F55E  5E			     pop     si
F55F  81 C6 2000		     add     si,2000h
F563  81 C7 2000		     add     di,2000h	     ; указать нечетное поле
F567  56			     push    si
F568  57			     push    di		     ; сохранить указатели
F569  8A CA			     mov     cl,dl	     ; возврат счвтчика
F56B  F3> A4			     rep     movsb	     ; передать	нечетное поле
F56D  5F			     pop     di
F56E  5E			     pop     si		     ; возврат указателей
F56F  C3			     ret		     ; возврат к программе
F570			     r17     endp

			     ;	 Заполнение пробелами строки

F570			     r18     proc    near
F570  8A CA			     mov     cl,dl	     ; число байт в поле
F572  57			     push    di		     ; хранить указатель
F573  F3> AA			     rep     stosb	     ; запомнить новое значение
F575  5F			     pop     di		     ; вернуть указатель
F576  81 C7 2000		     add     di,2000h	     ; указать нечетное поле
F57A  57			     push    di
F57B  8A CA			     mov     cl,dl
F57D  F3> AA			     rep     stosb	     ; заполнить нечетное поле
F57F  5F			     pop     di
F580  C3			     ret		     ; возврат к программе
F581			     r18     endp

			     ;--------------------------------------
			     ;
			     ;	graphics_write
			     ;
			     ;	 Эта	программа записывает	символ в	режиме   +
			     графики
			     ;
			     ;	 ВХОД
			     ;		AL - код символа,
			     ;		BL - атрибут цвета,	который используется+
			     в	качестве цвета
			     ;		     переднего	плана (цвет символа). Если +
			     бит 7 BL=1, то
			     ;		     выполняется операция XOR над	байтом в+
			     буфере и байтом
			     ;		     в	генераторе символов,
			     ;		CX - счетчик повторений символа
			     ;
			     ;----------------------------------------

				     assume cs:code,ds:data,es:data
F581			     graphics_write proc near
F581  B4 00			     mov     ah,0	     ; AH=0
F583  50			     push    ax		     ; сохранить значение кода    +
			     символа

			     ;	 Определение	позиции в области буфера	       +
			     засылкой туда кода	точек

F584  E8 0185			     call    s26	     ; найти ячейку в области       +
			     буфера
F587  8B F8			     mov     di,ax	     ; указатель области в DI

			     ;	 Определение	области для получения кода      +
			     точки

F589  58			     pop     ax		     ; восстановить	код точки
F58A  3C 80			     cmp     al,80h	     ; во второй половине ?
F58C  73 06			     jae     s1		     ; да

			     ;	 Изображение	есть в первой половине памяти

F58E  BE FA6Er			     mov     si, offset	crt_char_gen  ;	смещение изображения
F591  0E			     push    cs		     ; хранить сегмент в	стеке
F592  EB 0F			     jmp     short s2	     ; определить режим

			     ;	 Изображение	есть во второй части памяти

F594			     s1:
F594  2C 80			     sub     al,80h	     ; 0 во вторую половину
F596  1E			     push    ds		     ; хранить указатель данных
F597  2B F6			     sub     si,si
F599  8E DE			     mov     ds,si	     ; установить адресацию
				     assume  ds:abs0
F59B  C5 36 007Cr		     lds     si,ext_ptr	     ; получить	смещение
F59F  8C DA			     mov     dx,ds	     ; получить	сегмент
				     assume  ds:data
F5A1  1F			     pop     ds		     ; восстановить	сегмент	       +
			     данных
F5A2  52			     push    dx		     ; хранить сегмент в	стеке

			     ;	 Опеделение графического режима операции

F5A3			     s2:			     ; определение режима
F5A3  D1 E0			     sal     ax,1	     ; умножить	указатель кода    +
			     на 8
F5A5  D1 E0			     sal     ax,1
F5A7  D1 E0			     sal     ax,1
F5A9  03 F0			     add     si,ax	     ; SI содержит смещение
F5AB  80 3E 0049r 06		     cmp     crt_mode,6
F5B0  1F			     pop     ds		     ; восстановить	указатель     +
			     таблицы
F5B1  72 2C			     jc	     s7	     ; проверка	для средней		       +
			     разрешающей способности

			     ;	 Высокая	разрешающая способность
F5B3			     s3:
F5B3  57			     push    di		     ; сохранить указатель	       +
			     области
F5B4  56			     push    si		     ; сохранить указатель кода
F5B5  B6 04			     mov     dh,4	     ; количество циклов
F5B7			     s4:
F5B7  AC			     lodsb		     ; выборка четного байта
F5B8  F6 C3 80			     test    bl,80h
F5BB  75 16			     jnz     s6
F5BD  AA			     stosb
F5BE  AC			     lodsb
F5BF			     s5:
F5BF  26: 88 85	1FFF		     mov es:[di+1fffh],al    ; запомнить во второй части
F5C4  83 C7 4F			     add     di,79	     ; передать	следующую строку
F5C7  FE CE			     dec     dh		     ; выполнить цикл
F5C9  75 EC			     jnz     s4
F5CB  5E			     pop     si
F5CC  5F			     pop     di		     ; восстановить	указатель     +
			     области
F5CD  47			     inc     di	     ; указать на следующую позицию   +
			     символа
F5CE  E2 E3			     loop    s3		     ; записать	последующие	       +
			     символы
F5D0  E9 FBF4			     jmp     video_return

F5D3			     s6:
F5D3  26: 32 05			     xor al,es:[di]
F5D6  AA			     stosb		     ; запомнить код
F5D7  AC			     lodsb		     ; выборка нечетного символа
F5D8  26: 32 85	1FFF		     xor  al,es:[di+1fffh]
F5DD  EB E0			     jmp     s5		     ; повторить

			     ;	 Средняя	разрешающая способность записи
F5DF			     s7:
F5DF  8A D3			     mov     dl,bl	     ; сохранить старший бит	       +
			     цвета
F5E1  D1 E7			     sal     di,1    ; умножить	на 2,	т.к. два		       +
			     байта/символа
F5E3  E8 00D1			     call    s19	     ; расширение BL до полного     +
			     слова	цвета
F5E6			     s8:
F5E6  57			     push    di
F5E7  56			     push    si
F5E8  B6 04			     mov     dh,4	     ; число циклов
F5EA			     s9:
F5EA  AC			     lodsb		     ; получить	код точки
F5EB  E8 00DE			     call    s21	     ; продублировать
F5EE  23 C3			     and     ax,bx	     ; окрашивание в заданный      +
			     цвет
F5F0  F6 C2 80			     test    dl,80h
F5F3  74 07			     jz	     s10
F5F5  26: 32 25			     xor     ah,es:[di]	     ; выполнить функцию XOR со      +
			     "старым"
F5F8  26: 32 45	01		     xor     al,es:[di+1]    ; и "новым" цветами
F5FC  26: 88 25		     s10:    mov  es:[di],ah	     ; запомнить первый байт
F5FF  26: 88 45	01		     mov es:[di+1],al	     ; запомнить второй байт
F603  AC			     lodsb		     ; получить	код точки
F604  E8 00C5			     call    s21
F607  23 C3			     and     ax,bx	     ; окрашивание нечетного       +
			     байта
F609  F6 C2 80			     test    dl,80h
F60C  74 0A			     jz	 s11
F60E  26: 32 A5	2000		     xor     ah,es:[di+2000h]	; из первой половины
F613  26: 32 85	2001		     xor     al,es:[di+2001h]	; и из второй половины
F618  26: 88 A5	2000	     s11:    mov     es:[di+2000h],ah
F61D  26: 88 85	2001		     mov     es:[di+2001h],al	; запомнить вторую часть   +
			     буфера
F622  83 C7 50			     add     di,80	     ; указать следующую ячейку
F625  FE CE			     dec     dh
F627  75 C1			     jnz     s9		     ; повторить
F629  5E			     pop     si
F62A  5F			     pop     di
F62B  83 C7 02			     add     di,2	     ; переход к следующему	       +
			     символу
F62E  E2 B6			     loop    s8		     ; режим записи
F630  E9 FB94			     jmp     video_return
F633			     graphics_write  endp
			     ;-------------------------------------
			     ;graphics_read
			     ;
			     ;	 Программа считывает символ в режиме	       +
			     графики
			     ;
			     ;-------------------------------------
F633			     graphics_read   proc    near
F633  E8 00D6			     call    s26
F636  8B F0			     mov     si,ax	     ; сохранить в SI
F638  83 EC 08			     sub     sp,8	     ; зарезервировать в стеке 8  +
			     байт для
							     ; записи символа из	буфера   +
			     дисплея
F63B  8B EC			     mov     bp,sp	     ; указатель для хранения      +
			     области

			     ;	 Определение	режима графики

F63D  80 3E 0049r 06		     cmp     crt_mode,6
F642  06			     push    es
F643  1F			     pop     ds		     ; указать сегмент
F644  72 1A			     jc	     s13	     ; средняя разрешающая	       +
			     способность

			     ;	Высокая разрешающая способность для	       +
			     считавания

F646  B6 04			     mov     dh,4
F648			     s12:
F648  8A 04			     mov     al,byte ptr [si]	; получить первый	байт
F64A  88 46 00			     mov byte ptr [bp],al	; запомнить в	памяти
F64D  45			     inc     bp
F64E  8A 84 2000		     mov al,byte ptr [si+2000h]	  ; получить младший байт
F652  88 46 00			     mov byte ptr [bp],al
F655  45			     inc     bp
F656  83 C6 50			     add     si,80	     ; переход на следующую	       +
			     четную строку
F659  FE CE			     dec     dh
F65B  75 EB			     jnz     s12	     ; повторить
F65D  EB 17			     jmp     short s15	     ; переход к хранению кодов   +
			     точек
F65F  90			     nop

			     ;	 Средняя	разрешающая способность для	       +
			     считывания
F660			     s13:
F660  D1 E6			     sal     si,1      ; смещение умножить на	2, т.к. 2    +
			     байта/символа
F662  B6 04			     mov     dh,4
F664			     s14:
F664  E8 0088			     call    s23
F667  81 C6 2000		     add     si,2000h
F66B  E8 0081			     call    s23
F66E  81 EE 1FB0		     sub     si,2000h-80
F672  FE CE			     dec     dh
F674  75 EE			     jnz     s14	     ; повторить

			     ;	 Сохранить
F676			     s15:
F676  BF FA6Er			     mov     di,offset crt_char_gen   ;	смещение
F679  0E			     push    cs
F67A  07			     pop     es
F67B  83 ED 08			     sub     bp,8	     ; восстановить	начальный     +
			     адрес
F67E  8B F5			     mov     si,bp
F680  FC			     cld		     ; установить направление
F681  B0 00			     mov     al,0
F683			     s16:
F683  16			     push    ss
F684  1F			     pop     ds
F685  BA 0080			     mov     dx,128	     ; количество символов
F688			     s17:
F688  56			     push    si
F689  57			     push    di
F68A  B9 0008			     mov     cx,8	     ; количество байт в	символе
F68D  F3> A6			     repe    cmpsb	     ; сравнить
F68F  5F			     pop     di
F690  5E			     pop     si
F691  74 1E			     jz	     s18	     ; если	признак = 0,символы      +
			     сравнились
F693  FE C0			     inc     al		     ; не сравнились
F695  83 C7 08			     add     di,8	     ; следующий код точки
F698  4A			     dec     dx		     ; - 1 из	счетчика
F699  75 ED			     jnz     s17	     ; повторить


F69B  3C 00			     cmp     al,0
F69D  74 12			     je	     s18    ; переход, если все сканировано,  +
			     но символ
						    ; не найден
F69F  2B C0			     sub     ax,ax
F6A1  8E D8			     mov     ds,ax	     ; установить адресацию	       +
			     вектора
				     assume  ds:abs0
F6A3  C4 3E 007Cr		     les     di,ext_ptr
F6A7  8C C0			     mov     ax,es
F6A9  0B C7			     or	     ax,di
F6AB  74 04			     jz	     s18
F6AD  B0 80			     mov     al,128	     ; начало второй части
F6AF  EB D2			     jmp     short s16	     ; вернуться и повторить
				     assume  ds:data

F6B1			     s18:
F6B1  83 C4 08			     add     sp,8
F6B4  E9 FB10			     jmp     video_return
F6B7			     graphics_read   endp

			     ;---------------------------------
			     ;
			     ;	 Эта	программа заполняет регистр BX	двумя     +
			     младшими битами
			     ; регистра	BL.
			     ;
			     ;	 ВХОД
			     ;		BL - используемый цвет (младшие два бита).
			     ;
			     ;	 ВЫХОД
			     ;		BX - используемый цвет (восемь		       +
			     повторений двух битов цвета).
			     ;
			     ;---------------------------------
F6B7			     s19     proc    near
F6B7  80 E3 03			     and     bl,3	     ; выделить	биты цвета
F6BA  8A C3			     mov     al,bl	     ; переписать в AL
F6BC  51			     push    cx		     ; сохранить регистр
F6BD  B9 0003			     mov     cx,3	     ; количество повторений
F6C0			     s20:
F6C0  D0 E0			     sal     al,1
F6C2  D0 E0			     sal     al,1	     ; сдвиг влево на 2
F6C4  0A D8			     or	     bl,al	     ; в BL накапливается		       +
			     результат
F6C6  E2 F8			     loop    s20	     ; цикл
F6C8  8A FB			     mov     bh,bl	     ; заполнить
F6CA  59			     pop     cx
F6CB  C3			     ret		     ; все выполнено
F6CC			     s19     endp
			     ;--------------------------------------
			     ;
			     ;	 Эта	программа берет байт в AL и	удваивает     +
			     все биты, превращая
			     ; 8 бит	в 16 бит. Результат помещается в AX.
			     ;--------------------------------------
F6CC			     s21     proc    near
F6CC  52			     push    dx		     ; сохранить регистры
F6CD  51			     push    cx
F6CE  53			     push    bx
F6CF  BA 0000			     mov     dx,0	     ; результат удвоения
F6D2  B9 0001			     mov     cx,1	     ; маска
F6D5			     s22:
F6D5  8B D8			     mov     bx,ax
F6D7  23 D9			     and     bx,cx	     ; выделение бита
F6D9  0B D3			     or	     dx,bx	     ; накапливание	результата
F6DB  D1 E0			     shl     ax,1
F6DD  D1 E1			     shl     cx,1	     ; сдвинуть	базу и маску на 1
F6DF  8B D8			     mov     bx,ax
F6E1  23 D9			     and     bx,cx
F6E3  0B D3			     or	     dx,bx
F6E5  D1 E1			     shl     cx,1    ; сдиг	маски, для выделения	       +
			     следующего бита
F6E7  73 EC			     jnc     s22
F6E9  8B C2			     mov     ax,dx
F6EB  5B			     pop     bx		     ; восстановить	регистры
F6EC  59			     pop     cx
F6ED  5A			     pop     dx
F6EE  C3			     ret		     ; к выходу из прерывания
F6EF			     s21     endp

			     ;----------------------------------
			     ;
			     ;	 Эта	программа преобразовывает		       +
			     двух-битовое представление	точки
			     ; (C1,C0) в однобитовое
			     ; (C1,C0) к однобитовому.
			     ;
			     ;----------------------------------
F6EF			     s23     proc    near
F6EF  8A 24			     mov     ah,byte ptr [si]	; получить первый	байт
F6F1  8A 44 01			     mov     al,byte ptr [si+1]	  ; получить второй байт
F6F4  B9 C000			     mov     cx,0c000h	     ; 2 бита маски
F6F7  B2 00			     mov     dl,0	     ; регистр результата
F6F9			     s24:
F6F9  85 C1			     test    ax,cx	     ; проверка	2 младших бит	AX на+
			     0
F6FB  F8			     clc		     ; сбросить	признак переноса+
			     CF
F6FC  74 01			     jz	     s25	     ; переход если 0
F6FE  F9			     stc		     ; нет -	установить CF
F6FF  D0 D2		     s25:    rcl     dl,1	     ; циклический сдвиг
F701  D1 E9			     shr     cx,1
F703  D1 E9			     shr     cx,1
F705  73 F2			     jnc     s24	     ; повторить, если CF=1
F707  88 56 00			     mov byte ptr [bp],dl    ; запомнить результат
F70A  45			     inc     bp
F70B  C3			     ret		     ; к выходу из прерывания
F70C			     s23     endp

			     ;---------------------------------------
			     ;
			     ;	 Эта	программа определает	положение	       +
			     курсора относительно	мяти и
			     ; начала буфера в режиме графики			       +
			     /символ
			     ;
			     ;	 ВЫХОД
			     ;		AX  содержит смещение курсора
			     ;
			     ;-----------------------------------------
F70C			     s26     proc    near
F70C  A1 0050r			     mov     ax,cursor_posn  ; получить	текущее		       +
			     положение	курсора
F70F			     graph_posn	     label   near
F70F  53			     push    bx		     ; сохранить регистр
F710  8B D8			     mov     bx,ax	     ; сохранить текущее	       +
			     положение	курсора
F712  8A C4			     mov     al,ah	     ; строка
F714  F6 26 004Ar		     mul     byte ptr crt_cols	 ; умножить на байт/колонку
F718  D1 E0			     shl     ax,1	     ; умножить	на 4
F71A  D1 E0			     shl     ax,1
F71C  2A FF			     sub     bh,bh	     ; выделить	значение колонки
F71E  03 C3			     add     ax,bx	     ; определить смещение
F720  5B			     pop     bx
F721  C3			     ret		     ; к выходу из прерывания
F722			     s26     endp

			     ;----------------------------------------
			     ;
			     ;	 Записать телетайп (INT	10H, AH=14)
			     ;
			     ;	 Эта	программа выводит символ в буфер ЭЛИ с +
			     одновременной	уста-
			     ; новкой позиции курсора и передвижением	       +
			     курсора на экране.
			     ;	 После записи символа	в последнюю позицию   +
			     строки выполняется ав-
			     ; томатический	переход на новую строку. Если  +
			     страница экрана за-
			     ; полнена (позиция курсора 24,79/39),	выполняется +
			     перемещение экрана
			     ; на одну строку вверх. Освободившаяся строка+
			     заполняется значением
			     ; атрибута	символа (для алфавитно-цифрового   +
			     режима). Для графики цвет=00
			     ; После записи очередного символа курсор	       +
			     установлен в следующую	позицию.
			     ;
			     ;	 ВХОД
			     ;		AL - код выводимого символа,
			     ;		BL - цвет переднего плана для графики.
			     ;
			     ;----------------------------------------

				     assume  cs:code,ds:data
F722			     write_tty	     proc    near
F722  50			     push    ax		     ; сохранить регистры
F723  50			     push    ax
F724  B4 03			     mov     ah,3
F726  CD 10			     int     10h	     ; считать положение	       +
			     текущего курсора
F728  58			     pop     ax		     ; восстановить	символ

			     ;	 DX содержит текущую позицию курсора

F729  3C 08			     cmp     al,8	     ; есть	возврат на одну	       +
			     позицию ?
F72B  74 59			     je	     u8		     ; возврат на одну позицию
F72D  3C 0D			     cmp     al,0dh	     ; есть	возврат каретки ?
F72F  74 5E			     je	     u9		     ; возврат каретки
F731  3C 0A			     cmp     al,0ah	     ; есть	граница поля	?
F733  74 5E			     je	     u10	     ; граница поля
F735  3C 07			     cmp     al,07h	     ; звуковой	сигнал ?
F737  74 61			     je	     u11	     ; звуковой	сигнал

			     ;	 Запись символа на экран

F739  8A 3E 0062r		     mov     bh,active_page
F73D  B4 0A			     mov     ah,10	     ; запись символа без	       +
			     атрибута
F73F  B9 0001			     mov     cx,1
F742  CD 10			     int     10h

			     ;	 Положение курсора для следующего символа

F744  FE C2			     inc     dl
F746  3A 16 004Ar		     cmp     dl,byte ptr crt_cols
F74A  75 36			     jnz     u7		     ; переход к установке	       +
			     курсора
F74C  B2 00			     mov     dl,0
F74E  80 FE 18			     cmp     dh,24	     ; проверка	граничной строки
F751  75 2D			     jnz     u6		     ; установить курсор

			     ;	 Сдвиг экрана
F753			     u1:

F753  B4 02			     mov     ah,2
F755  B7 00			     mov     bh,0
F757  CD 10			     int     10h	     ; установить курсор


F759  A0 0049r			     mov     al,crt_mode     ; получить	текущий режим
F75C  3C 04			     cmp     al,4
F75E  72 06			     jc	     u2		     ; считывание курсора
F760  3C 07			     cmp     al,7
F762  B7 00			     mov     bh,0	     ; цвет	заднего плана
F764  75 06			     jne     u3

F766			     u2:			     ; считывание курсора
F766  B4 08			     mov     ah,8
F768  CD 10			     int     10h	; считать символ/атрибут	       +
			     текущего курсора
F76A  8A FC			     mov     bh,ah	     ; запомнить в BH

			     ;	 Перемещение	экрана на одну строку	вверх

F76C			     u3:
F76C  B8 0601			     mov     ax,601h
F76F  B9 0000			     mov     cx,0	     ; верхний левый угол
F772  B6 18			     mov     dh,24	     ; координаты нижнего	       +
			     правого
F774  8A 16 004Ar		     mov     dl,byte ptr crt_cols    ; угла
F778  FE CA			     dec     dl
F77A			     u4:
F77A  CD 10			     int     10h

			     ;	 Выход из прерывания

F77C			     u5:
F77C  58			     pop     ax		     ; восстановить	символ
F77D  E9 FA47			     jmp     video_return    ; возврат к программе

F780			     u6:			     ; установить курсор
F780  FE C6			     inc     dh		     ; следующая строка
F782			     u7:			     ; установить курсор
F782  B4 02			     mov     ah,2
F784  EB F4			     jmp     short u4	     ; установить новый курсор

			     ;	 Сдвиг курсора на	одну позицию	влево

F786			     u8:
F786  80 FA 00			     cmp     dl,0
F789  74 F7			     je	     u7		     ; установить курсор
F78B  FE CA			     dec     dl		     ; нет -	снова его передать
F78D  EB F3			     jmp     short u7

			     ;	 Перемещение	курсора в начало строки

F78F			     u9:
F78F  B2 00			     mov     dl,0
F791  EB EF			     jmp     short u7	     ; установить курсор

			     ;	 Перемещение	курсора на следующую строку

F793			     u10:
F793  80 FE 18			     cmp     dh,24	     ; последняя строка экрана
F796  75 E8			     jne     u6		     ; да - сдвиг экрана
F798  EB B9			     jmp     short u1	     ; нет -	снова установить	       +
			     курсор

			     ;	 Звуковой сигнал

F79A			     u11:
F79A  B3 02			     mov     bl,2	     ; уст длительность		       +
			     звукового	сигнала
F79C  E8 EE0A			     call    beep	     ; звук
F79F  EB DB			     jmp     short u5	     ; возврат
F7A1			     write_tty	     endp

			     ;
			     ;----------------------------------------
			     ;
			     ;	 Эта	программа считывает положение	       +
			     светового	пера.
			     ; Проверяется переключатель и триггер	       +
			     светового	пера. Если бит 1 ре-
			     ; гистра состояния (порт 3DA)=1, то триггер	       +
			     установлен. Если бит 2 порта
			     ; 3DA=0, то установлен	переключатель.
			     ;	 Порты 3BD	и 3DC используются	для установки и   +
			     сброса триггера и пере-
			     ; ключателя светового пера.
			     ;	 В регистрах R16 и R17 контроллера содержится  +
			     адрес	координат пера
			     ; относительно	начала буфера дисплея.
			     ;	 Если триггер и переключатель установлены, +
			     то программа определяет
			     ; положение светового пера, в противном	       +
			     случае, возврат без выдачи
			     ; информации.
			     ;
			     ;	 В ППЭВМ ЕС1841	функция не поддерживается
			     ;-------------------------------------------------




				     assume  cs:code,ds:data

			     ;	 Таблица	поправок для	получения		       +
			     фактических координат светового пера

F7A1			     v1	     label   byte
F7A1  03 03 05 05 03 03	03+	     db	     3,3,5,5,3,3,3,4
      04

F7A9			     read_lpen	     proc    near


F7A9  B4 00			     mov     ah,0	     ; код возврата,	если перо не +
			     включено
F7AB  8B 16 0063r		     mov     dx,addr_6845    ; получить	базовый адрес 6845
F7AF  83 C2 06			     add     dx,6	     ; указать регистр состояния
F7B2  EC			     in	     al,dx	     ; получить	регистр		       +
			     состояния
F7B3  A8 04			     test    al,4	     ; проверить переключатель   +
			     светового	пера
F7B5  75 78			     jnz     v6		     ; не установлено, возврат

			     ;	 Проверка триггера светового пера

F7B7  A8 02			     test    al,2	     ; проверить триггер	       +
			     светового	пера
F7B9  74 7E			     jz	     v7		     ; возврат без сброса	       +
			     триггера

			     ;	 Триггер	был установлен, считать значение в+
			     AH

F7BB  B4 10			     mov     ah,16	     ; уст регистры светового      +
			     пера 6845

			     ;	 Ввод регистров, указанных AH и			       +
			     преобразование в строки колонки в DX

F7BD  8B 16 0063r		     mov     dx,addr_6845
F7C1  8A C4			     mov     al,ah
F7C3  EE			     out     dx,al	     ; вывести в порт
F7C4  42			     inc     dx
F7C5  EC			     in	     al,dx	     ; получить	значение из порта
F7C6  8A E8			     mov     ch,al	     ; сохранить его в CX
F7C8  4A			     dec     dx		     ; регистр адреса
F7C9  FE C4			     inc     ah
F7CB  8A C4			     mov     al,ah	     ; второй регистр данных
F7CD  EE			     out     dx,al
F7CE  42			     inc     dx
F7CF  EC			     in	     al,dx	     ; получить	второе значение  +
			     данных
F7D0  8A E5			     mov     ah,ch	     ; AX содержит координаты	       +
			     светового	пера


F7D2  8A 1E 0049r		     mov     bl,crt_mode
F7D6  2A FF			     sub     bh,bh	     ; выделить	значение режима  +
			     в	BX
F7D8  2E: 8A 9F	F7A1r		     mov     bl,cs:v1[bx]    ; значение	поправки
F7DD  2B C3			     sub     ax,bx
F7DF  2B 06 004Er		     sub     ax,crt_start

F7E3  79 03			     jns     v2
F7E5  B8 0000			     mov     ax,0	     ; поместить 0

			     ;	 Определить режим

F7E8			     v2:
F7E8  B1 03			     mov     cl,3	     ; установить счетчик
F7EA  80 3E 0049r 04		     cmp     crt_mode,4	     ; определить, режим	графики +
			     или
							     ; альфа
F7EF  72 2A			     jb	     v4		     ; альфа-перо
F7F1  80 3E 0049r 07		     cmp     crt_mode,7
F7F6  74 23			     je	     v4		     ; альфа-перо

			     ;	 Графический	режим

F7F8  B2 28			     mov     dl,40	     ; делитель	для графики
F7FA  F6 F2			     div     dl	     ; определение строки (AL)	и	       +
			     колонки (AH)
							     ; пределы AL 0-99, AH 0-39

			     ;	 Определение	положения строки	для графики

F7FC  8A E8			     mov     ch,al	     ; сохранить значение строки+
			     в	CH
F7FE  02 ED			     add     ch,ch	     ; умножить	на 2			       +
			     четно/нечетное поле
F800  8A DC			     mov     bl,ah	     ; значение	колонки в BX
F802  2A FF			     sub     bh,bh	     ; умножить	на 8 для среднего +
			     результата
F804  80 3E 0049r 06		     cmp     crt_mode,6	     ; определить среднюю или      +
			     наивысшую
							     ; разрешающую способность
F809  75 04			     jne     v3		     ; не наивысшая разрешающая  +
			     способность
F80B  B1 04			     mov     cl,4     ;	сдвинуть значение наивысшей   +
			     разрешающей
						      ;	способности
F80D  D0 E4			     sal     ah,1    ; сдвиг на 1 разряд влево	       +
			     значения колонки
F80F			     v3:			     ; не наивысшая разрешающая  +
			     способность
F80F  D3 E3			     shl     bx,cl   ; умножить	на 16	для наивысшей      +
			     разрешающей
						     ; способности

			     ;	 Определение	положения символа для альфа

F811  8A D4			     mov     dl,ah	     ; значение	колонки для	       +
			     возврата
F813  8A F0			     mov     dh,al	     ; значение	строки
F815  D0 EE			     shr     dh,1	     ; делить на 4
F817  D0 EE			     shr     dh,1	     ; для значения в пределах 0-24
F819  EB 12			     jmp     short v5	     ; возврат светового пера

			     ;	 Режим альфа светового пера

F81B			     v4:			     ; альфа светового пера
F81B  F6 36 004Ar		     div     byte ptr crt_cols	; строка,	колонка
F81F  8A F0			     mov     dh,al	     ; строка в DH
F821  8A D4			     mov     dl,ah	     ; колонка в DL
F823  D2 E0			     sal     al,cl	     ; умножение строк на 8
F825  8A E8			     mov     ch,al
F827  8A DC			     mov     bl,ah
F829  32 FF			     xor     bh,bh
F82B  D3 E3			     sal     bx,cl
F82D			     v5:
F82D  B4 01			     mov     ah,1	     ; указать, что все		       +
			     установлено
F82F			     v6:
F82F  52			     push    dx		     ; сохранить значение	       +
			     возврата
F830  8B 16 0063r		     mov     dx,addr_6845    ; получить	базовый адрес
F834  83 C2 07			     add     dx,7
F837  EE			     out     dx,al	     ; вывод
F838  5A			     pop     dx		     ; восстановить	значение
F839			     v7:
F839  5F			     pop     di		      ;	восстановить регистры
F83A  5E			     pop     si
F83B  1F			     pop     ds
F83C  1F			     pop     ds
F83D  1F			     pop     ds
F83E  1F			     pop     ds
F83F  07			     pop     es
F840  CF			     iret
F841			     read_lpen	     endp

			     ;--- int 12 ------------------------------------
			     ;
			     ;	  Программа определения размера памяти.
			     ;
			     ;	  Эта программа передает в	регистр AX об'ем    +
			     памяти в Кбайтах.
			     ;
			     ;-----------------------------------------

				     assume  cs:code,ds:data
F841			     memory_size_determine   proc    far
F841  FB			     sti		     ; установить бит разрешения+
			     прерывания
F842  1E			     push    ds		     ; сохранить сегмент
F843  B8 0040			     mov     ax,dat	     ; установить адресацию
F846  8E D8			     mov     ds,ax
F848  A1 0013r			     mov     ax,memory_size  ; получить	значение размера+
			     памяти
F84B  1F			     pop     ds		     ; восстановить	сегмент
F84C  CF			     iret		     ; возврат из прерывания
F84D			     memory_size_determine   endp

			     ;--- int 11-------------------------------
			     ;
			     ;	  Программа определения состава		       +
			     оборудования.
			     ;
			     ;	 Эта	программа передает в регистр AX	       +
			     конфигурацию системы.
			     ;
			     ;	 Разряды	регистра AX имеют следующее	       +
			     значение:
			     ;	 0	 - загрузка системы с НГМД;
			     ;	 5,4	 - тип подключенного ЭЛИ и режим его       +
			     работы:
			     ;		   00 -	не используется;
			     ;		   01 -	40х25,	черно-белый режим цветного      +
			     графического
			     ;			ЭЛИ;
			     ;		   10 -	80х25,	черно-белый режим цветного      +
			     графического
			     ;			ЭЛИ;
			     ;		   11 -	80х25,	черно-белый режим		       +
			     монохромного ЭЛИ.
			     ;	 7,6	 - количество	НГМД;
			     ;	 11,10,9 - количество	адаптеров стыка С2;
			     ;	 12	 - адаптер игр;
			     ;	 15,14	 - количество	печатающих устройств.
			     ;	 Разряды	6 и 7 устанавливаются только в том   +
			     случае, если
			     ; разряд 0 установлен в "1".
			     ;
			     ;----------------------------------------------

				     assume  cs:code,ds:data
F84D			     equipment	     proc    far
F84D  FB			     sti		     ; установить признак	       +
			     разрешения прерывания
F84E  1E			     push    ds		     ; сохранить сегмент
F84F  B8 0040			     mov     ax,dat	     ; установить адресацию
F852  8E D8			     mov     ds,ax
F854  A1 0010r			     mov     ax,equip_flag   ; получить	конфигурацию       +
			     системы
F857  1F			     pop     ds		     ; восстановить	сегмент
F858  CF			     iret		     ; возврат из прерывания
F859			     equipment	     endp

			     ;****************************************
			     ;
			     ;	 Загрузка знакогенератора
			     ;
			     ;****************************************

F859			     bct     proc    near
F859  B8 DC00			     mov     ax,0dc00h
F85C  8E C0			     mov     es,ax
F85E  B9 1400			     mov     cx,1400h
F861  BA 03B8			     mov     dx,3b8h
F864  33 C0			     xor     ax,ax
F866  EE			     out     dx,al
F867  33 FF			     xor     di,di
F869  FC			     cld
F86A  F3> AB			     rep     stosw
F86C  BE FA6Er		     bct3:   mov     si,offset crt_char_gen
F86F  33 FF			     xor     di,di
F871  33 C0			     xor     ax,ax
F873  B1 80			     mov     cl,128
F875			     bct1:
F875  B3 08			     mov     bl,8
F877  2E: 8A 04		     bct2:   mov     al,cs:[si]
F87A  46			     inc     si
F87B  26: 89 05			     mov     word ptr es:[di],ax
F87E  47			     inc     di
F87F  47			     inc     di
F880  FE CB			     dec     bl
F882  75 F3			     jnz     bct2
F884  83 C7 10			     add     di,10h
F887  FE C9			     dec     cl
F889  75 EA				     jnz     bct1
F88B  B0 01				     mov     al, 1
F88D  EE				     out     dx, al
F88E  B8 B800				     mov     ax, 0B800h
F891  8E C0				     mov     es, ax
F893  B0 01				     mov     al, 1
F895  BA 03DF				     mov     dx, 3DFh
F898  EE				     out     dx, al
F899  B2 D8				     mov     dl, 0D8h
F89B  B0 00				     mov     al, 0
F89D  EE				     out     dx, al
F89E  33 FF				     xor     di, di
F8A0  B9 0400				     mov     cx, 1024
F8A3  BE FA6Er				     mov     si, offset	crt_char_gen
F8A6  33 FF				     xor     di, di
F8A8  2E				     db	     02eh	     ;cs:  segment prefix (not handled by Turbo+
			     Assembler)
F8A9  F3> A4				     rep movsb
F8AB  B0 09				     mov     al, 00001001b
F8AD  EE				     out     dx, al
F8AE  B0 00				     mov     al,0
F8B0  B2 DF				     mov     dl, 0DFh
F8B2  EE				     out     dx, al
F8B3  C3				     ret
F8B4			     bct     endp

			     org     0f8cbh
			     ;
			     ;	 Таблица	кодов русских маленьких букв	       +
			     (строчных)
			     ;
F8CB			     rust    label   byte
F8CB  1B 31 32 33 34 35	36+	     db	     1bh,'1234567890-='
      37 38 39 30 2D 3D


F8D8  08 09			     db	     08h,09h
F8DA  D9 E6 E3 DA D5 DD	D3+	     db	     0d9h,0e6h,0e3h,0dah,0d5h,0ddh,0d3h,0e8h
      E8

F8E2  E9 D7 D6 ED 0D FF	E4+	     db	     0e9h,0d7h,0d6h,0edh,0dh,-1,0e4h,0ebh
      EB

F8EA  D2 D0 DF E0 DE DB	D4+	     db	     0d2h,0d0h,0dfh,0e0h,0deh,0dbh,0d4h,';:'
      3B 3A

F8F3  D1 EE 5C EF E7 E1	DC+	     db	     0d1h,0eeh,5ch,0efh,0e7h,0e1h,0dch,0d8h
      D8

F8FB  E2 EC 2C 2E 2F E5	2A	     db	     0e2h,0ech,',./',0e5h,'*'

F902  FF 20 EA			     db	     -1,' ',0eah


F905			     k30     label   byte
F905  52 4F 50 51 4B 4C	4D	     db	     82,79,80,81,75,76,77

F90C  47 48 49			     db	     71,72,73
			     ;---
F90F  10 11 12 13 14 15	16+	     db	     16,17,18,19,20,21,22,23
      17

F917  18 19 1E 1F 20 21	22+	     db	     24,25,30,31,32,33,34,35
      23

F91F  24 25 26 2C 2D 2E	2F+	     db	     36,37,38,44,45,46,47,48
      30

F927  31 32			     db	     49,50

			     ;	     Временный	обработчик прерываний стыка С2

F929			     rs232_io:
F929  B8 61F0				     mov     ax, 61F0h
F92C  CF				     iret

F92D			     int15h:
F92D  F9				     stc
F92E  B4 86				     mov     ah, 86h
F930  CA 0002				     retf    2

			     ;---
F933  F6 06 0017r 03	     k89:    test    kb_flag,left_shift+right_shift
F938  74 11			     jz	     k80
F93A  3C F0			     cmp     al,0f0h
F93C  74 23			     je	     k89a
F93E  3C B0			     cmp     al,0b0h
F940  72 06			     jb	     k81
F942  3C CF			     cmp     al,0cfh
F944  77 02			     ja	     k81
F946  04 20			     add     al,20h
F948  E9 EE94		     k81:    jmp     k61
F94B  3C F1		     k80:    cmp     al,0f1h
F94D  74 0D			     je	     k89b
F94F  3C D0			     cmp     al,0d0h
F951  72 F5			     jb	     k81
F953  3C FE			     cmp     al,0feh
F955  77 F1			     ja	     k81
F957  2C 20			     sub     al,20h
F959  E9 EE83			     jmp     k61
F95C  2C 01		     k89b:   sub     al,01h
F95E  E9 EE7E			     jmp     k61
F961  04 01		     k89a:   add     al,01h
F963  E9 EE79			     jmp     k61

F966			     write_tty2:
F966  8A 3E 0062r			     mov     bh, ds:active_page
F96A  E9 FDB5				     jmp     write_tty

F96D			     f19a:
F96D  42				     inc     dx
F96E  B0 08				     mov     al, 8
F970  EE				     out     dx, al
F971  BA 03FE				     mov     dx, 3FEh
F974  EE				     out     dx, al
F975  B0 A4				     mov     al, 0A4h
F977  E6 21				     out     inta01, al
F979  8B C6				     mov     ax, si
F97B  B1 03				     mov     cl, 3
F97D  E9 EBDC				     jmp     f19b

F980			     f20a:
F980  B0 80				     mov     al, 80h
F982  E6 A0				     out     0A0h, al
F984  B0 BC				     mov     al, 0BCh
F986  E6 21				     out     21h, al
F988  E9 EBE9				     jmp     f20b
			     ;
F98B  50		     dummm_return:   push    ax
F98C  B0 20				     mov     al,20h
F98E  E6 20				     out     20h,al
F990  58				     pop     ax
F991  CF				     iret

F992  DC*(00)				     db	220 dup(0)

			     ;**************************************
			     ;
			     ;	 Знакогенератор графический 320х200 и 640х200
			     ;
			     ;***************************************



FA6E			     crt_char_gen  label  byte
FA6E  00 00 00 00 00 00	00+	     db	     000h,000h,000h,000h,000h,000h,000h,000h ;d_00
      00

FA76  7E 81 A5 81 BD 99	81+	     db	     07eh,081h,0a5h,081h,0bdh,099h,081h,07eh ;d_01
      7E

FA7E  7E FF DB FF C3 E7	FF+	     db	     07eh,0ffh,0dbh,0ffh,0c3h,0e7h,0ffh,07eh ;d_02
      7E

FA86  6C FE FE FE 7C 38	10+	     db	     06ch,0feh,0feh,0feh,07ch,038h,010h,000h ;d_03
      00

FA8E  10 38 7C FE 7C 38	10+	     db	     010h,038h,07ch,0feh,07ch,038h,010h,000h ;d_04
      00

FA96  38 7C 38 FE FE 7C	38+	     db	     038h,07ch,038h,0feh,0feh,07ch,038h,07ch ;d_05
      7C

FA9E  10 10 38 7C FE 7C	38+	     db	     010h,010h,038h,07ch,0feh,07ch,038h,07ch ;d_06
      7C

FAA6  00 00 18 3C 3C 18	00+	     db	     000h,000h,018h,03ch,03ch,018h,000h,000h ;d_07
      00

FAAE  FF FF E7 C3 C3 E7	FF+	     db	     0ffh,0ffh,0e7h,0c3h,0c3h,0e7h,0ffh,0ffh ;d_08
      FF

FAB6  00 3C 66 42 42 66	3C+	     db	     000h,03ch,066h,042h,042h,066h,03ch,000h ;d_09
      00

FABE  FF C3 99 BD BD 99	C3+	     db	     0ffh,0c3h,099h,0bdh,0bdh,099h,0c3h,0ffh ;d_0a
      FF

FAC6  0F 07 0F 7D CC CC	CC+	     db	     00fh,007h,00fh,07dh,0cch,0cch,0cch,078h ;d_0b
      78

FACE  3C 66 66 66 3C 18	7E+	     db	     03ch,066h,066h,066h,03ch,018h,07eh,018h ;d_0c
      18

FAD6  3F 33 3F 30 30 70	F0+	     db	     03fh,033h,03fh,030h,030h,070h,0f0h,0e0h ;d_0d
      E0

FADE  7F 63 7F 63 63 67	E6+	     db	     07fh,063h,07fh,063h,063h,067h,0e6h,0c0h ;d_0e
      C0

FAE6  99 5A 3C E7 E7 3C	5A+	     db	     099h,05ah,03ch,0e7h,0e7h,03ch,05ah,099h ;d_0f
      99


FAEE  80 E0 F8 FE F8 E0	80+	     db	     080h,0e0h,0f8h,0feh,0f8h,0e0h,080h,000h ;d_10
      00

FAF6  02 0E 3E FE 3E 0E	02+	     db	     002h,00eh,03eh,0feh,03eh,00eh,002h,000h ;d_11
      00

FAFE  18 3C 7E 18 18 7E	3C+	     db	     018h,03ch,07eh,018h,018h,07eh,03ch,018h ;d_12
      18

FB06  66 66 66 66 66 00	66+	     db	     066h,066h,066h,066h,066h,000h,066h,000h ;d_13
      00

FB0E  7F DB DB 7B 1B 1B	1B+	     db	     07fh,0dbh,0dbh,07bh,01bh,01bh,01bh,000h ;d_14
      00

FB16  3E 63 38 6C 6C 38	CC+	     db	     03eh,063h,038h,06ch,06ch,038h,0cch,078h ;d_15
      78

FB1E  00 00 00 00 7E 7E	7E+	     db	     000h,000h,000h,000h,07eh,07eh,07eh,000h ;d_16
      00

FB26  18 3C 7E 18 7E 3C	18+	     db	     018h,03ch,07eh,018h,07eh,03ch,018h,0ffh ;d_17
      FF

FB2E  18 3C 7E 18 18 18	18+	     db	     018h,03ch,07eh,018h,018h,018h,018h,000h ;d_18
      00

FB36  18 18 18 18 7E 3C	18+	     db	     018h,018h,018h,018h,07eh,03ch,018h,000h ;d_19
      00

FB3E  00 18 0C FE 0C 18	00+	     db	     000h,018h,00ch,0feh,00ch,018h,000h,000h ;d_1a
      00

FB46  00 30 60 FE 60 30	00+	     db	     000h,030h,060h,0feh,060h,030h,000h,000h ;d_1b
      00

FB4E  00 00 C0 C0 C0 FE	00+	     db	     000h,000h,0c0h,0c0h,0c0h,0feh,000h,000h ;d_1c
      00

FB56  00 24 66 FF 66 24	00+	     db	     000h,024h,066h,0ffh,066h,024h,000h,000h ;d_1d
      00

FB5E  00 18 3C 7E FF FF	00+	     db	     000h,018h,03ch,07eh,0ffh,0ffh,000h,000h ;d_1e
      00

FB66  00 FF FF 7E 3C 18	00+	     db	     000h,0ffh,0ffh,07eh,03ch,018h,000h,000h ;d_1f
      00


FB6E  00 00 00 00 00 00	00+	     db	     000h,000h,000h,000h,000h,000h,000h,000h ;sp d_20
      00

FB76  30 78 78 30 30 00	30+	     db	     030h,078h,078h,030h,030h,000h,030h,000h ;!	d_21
      00

FB7E  6C 6C 6C 00 00 00	00+	     db	     06ch,06ch,06ch,000h,000h,000h,000h,000h ;"d_22
      00

FB86  6C 6C FE 6C FE 6C	6C+	     db	     06ch,06ch,0feh,06ch,0feh,06ch,06ch,000h ;#	d_23
      00

FB8E  30 7C C0 78 0C F8	30+	     db	     030h,07ch,0c0h,078h,00ch,0f8h,030h,000h ;$	d_24
      00

FB96  00 C6 CC 18 30 66	C6+	     db	     000h,0c6h,0cch,018h,030h,066h,0c6h,000h ;per cent d_25
      00

FB9E  38 6C 38 76 DC CC	76+	     db	     038h,06ch,038h,076h,0dch,0cch,076h,000h ;&	d_26
      00

FBA6  60 60 C0 00 00 00	00+	     db	     060h,060h,0c0h,000h,000h,000h,000h,000h ;'	d_27
      00

FBAE  18 30 60 60 60 30	18+	     db	     018h,030h,060h,060h,060h,030h,018h,000h ;(	d_28
      00

FBB6  60 30 18 18 18 30	60+	     db	     060h,030h,018h,018h,018h,030h,060h,000h ;)	d_29
      00

FBBE  00 66 3C FF 3C 66	00+	     db	     000h,066h,03ch,0ffh,03ch,066h,000h,000h ;*	d_2a
      00

FBC6  00 30 30 FC 30 30	00+	     db	     000h,030h,030h,0fch,030h,030h,000h,000h ;+	d_2b
      00

FBCE  00 00 00 00 00 30	30+	     db	     000h,000h,000h,000h,000h,030h,030h,060h ;,	d_2c
      60

FBD6  00 00 00 FC 00 00	00+	     db	     000h,000h,000h,0fch,000h,000h,000h,000h ;-	d_2d
      00

FBDE  00 00 00 00 00 30	30+	     db	     000h,000h,000h,000h,000h,030h,030h,000h ;.	d_2e
      00

FBE6  06 0C 18 30 60 C0	80+	     db	     006h,00ch,018h,030h,060h,0c0h,080h,000h ;/	d_2f
      00


FBEE  7C C6 CE DE F6 E6	7C+	     db	     07ch,0c6h,0ceh,0deh,0f6h,0e6h,07ch,000h ;0	d_30
      00

FBF6  30 70 30 30 30 30	FC+	     db	     030h,070h,030h,030h,030h,030h,0fch,000h ;1	d_31
      00

FBFE  78 CC 0C 38 60 CC	FC+	     db	     078h,0cch,00ch,038h,060h,0cch,0fch,000h ;2	d_32
      00

FC06  78 CC 0C 38 0C CC	78+	     db	     078h,0cch,00ch,038h,00ch,0cch,078h,000h ;3	d_33
      00

FC0E  1C 3C 6C CC FE 0C	1E+	     db	     01ch,03ch,06ch,0cch,0feh,00ch,01eh,000h ;4	d_34
      00

FC16  FC C0 F8 0C 0C CC	78+	     db	     0fch,0c0h,0f8h,00ch,00ch,0cch,078h,000h ;5	d_35
      00

FC1E  38 60 C0 F8 CC CC	78+	     db	     038h,060h,0c0h,0f8h,0cch,0cch,078h,000h ;6	d_36
      00

FC26  FC CC 0C 18 30 30	30+	     db	     0fch,0cch,00ch,018h,030h,030h,030h,000h ;7	d_37
      00

FC2E  78 CC CC 78 CC CC	78+	     db	     078h,0cch,0cch,078h,0cch,0cch,078h,000h ;8	d_38
      00

FC36  78 CC CC 7C 0C 18	70+	     db	     078h,0cch,0cch,07ch,00ch,018h,070h,000h ;9	d_39
      00

FC3E  00 30 30 00 00 30	30+	     db	     000h,030h,030h,000h,000h,030h,030h,000h ;:	d_3a
      00

FC46  00 30 30 00 00 30	30+	     db	     000h,030h,030h,000h,000h,030h,030h,060h ;;	d_3b
      60

FC4E  18 30 60 C0 60 30	18+	     db	     018h,030h,060h,0c0h,060h,030h,018h,000h ;<	d_3c
      00

FC56  00 00 FC 00 00 FC	00+	     db	     000h,000h,0fch,000h,000h,0fch,000h,000h ;=	d_3d
      00

FC5E  60 30 18 0C 18 30	60+	     db	     060h,030h,018h,00ch,018h,030h,060h,000h ;>	d_3e
      00

FC66  78 CC 0C 18 30 00	30+	     db	     078h,0cch,00ch,018h,030h,000h,030h,000h ;?	d_3f
      00


FC6E  7C C6 DE DE DE C0	78+	     db	     07ch,0c6h,0deh,0deh,0deh,0c0h,078h,000h ;@	d_40
      00

FC76  30 78 CC CC FC CC	CC+	     db	     030h,078h,0cch,0cch,0fch,0cch,0cch,000h ;A	d_41
      00

FC7E  FC 66 66 7C 66 66	FC+	     db	     0fch,066h,066h,07ch,066h,066h,0fch,000h ;B	d_42
      00

FC86  3C 66 C0 C0 C0 66	3C+	     db	     03ch,066h,0c0h,0c0h,0c0h,066h,03ch,000h ;C	d_43
      00

FC8E  F8 6C 66 66 66 6C	F8+	     db	     0f8h,06ch,066h,066h,066h,06ch,0f8h,000h ;D	d_44
      00

FC96  FE 62 68 78 68 62	FE+	     db	     0feh,062h,068h,078h,068h,062h,0feh,000h ;E	d_45
      00

FC9E  FE 62 68 78 68 60	F0+	     db	     0feh,062h,068h,078h,068h,060h,0f0h,000h ;F	d_46
      00

FCA6  3C 66 C0 C0 CE 66	3E+	     db	     03ch,066h,0c0h,0c0h,0ceh,066h,03eh,000h ;G	d_47
      00

FCAE  CC CC CC FC CC CC	CC+	     db	     0cch,0cch,0cch,0fch,0cch,0cch,0cch,000h ;H	d_48
      00

FCB6  78 30 30 30 30 30	78+	     db	     078h,030h,030h,030h,030h,030h,078h,000h ;I	d_49
      00

FCBE  1E 0C 0C 0C CC CC	78+	     db	     01eh,00ch,00ch,00ch,0cch,0cch,078h,000h ;J	d_4a
      00

FCC6  E6 66 6C 78 6C 66	E6+	     db	     0e6h,066h,06ch,078h,06ch,066h,0e6h,000h ;K	d_4b
      00

FCCE  F0 60 60 60 62 66	FE+	     db	     0f0h,060h,060h,060h,062h,066h,0feh,000h ;L	d_4c
      00

FCD6  C6 EE FE FE D6 C6	C6+	     db	     0c6h,0eeh,0feh,0feh,0d6h,0c6h,0c6h,000h ;M	d_4d
      00

FCDE  C6 E6 F6 DE CE C6	C6+	     db	     0c6h,0e6h,0f6h,0deh,0ceh,0c6h,0c6h,000h ;N	d_4e
      00

FCE6  38 6C C6 C6 C6 6C	38+	     db	     038h,06ch,0c6h,0c6h,0c6h,06ch,038h,000h ;O	d_4f
      00


FCEE  FC 66 66 7C 60 60	F0+	     db	     0fch,066h,066h,07ch,060h,060h,0f0h,000h ;P	d_50
      00

FCF6  78 CC CC CC DC 78	1C+	     db	     078h,0cch,0cch,0cch,0dch,078h,01ch,000h ;Q	d_51
      00

FCFE  FC 66 66 7C 6C 66	E6+	     db	     0fch,066h,066h,07ch,06ch,066h,0e6h,000h ;R	d_52
      00

FD06  78 CC E0 70 1C CC	78+	     db	     078h,0cch,0e0h,070h,01ch,0cch,078h,000h ;S	d_53
      00

FD0E  FC B4 30 30 30 30	78+	     db	     0fch,0b4h,030h,030h,030h,030h,078h,000h ;T	d_54
      00

FD16  CC CC CC CC CC CC	FC+	     db	     0cch,0cch,0cch,0cch,0cch,0cch,0fch,000h ;U	d_55
      00

FD1E  CC CC CC CC CC 78	30+	     db	     0cch,0cch,0cch,0cch,0cch,078h,030h,000h ;V	d_56
      00

FD26  C6 C6 C6 D6 FE EE	C6+	     db	     0c6h,0c6h,0c6h,0d6h,0feh,0eeh,0c6h,000h ;W	d_57
      00

FD2E  C6 C6 6C 38 38 6C	C6+	     db	     0c6h,0c6h,06ch,038h,038h,06ch,0c6h,000h ;X	d_58
      00

FD36  CC CC CC 78 30 30	78+	     db	     0cch,0cch,0cch,078h,030h,030h,078h,000h ;Y	d_59
      00

FD3E  FE C6 8C 18 32 66	FE+	     db	     0feh,0c6h,08ch,018h,032h,066h,0feh,000h ;Z	d_5a
      00

FD46  78 60 60 60 60 60	78+	     db	     078h,060h,060h,060h,060h,060h,078h,000h ;(	d_5b
      00

FD4E  C0 60 30 18 0C 06	02+	     db	     0c0h,060h,030h,018h,00ch,006h,002h,000h ;backslash
      00

FD56  78 18 18 18 18 18	78+	     db	     078h,018h,018h,018h,018h,018h,078h,000h ;)	d_5d
      00

FD5E  10 38 6C C6 00 00	00+	     db	     010h,038h,06ch,0c6h,000h,000h,000h,000h ;cimpqumflex
      00

FD66  00 00 00 00 00 00	00+	     db	     000h,000h,000h,000h,000h,000h,000h,0ffh ;_	d_5f
      FF


FD6E  30 30 18 00 00 00	00+	     db	     030h,030h,018h,000h,000h,000h,000h,000h ;	d_60
      00

FD76  00 00 78 0C 7C CC	76+	     db	     000h,000h,078h,00ch,07ch,0cch,076h,000h ;lower case a
      00

FD7E  E0 60 60 7C 66 66	DC+	     db	     0e0h,060h,060h,07ch,066h,066h,0dch,000h ;b	d_62
      00

FD86  00 00 78 CC C0 CC	78+	     db	     000h,000h,078h,0cch,0c0h,0cch,078h,000h ;c	d_63
      00

FD8E  1C 0C 0C 7C CC CC	76+	     db	     01ch,00ch,00ch,07ch,0cch,0cch,076h,000h ;d	d_64
      00

FD96  00 00 78 CC FC C0	78+	     db	     000h,000h,078h,0cch,0fch,0c0h,078h,000h ;e	d_65
      00

FD9E  38 6C 60 F0 60 60	F0+	     db	     038h,06ch,060h,0f0h,060h,060h,0f0h,000h ;f	d_66
      00

FDA6  00 00 76 CC CC 7C	0C+	     db	     000h,000h,076h,0cch,0cch,07ch,00ch,0f8h ;g	d_67
      F8

FDAE  E0 60 6C 76 66 66	E6+	     db	     0e0h,060h,06ch,076h,066h,066h,0e6h,000h ;h	d_68
      00

FDB6  30 00 70 30 30 30	78+	     db	     030h,000h,070h,030h,030h,030h,078h,000h ;i	d_69
      00

FDBE  0C 00 0C 0C 0C CC	CC+	     db	     00ch,000h,00ch,00ch,00ch,0cch,0cch,078h ;j	d_6a
      78

FDC6  E0 60 66 6C 78 6C	E6+	     db	     0e0h,060h,066h,06ch,078h,06ch,0e6h,000h ;k	d_6b
      00

FDCE  70 30 30 30 30 30	78+	     db	     070h,030h,030h,030h,030h,030h,078h,000h ;l	d_6c
      00

FDD6  00 00 CC FE FE D6	C6+	     db	     000h,000h,0cch,0feh,0feh,0d6h,0c6h,000h ;m	d_6d
      00

FDDE  00 00 F8 CC CC CC	CC+	     db	     000h,000h,0f8h,0cch,0cch,0cch,0cch,000h ;n	d_6e
      00

FDE6  00 00 78 CC CC CC	78+	     db	     000h,000h,078h,0cch,0cch,0cch,078h,000h ;o	d_6f
      00


FDEE  00 00 DC 66 66 7C	60+	     db	     000h,000h,0dch,066h,066h,07ch,060h,0f0h ;p	d_70
      F0

FDF6  00 00 76 CC CC 7C	0C+	     db	     000h,000h,076h,0cch,0cch,07ch,00ch,01eh ;q	d_71
      1E

FDFE  00 00 DC 76 66 60	F0+	     db	     000h,000h,0dch,076h,066h,060h,0f0h,000h ;r	d_72
      00

FE06  00 00 7C C0 78 0C	F8+	     db	     000h,000h,07ch,0c0h,078h,00ch,0f8h,000h ;s	d_73
      00

FE0E  10 30 7C 30 30 34	18+	     db	     010h,030h,07ch,030h,030h,034h,018h,000h ;t	d_74
      00

FE16  00 00 CC CC CC CC	76+	     db	     000h,000h,0cch,0cch,0cch,0cch,076h,000h ;u	d_75
      00

FE1E  00 00 CC CC CC 78	30+	     db	     000h,000h,0cch,0cch,0cch,078h,030h,000h ;v	d_76
      00

FE26  00 00 C6 D6 FE FE	6C+	     db	     000h,000h,0c6h,0d6h,0feh,0feh,06ch,000h ;w	d_77
      00

FE2E  00 00 C6 6C 38 6C	C6+	     db	     000h,000h,0c6h,06ch,038h,06ch,0c6h,000h ;x	d_78
      00

FE36  00 00 CC CC CC 7C	0C+	     db	     000h,000h,0cch,0cch,0cch,07ch,00ch,0f8h ;y	d_79
      F8

FE3E  00 00 FC 98 30 64	FC+	     db	     000h,000h,0fch,098h,030h,064h,0fch,000h ;z	d_7a
      00

FE46  1C 30 30 E0 30 30	1C+	     db	     01ch,030h,030h,0e0h,030h,030h,01ch,000h ;	d_7b
      00

FE4E  18 18 18 00 18 18	18+	     db	     018h,018h,018h,000h,018h,018h,018h,000h ;	d_7c
      00

FE56  E0 30 30 1C 30 30	E0+	     db	     0e0h,030h,030h,01ch,030h,030h,0e0h,000h ;	d_7d
      00

FE5E  76 DC 00 00 00 00	00+	     db	     076h,0dch,000h,000h,000h,000h,000h,000h ;	d_7e
      00

FE66  00 10 38 6C C6 C6	FE+	     db	     000h,010h,038h,06ch,0c6h,0c6h,0feh,000h ;delta d_7f
      00


			     ;---int 1a-------------------------------
			     ;
			     ;	 Программа установки-считывания времени     +
			     суток
			     ;
			     ;	 Эта	программа обеспечивает выполнение       +
			     двух функций, код которых
			     ; задается	в регистре AH:
			     ;	 AH=0 -	считать текущее состояние часов. После+
			     выполнения коман-
			     ; ды регистры CX	и DX содержат старшую и младшую+
			     части	счетчика.
			     ;	 Если регистр AL содержит "0", то счет	идет в    +
			     течение одних
			     ; суток, при любом другом значении счет	       +
			     переходит	на следующие
			     ; сутки;
			     ;
			     ;	 AH=1 -	записать текущее	состояние часов.	       +
			     Регистры CX и DX
			     ; содержат	старшую и младшую части счетчика.
			     ;
			     ;------------------------------------------
				     assume  cs:code,ds:data
FE6E			     time_of_day     proc    far
FE6E  FB			     sti	     ; уст признак разрешения	       +
			     прерывания
FE6F  1E			     push    ds	     ; сохранить сегмент
FE70  50			     push    ax	     ; сохранить параметры
FE71  B8 0040			     mov     ax,dat
FE74  8E D8			     mov     ds,ax
FE76  58			     pop     ax
FE77  0A E4			     or	     ah,ah   ; AH=0 ?
FE79  74 07			     jz	     t2	 ; да, переход	к считыванию		       +
			     текущего состояния
FE7B  FE CC			     dec     ah	     ; AH=1 ?
FE7D  74 16			     jz	     t3	 ; да, переход	к установке текущего +
			     состояния

FE7F			     t1:     ; Возврат из программы

FE7F  FB			     sti	     ; уст признак разрешения	       +
			     прерывания
FE80  1F			     pop     ds	     ; возврат сегмента
FE81  CF			     iret	     ; возврат к программе,вызвавшей +
			     процедуру

FE82			     t2:     ; Считать текущее состояния	часов

FE82  FA			     cli	     ; сбросить	признак разрешения    +
			     прерывания
FE83  A0 0070r			     mov     al,timer_ofl  ; считать в AL флажок перехода+
			     на сле-
FE86  C6 06 0070r 00		     mov     timer_ofl,0   ; дующие сутки и	сбросить его+
			     в	памяти
FE8B  8B 0E 006Er		     mov     cx,timer_high	     ; установить старшую и  +
			     младшую
FE8F  8B 16 006Cr		     mov     dx,timer_low	     ; части счетчика
FE93  EB EA			     jmp     short t1

FE95			     t3:     ; Установить текущее состояние часов

FE95  FA			     cli	     ; сброс признака разрешения	       +
			     прерывания
FE96  89 16 006Cr		     mov     timer_low,dx	     ; установить младшую и  +
			     старшую
FE9A  89 0E 006Er		     mov     timer_high,cx	     ; части счетчика
FE9E  C6 06 0070r 00		     mov     timer_ofl,0     ; сброс флажка перехода	       +
			     через	сутки
FEA3  EB DA			     jmp     short t1	     ; возврат из программы	       +
			     отсчета времени
FEA5			     time_of_day     endp

			     ;-------int 08-------------------
			     ;
			     ;	 Программа обработки прерывания таймера     +
			     КР580ВИ53 (INT	8H) об-
			     ; рабатывает прерывания, аппаратурно	       +
			     возникающие от нулевого канала
			     ; таймера, на вход которого подаются сигналы  +
			     с	частотой 1,228 МГц,
			     ; делящиеся на 56263 для обеспечения 18,2		       +
			     прерываний в секунду.
			     ;	 При	обработке прерывания	корректируется   +
			     программный счетчик,
			     ; хранящийся в памяти по адресу 0046CH (младшая   +
			     часть	счетчика) и
			     ; адресу 0047EH (старшая часть счетчика)	и	       +
			     используемый для уста-
			     ; новки времени суток.
			     ;	 В функции программы входит коррекция	       +
			     счетчика, управляющего
			     ; двигателем НГМД. После обнуления счетчика   +
			     двигатель	выключается.
			     ;	 Вектор 1CH дает возможность пользователю     +
			     входить в заданную
			     ; программу с частотой прерывания таймера (18.2+
			     прерываний в секун-
			     ; ду). Для этого	в таблице векторов прерываний+
			     по адресу 007CH
			     ; необходимо задать адрес пользовательской   +
			     программы.
			     ;
			     ;---------------------------------------------------

FEA5			     timer_int	     proc    far
FEA5  FB			     sti	     ; уст признак разрешения	       +
			     прерывания
FEA6  1E			     push    ds
FEA7  50			     push    ax
FEA8  52			     push    dx
FEA9  B8 0040			     mov     ax,dat
FEAC  8E D8			     mov     ds,ax
FEAE  FF 06 006Cr		     inc     timer_low	  ; +1 к старшей части счетчика
FEB2  75 04			     jnz     t4
FEB4  FF 06 006Er		     inc     timer_high	  ; +1 к старшей части счетчика

FEB8			     t4:     ; Опрос счетчика = 24	часам

FEB8  83 3E 006Er 18		     cmp     timer_high,018h
FEBD  75 19			     jnz     t5
FEBF  81 3E 006Cr 00B0		     cmp     timer_low,0b0h
FEC5  75 11			     jnz     t5

			     ;	 Таймер исчерпал 24 часа

FEC7  C7 06 006Er 0000		     mov     timer_high,0   ; сброс старшей	и младшей      +
			     частей
FECD  C7 06 006Cr 0000		     mov     timer_low,0    ; счетчика и установка	       +
			     флажка пере-
FED3  C6 06 0070r 01		     mov     timer_ofl,1    ; хода счета на следующие      +
			     сутки

			     ;	 Выключение мотора НГМД, если счетчик	       +
			     управления мотором
			     ; исчерпан

FED8			     t5:
FED8  FE 0E 0040r		     dec     motor_count
FEDC  75 0B			     jnz     t6		     ; переход, если	счетчик не    +
			     установлен
FEDE  80 26 003Fr F0		     and     motor_status,0f0h
FEE3  B0 0C			     mov     al,0ch
FEE5  BA 03F2			     mov     dx,03f2h
FEE8  EE			     out     dx,al	     ; выключить мотор

FEE9			     t6:
FEE9  CD 1C			     int     1ch     ; передача	управления программе+
			     пользователя
FEEB  B0 20			     mov     al,eoi
FEED  E6 20			     out     020h,al	    ; конец прерывания
FEEF  5A			     pop     dx
FEF0  58			     pop     ax
FEF1  1F			     pop     ds
FEF2  CF			     iret		     ; возврат из прерывания
FEF3			     timer_int	     endp
			     ;---------------------------------
			     ;
			     ;	 Эти	вектора передаются в область		       +
			     прерывания 8086 во время
			     ; включения питания.
			     ;
			     ;---------------------------------
FEF3			     vector_table    label   word    ; таблица векторов		       +
			     прерываний

FEF3  FEA5r			     dw	     offset timer_int	     ; прерывание 8
FEF5  E987r			     dw	     offset kb_int	     ; прерывание 9
FEF7  FF53r			     dw	     offset dummy_return     ; прерывание А
FEF9  F98Br			     dw	     offset dummm_return     ; прерывание B
FEFB  F98Br			     dw	     offset dummm_return     ; прерывание C
FEFD  FF53r			     dw	     offset dummy_return     ; прерывание D
FEFF  EF57r			     dw	     offset disk_int	     ; прерывание E
FF01  FF53r			     dw	     offset dummy_return     ; прерывание F
FF03  F065r			     dw	     offset video_io	     ; прерывание 10H
FF05  F84Dr			     dw	     offset equipment	     ; прерывание 11H
FF07  F841r			     dw	     offset memory_size_determine    ; прерывание 12H
FF09  EC59r			     dw	     offset diskette_io	     ; прерывание 13H
FF0B  F929r			     dw	     offset rs232_io	     ; прерывание  14H
FF0D  F92Dr			     dw	     offset int15h	     ; int 15h (rc заглушка)
FF0F  E82Er			     dw	     offset keyboard_io	     ; прерывание 16H
FF11  EFD2r			     dw	     offset printer_io	     ; прерывание 17H
FF13  E06Cr			     dw	     offset start	     ; rc перывание 18h,	       +
			     поставил как в	1841 перезагрузку
FF15  E6F7r			     dw	     offset boot_strap	     ; прерывание 19H
FF17  FE6Er			     dw	     time_of_day     ; прерывание 1АH - время суток
FF19  FF53r			     dw	     dummy_return    ; прерывание 1BH	- прерывание +
			     клавиатуры
FF1B  FF53r			     dw	     dummy_return    ; прерывание 1C - прерывание  +
			     таймера
FF1D  F0A4r			     dw	     video_parms     ; прерывание 1D - параметры    +
			     видео
FF1F  EFC7r			     dw	     offset  disk_base	 ;прерывание 1EH - параметры+
			     НГМД
FF21  0000			     dw	     0		     ; 1FH - адрес	таблицы пользов. +
			     знакогенер. (не инициализируется)

				     org     0ff53h	     ;rc для	того, чтобы не	       +
			     съехало при сокращении	таблицы векторов
FF53			     dummy_return:
FF53  CF			     iret

			     ;---int 5----------------------
			     ;
			     ;	 Программа вывода на печать содержимого      +
			     буфера ЭЛИ вызывается
			     ; одновременным нажатием клавиши ПЕЧ и	       +
			     клавиши переключения регист-
			     ; ров. Позиция курсора сохраняется до	       +
			     завершения процедуры обработки
			     ; прерывания. Повторное	нажатие названных      +
			     клавиш во время обработки
			     ; прерывания игнорируется.
			     ;	 При	выполнении программы	в постоянно	       +
			     распределенной рабочей
			     ; области памяти по	адресу 0500H			       +
			     устанавливается следующая
			     ; информация:
			     ;	 0    -	содержимое буфера ЭЛИ еще	не выведено  +
			     на печать,	либо
			     ; вывод уже завершен;
			     ;	 1    -	в процессе вывода содержимого	буфера   +
			     ЭЛИ на печать;
			     ;	 255  -	при печати обнаружена ошибка.
			     ;-----------------------------------------------------

				     assume  cs:code,ds:xxdata

FF54			     print_screen    proc    far
FF54  FB			     sti		  ; уст признак разрешения	       +
			     прерывания
FF55  1E			     push    ds
FF56  50			     push    ax
FF57  53			     push    bx
FF58  51			     push    cx	  ; будет использоваться заглавная +
			     буква	для курсора
FF59  52			     push    dx	  ; будет содержать текущее	       +
			     положение	курсора
FF5A  B8 0050			     mov     ax,xxdat	     ; адрес 50
FF5D  8E D8			     mov     ds,ax
FF5F  80 3E 0000r 01		     cmp     status_byte,1   ; печать готова ?
FF64  74 5F			     jz	     exit	     ; переход, если	печать	       +
			     готова
FF66  C6 06 0000r 01		     mov     status_byte,1   ;
FF6B  B4 0F			     mov     ah,15	     ; требуется текущий режим    +
			     экрана
FF6D  CD 10			     int     10h	     ; AL - режим,	AH - число		       +
			     строк/колонок
							     ; BH - страница,выведенная на +
			     экран


			     ;*************************************8
			     ;
			     ;	 В этом месте:
			     ;			 AX - колонка, строка,
			     ;			 BH - номер отображаемой страницы.
			     ;
			     ;	 Стек содержит DS, AX, BX, CX, DX.
			     ;
			     ;			 AL - режим
			     ;
			     ;**************************************

FF6F  8A CC			     mov     cl,ah
FF71  B5 19			     mov     ch,25
FF73  E8 0055			     call    crlf
FF76  51			     push    cx
FF77  B4 03			     mov     ah,3
FF79  CD 10			     int     10h
FF7B  59			     pop     cx
FF7C  52			     push    dx
FF7D  33 D2			     xor     dx,dx

			     ;**************************************
			     ;
			     ;	  Считывание знака, находящегося в текущей  +
			     позиции курсора
			     ; и вывод на печать
			     ;
			     ;**************************************

FF7F  B4 02		     pri10:  mov     ah,2
FF81  CD 10			     int     10h
FF83  B4 08			     mov     ah,8
FF85  CD 10			     int     10h
FF87  0A C0			     or	     al,al
FF89  75 02			     jnz     pri15
FF8B  B0 20			     mov     al,' '
FF8D			     pri15:
FF8D  52			     push    dx
FF8E  33 D2			     xor     dx,dx
FF90  32 E4			     xor     ah,ah
FF92  CD 17			     int     17h
FF94  5A			     pop     dx
FF95  F6 C4 25			     test    ah,25h
FF98  75 21			     jnz     err10
FF9A  FE C2			     inc     dl
FF9C  3A CA			     cmp     cl,dl
FF9E  75 DF			     jnz     pri10
FFA0  32 D2			     xor     dl,dl
FFA2  8A E2			     mov     ah,dl
FFA4  52			     push    dx
FFA5  E8 0023			     call    crlf
FFA8  5A			     pop     dx
FFA9  FE C6			     inc     dh
FFAB  3A EE			     cmp     ch,dh
FFAD  75 D0			     jnz     pri10
FFAF  5A			     pop     dx
FFB0  B4 02			     mov     ah,2
FFB2  CD 10			     int     10h
FFB4  C6 06 0000r 00		     mov     status_byte,0
FFB9  EB 0A			     jmp     short exit
FFBB  5A		     err10:  pop     dx
FFBC  B4 02			     mov     ah,2
FFBE  CD 10			     int     10h
FFC0  C6 06 0000r FF		     mov     status_byte,0ffh

FFC5  5A		     exit:   pop     dx
FFC6  59			     pop     cx
FFC7  5B			     pop     bx
FFC8  58			     pop     ax
FFC9  1F			     pop     ds
FFCA  CF			     iret
FFCB			     print_screen    endp

			     ;	 Возврат	каретки

FFCB			     crlf    proc    near
FFCB  33 D2			     xor     dx,dx
FFCD  32 E4			     xor     ah,ah
FFCF  B0 0A			     mov     al,12q
FFD1  CD 17			     int     17h
FFD3  32 E4			     xor     ah,ah
FFD5  B0 0D			     mov     al,15q
FFD7  CD 17			     int     17h
FFD9  C3			     ret
FFDA			     crlf    endp

FFDA  16*(00)				     db	22 dup(0)

			     ;--------------------------------------
			     ;
			     ;	 Включение питания
			     ;
			     ;--------------------------------------

			     ;vector segment at	0ffffh

			     ;	 Переход	по включению	питания

FFF0  EA		     POST:	     db	     0eah	     ; db    0eah,5bh,0e0h,00h,0f0h  ; jmp reset
FFF1  E06Cr F000			     dw	     offset reset, cod	     ; ###Gleb###

FFF5  30 34 2F 32 34 2F	38+		     db	'04/24/81'
      31

FFFD  00 00				     db	   0, 0

FFFF  00				     db	   0 ;
			     ;vector ends






0000			     code    ends
				     end     POST

Symbol Name			  Type	 Value

??DATE				  Text	 "11-17-21"
??FILENAME			  Text	 "1840v5  "
??TIME				  Text	 "18:28:28"
??VERSION			  Number 0500
@CPU				  Text	 0101H
@CURSEG				  Text	 CODE
@FILENAME			  Text	 1840V5
@WORDSIZE			  Text	 2
A5700051COPR_IB			  Byte	 CODE:E000
ACTIVE_PAGE			  Byte	 DATA:0062
ACT_DISP_PAGE			  Near16 CODE:F230
ADDR_6845			  Word	 DATA:0063
ALT_INPUT			  Byte	 DATA:0019
ALT_KEY				  Number 0038
ALT_SHIFT			  Number 0008
ASCII_TBL			  Byte	 CODE:E417
B1				  Near16 CODE:EFF5
B2				  Near16 CODE:EFFB
B3				  Near16 CODE:F002
B4				  Near16 CODE:F017
B5				  Near16 CODE:F01F
B6				  Near16 CODE:F020
B7				  Near16 CODE:F02B
B8				  Near16 CODE:F033
B9				  Near16 CODE:F03D
BAD_ADDR_MARK			  Number 0002
BAD_CMD				  Number 0001
BAD_CRC				  Number 0010
BAD_DMA				  Number 0008
BAD_NEC				  Number 0020
BAD_SEEK			  Number 0040
BCT				  Near16 CODE:F859
BCT1				  Near16 CODE:F875
BCT2				  Near16 CODE:F877
BCT3				  Near16 CODE:F86C
BEEP				  Near16 CODE:E5A9
BIOS_BREAK			  Byte	 DATA:0071
BOOT_LOCN			  Far16	 ABS0:7C00
BOOT_STRAP			  Near16 CODE:E6F7
BOOT_VEC			  Dword	 ABS0:0064
BUFFER_END			  Word	 DATA:0082
BUFFER_HEAD			  Word	 DATA:001A
BUFFER_START			  Word	 DATA:0080
BUFFER_TAIL			  Word	 DATA:001C
C1				  Word	 CODE:E016
C10				  Near16 CODE:E0C2
C11				  Near16 CODE:E0EA
C12				  Near16 CODE:E0FC
C13				  Near16 CODE:E10D
C14				  Near16 CODE:E113
C15				  Near16 CODE:E121
C16				  Near16 CODE:E12D
C17				  Near16 CODE:E137
C18				  Near16 CODE:E147
C19				  Near16 CODE:E193
C21				  Near16 CODE:E1A3
C22				  Near16 CODE:E1E1
C23				  Near16 CODE:E1ED
C25				  Near16 CODE:E1FB
C2A				  Near16 CODE:E02A
C2B				  Near16 CODE:E02D
C3				  Near16 CODE:E035
C3A				  Near16 CODE:E04D
C4				  Near16 CODE:E064
C7X				  Near16 CODE:E06B
C8				  Near16 CODE:E09F
C9				  Near16 CODE:E0BC
CA3				  Near16 CODE:E1F6
CAPS_KEY			  Number 0056
CAPS_SHIFT			  Number 0040
CAPS_STATE			  Number 0040
CAW				  Word	 CODE:E018
CHK_STAT_2			  Near16 CODE:EF0F
CMD_BLOCK			  Byte	 DATA:0042
CMD_PORT			  Number 0063
COD				  Number F000
CONTROL_BYTE			  Byte	 DATA:0076
CRLF				  Near16 CODE:FFCB
CRT_CHAR_GEN			  Byte	 CODE:FA6E
CRT_COLS			  Word	 DATA:004A
CRT_LEN				  Word	 DATA:004C
CRT_MODE			  Byte	 DATA:0049
CRT_MODE_SET			  Byte	 DATA:0065
CRT_PALLETTE			  Byte	 DATA:0066
CRT_START			  Word	 DATA:004E
CSI				  Word	 ABS0:04D0
CTL_KEY				  Number 001D
CTL_SHIFT			  Number 0004
CURSOR_MODE			  Word	 DATA:0060
CURSOR_POSN			  Word	 DATA:0050
D1				  Byte	 CODE:E205
D10				  Near16 CODE:E294
D11				  Near16 CODE:E29E
D12				  Near16 CODE:E2BA
D13				  Near16 CODE:E2C4
D14				  Near16 CODE:E2CE
D1L				  Number 000E
D2				  Byte	 CODE:E213
D2L				  Number 000E
D3				  Near16 CODE:E240
D4				  Near16 CODE:E25D
D5				  Near16 CODE:E25F
D6				  Near16 CODE:E265
D7				  Near16 CODE:E26D
D8				  Near16 CODE:E27F
D9				  Near16 CODE:E288
DAL				  Near16 CODE:E4E9
DAT				  Number 0040
DECIMAL_LOOP			  Near16 CODE:E653
DEL_KEY				  Number 0053
DISKETTE_IO			  Far16	 CODE:EC59
DISKETTE_PARM			  Dword	 ABS0:0078
DISKETTE_STATUS			  Byte	 DATA:0041
DISKW_STATUS			  Byte	 DATA:0074
DISK_BASE			  Byte	 CODE:EFC7
DISK_FORMAT			  Near16 CODE:ED1B
DISK_INT			  Far16	 CODE:EF57
DISK_POINTER			  Dword	 ABS0:0078
DISK_READ			  Near16 CODE:ED0E
DISK_RESET			  Near16 CODE:ECB9
DISK_STATUS			  Near16 CODE:ED0A
DISK_VECTOR			  Dword	 ABS0:0100
DISK_VERF			  Near16 CODE:ED17
DISK_WRITE			  Near16 CODE:ED41
DMA				  Number 0000
DMA08				  Number 0008
DMA_BOUNDARY			  Number 0009
DMA_SETUP			  Near16 CODE:EEC9
DUMMM_RETURN			  Near16 CODE:F98B
DUMMY_RETURN			  Near16 CODE:FF53
E1				  Byte	 CODE:E2D0
E10				  Near16 CODE:E362
E11				  Near16 CODE:E380
E12				  Near16 CODE:E382
E13				  Near16 CODE:E384
E14				  Near16 CODE:E38D
E15				  Near16 CODE:E38F
E16				  Near16 CODE:E398
E17				  Near16 CODE:E3A0
E18				  Near16 CODE:E3A6
E19				  Near16 CODE:E3AB
E190				  Near16 CODE:E613
E1A				  Near16 CODE:E2E0
E1L				  Number 0004
E20A				  Near16 CODE:E622
E20B				  Near16 CODE:E627
E20C				  Near16 CODE:E637
E21A				  Near16 CODE:E689
E22				  Near16 CODE:E3EB
E3				  Near16 CODE:E2FA
E300				  Byte	 CODE:E69F
E3A				  Near16 CODE:E305
E7				  Near16 CODE:E313
E8				  Near16 CODE:E323
E9				  Near16 CODE:E345
EOI				  Number 0020
EQUIPMENT			  Far16	 CODE:F84D
EQUIP_FLAG			  Word	 DATA:0010
EQ_FL				  Byte	 ABS0:0410
ERR01				  Near16 CODE:E0C0
ERR10				  Near16 CODE:FFBB
ERROR_BEEP			  Near16 CODE:E768
ERR_BEEP			  Near16 CODE:E580
ERR_WAIT			  Near16 CODE:E4E0
EVN				  Near16 CODE:E3DF
EXIT				  Near16 CODE:FFC5
EXT_PTR				  Dword	 ABS0:007C
F1				  Byte	 CODE:E40B
F10				  Near16 CODE:E490
F11				  Near16 CODE:E4A5
F12				  Near16 CODE:E4A7
F13				  Near16 CODE:E4BD
F14				  Near16 CODE:E4C6
F15				  Near16 CODE:E4CC
F16				  Near16 CODE:E502
F17				  Near16 CODE:E516
F18				  Near16 CODE:E542
F19				  Near16 CODE:E559
F19A				  Near16 CODE:F96D
F19B				  Near16 CODE:E55C
F1L				  Number 0004
F2				  Byte	 CODE:E40F
F20				  Near16 CODE:E570
F20A				  Near16 CODE:F980
F20B				  Near16 CODE:E574
F21				  Near16 CODE:E57A
F23				  Near16 CODE:E57D
F2L				  Number 0003
F3				  Byte	 CODE:E412
F39				  Byte	 CODE:E6A6
F3L				  Number 0003
F4				  Word	 CODE:E415
F4E				  Word	 CODE:E417
F5				  Near16 CODE:E444
F6				  Near16 CODE:E45C
F7				  Near16 CODE:E465
F7A				  Near16 CODE:E475
FIND_POSITION			  Near16 CODE:F3A7
G1				  Near16 CODE:E58C
G10				  Near16 CODE:E5EC
G12				  Near16 CODE:E5FC
G2				  Near16 CODE:E591
G3				  Near16 CODE:E597
G4				  Near16 CODE:E59C
G5				  Near16 CODE:E5A2
G6				  Near16 CODE:E5A4
G7				  Near16 CODE:E5C0
G8				  Near16 CODE:E5D2
G9				  Near16 CODE:E5E5
GET_PARM			  Near16 CODE:EE51
GRAPHICS_DOWN			  Near16 CODE:F4F7
GRAPHICS_READ			  Near16 CODE:F633
GRAPHICS_UP			  Near16 CODE:F49E
GRAPHICS_WRITE			  Near16 CODE:F581
GRAPH_POSN			  Near16 CODE:F70F
H1				  Near16 CODE:E707
H2				  Near16 CODE:E722
H3				  Near16 CODE:E727
H4				  Near16 CODE:E72A
HDISK_INT			  Dword	 ABS0:0034
HD_ERROR			  Byte	 DATA:0042
HF_NUM				  Byte	 DATA:0075
HF_TBL_VEC			  Dword	 ABS0:0104
HOLD_STATE			  Number 0008
IDNPOL				  Word	 DATA:0090
INF_KEY				  Number 0059
INS_KEY				  Number 0052
INS_SHIFT			  Number 0080
INS_STATE			  Number 0080
INT15H				  Near16 CODE:F92D
INT5_PTR			  Word	 ABS0:0014
INTA00				  Number 0020
INTA01				  Number 0021
INT_ADDR			  Word	 ABS0:0020
INT_FLAG			  Number 0080
INT_PTR				  Dword	 ABS0:0020
INV_KEY_L			  Number 0058
INV_KEY_R			  Number 005A
INV_SHIFT			  Number 0004
IO_RAM_SIZE			  Word	 DATA:0015
IO_ROM_INIT			  Word	 DATA:0067
IO_ROM_SEG			  Word	 DATA:0069
J1				  Near16 CODE:EC87
J10				  Near16 CODE:ED29
J11				  Near16 CODE:ED57
J12				  Near16 CODE:EDA0
J13				  Near16 CODE:EDA4
J14				  Near16 CODE:EDAA
J15				  Near16 CODE:EDD4
J16				  Near16 CODE:EDF9
J17				  Near16 CODE:EE00
J18				  Near16 CODE:EE3D
J19				  Near16 CODE:EE3F
J2				  Near16 CODE:ECAB
J20				  Near16 CODE:EE46
J21				  Near16 CODE:EE47
J22				  Near16 CODE:EE4B
J23				  Near16 CODE:E736
J24				  Near16 CODE:E73D
J25				  Near16 CODE:E747
J26				  Near16 CODE:E749
J27				  Near16 CODE:E752
J28				  Near16 CODE:EE95
J29				  Near16 CODE:EEB9
J3				  Near16 CODE:ECB3
J30				  Near16 CODE:EEC0
J300				  Near16 CODE:EEAB
J31				  Near16 CODE:EEC6
J32				  Near16 CODE:EEC8
J33				  Near16 CODE:EEDE
J34				  Near16 CODE:EF28
J35				  Near16 CODE:EF29
J36				  Near16 CODE:EF37
J37				  Near16 CODE:EF4A
J38				  Near16 CODE:EF74
J39				  Near16 CODE:EF79
J4				  Near16 CODE:ECD2
J40				  Near16 CODE:EF85
J40A				  Near16 CODE:EF8A
J41				  Near16 CODE:EF8F
J42				  Near16 CODE:EF96
J43				  Near16 CODE:EF9E
J44				  Near16 CODE:EFAC
J45				  Near16 CODE:EFC4
J5				  Near16 CODE:ECD4
J6				  Near16 CODE:ECD6
J7				  Near16 CODE:ECF8
J8				  Near16 CODE:ED09
J9				  Near16 CODE:ED10
K1				  Near16 CODE:E845
K10				  Byte	 CODE:E8DC
K11				  Byte	 CODE:E916
K12				  Byte	 CODE:E950
K13				  Byte	 CODE:E95A
K14				  Byte	 CODE:E964
K15				  Byte	 CODE:E971
K16				  Near16 CODE:E9AF
K17				  Near16 CODE:E9D9
K18				  Near16 CODE:EA4B
K19				  Near16 CODE:EA60
K2				  Near16 CODE:E85E
K20				  Near16 CODE:EA6E
K21				  Near16 CODE:EA74
K22				  Near16 CODE:EA7B
K23				  Near16 CODE:EA9F
K24				  Near16 CODE:EAC3
K25				  Near16 CODE:EACC
K26				  Near16 CODE:EAEB
K26A				  Near16 CODE:EA48
K27				  Near16 CODE:EAF0
K28				  Near16 CODE:EAFF
K29				  Near16 CODE:EB09
K3				  Near16 CODE:E86F
K30				  Byte	 CODE:F905
K300				  Near16 CODE:EA1D
K301				  Near16 CODE:EA22
K302				  Near16 CODE:EA37
K303				  Near16 CODE:EA93
K304				  Near16 CODE:EAAF
K307				  Near16 CODE:EAF9
K31				  Near16 CODE:EB1F
K32				  Near16 CODE:EB28
K33				  Near16 CODE:EB44
K34				  Near16 CODE:EB55
K35				  Near16 CODE:EB65
K36				  Near16 CODE:EB69
K37				  Near16 CODE:EB6B
K38				  Near16 CODE:EB75
K39				  Near16 CODE:EB98
K4				  Near16 CODE:E75B
K40				  Near16 CODE:EBB3
K400				  Near16 CODE:EA06
K401				  Near16 CODE:EA0E
K406				  Near16 CODE:E9C2
K406B				  Near16 CODE:EADB
K407				  Near16 CODE:E9D6
K41				  Near16 CODE:EBBD
K42				  Near16 CODE:EBC7
K43				  Near16 CODE:EBD1
K44				  Near16 CODE:EBD7
K45				  Near16 CODE:EBEF
K46				  Near16 CODE:EBFC
K47				  Near16 CODE:EC06
K48				  Near16 CODE:EC19
K49				  Near16 CODE:EC27
K5				  Near16 CODE:E767
K50				  Near16 CODE:EC37
K51				  Near16 CODE:EC3D
K52				  Near16 CODE:EC43
K53				  Near16 CODE:EC4A
K54				  Near16 CODE:E78D
K54A				  Near16 CODE:EBEC
K55				  Near16 CODE:E796
K56				  Near16 CODE:E7A0
K57				  Near16 CODE:E7A4
K58				  Near16 CODE:E7AD
K59				  Near16 CODE:E7D2
K6				  Byte	 CODE:E875
K60				  Near16 CODE:E7D5
K61				  Near16 CODE:E7DF
K62				  Near16 CODE:E7FC
K63				  Near16 CODE:E802
K64				  Near16 CODE:E804
K65				  Near16 CODE:E771
K66				  Near16 CODE:E778
K67				  Near16 CODE:E781
K6L				  Number 000C
K7				  Byte	 CODE:E881
K8				  Byte	 CODE:E889
K80				  Near16 CODE:F94B
K81				  Near16 CODE:F948
K88				  Near16 CODE:E7BE
K89				  Near16 CODE:F933
K89A				  Near16 CODE:F961
K89B				  Near16 CODE:F95C
K9				  Byte	 CODE:E8C3
K98				  Near16 CODE:EC13
K99				  Near16 CODE:E7F7
KBDINT				  Number 0002
KBD_IN				  Number 0060
KBD_RESET			  Near16 CODE:E5CB
KB_BUFFER			  Word	 DATA:001E
KB_BUFFER_END			  Word	 DATA:003E
KB_CTL				  Number 0061
KB_DAT				  Number 0060
KB_FLAG				  Byte	 DATA:0017
KB_FLAG_1			  Byte	 DATA:0018
KB_INT				  Far16	 CODE:E987
KB_OK				  Near16 CODE:E66C
KEYBOARD_IO			  Far16	 CODE:E82E
LAST_VAL			  Byte	 DATA:006B
LAT				  Number 0002
LAT_KEY				  Number 0057
LAT_SHIFT			  Number 0001
LEFT_KEY			  Number 0054
LEFT_SHIFT			  Number 0002
M1				  Word	 CODE:F045
M10				  Near16 CODE:F144
M11				  Near16 CODE:F16F
M12				  Near16 CODE:F172
M13				  Near16 CODE:F175
M14				  Near16 CODE:F1C3
M15				  Near16 CODE:F1CA
M16				  Near16 CODE:F1DA
M17				  Near16 CODE:F207
M18				  Near16 CODE:F209
M19				  Near16 CODE:F269
M1L				  Number 0020
M2				  Near16 CODE:F080
M20				  Near16 CODE:F270
M3				  Near16 CODE:F098
M4				  Number 0010
M5				  Word	 CODE:F0E4
M6				  Byte	 CODE:F0EC
M7				  Byte	 CODE:F0F4
M8				  Near16 CODE:F10D
M9				  Near16 CODE:F141
MAX_PERIOD			  Number 0540
MEMORY_SIZE			  Word	 DATA:0013
MEMORY_SIZE_DETERMINE		  Far16	 CODE:F841
MEM_SIZ				  Word	 ABS0:0413
MFG_TST				  Byte	 DATA:0012
MIN_PERIOD			  Number 0410
MOTOR_COUNT			  Byte	 DATA:0040
MOTOR_STATUS			  Byte	 DATA:003F
MOTOR_WAIT			  Number 0025
N1				  Near16 CODE:F2AB
N10				  Near16 CODE:F331
N11				  Near16 CODE:F33A
N12				  Near16 CODE:F351
N13				  Near16 CODE:F35F
N14				  Near16 CODE:F36A
N15				  Near16 CODE:F36D
N16				  Near16 CODE:F379
N2				  Near16 CODE:F2B9
N3				  Near16 CODE:F2C4
N4				  Near16 CODE:F2C7
N5				  Near16 CODE:F2D0
N6				  Near16 CODE:F2E3
N7				  Near16 CODE:F2E6
N8				  Near16 CODE:F2FD
N9				  Near16 CODE:F30A
NEC_OP				  Near16 CODE:EE64
NEC_OUTPUT			  Near16 CODE:E72F
NEC_STATUS			  Byte	 DATA:0042
NMI_INT				  Near16 CODE:E2AB
NMI_PTR				  Word	 ABS0:0008
NUM_KEY				  Number 0045
NUM_SHIFT			  Number 0020
NUM_STATE			  Number 0020
NUM_TRANS			  Near16 CODE:EFB0
ORG_VECTOR			  Dword	 ABS0:004C
OSH				  Near16 CODE:E3CE
P1				  Near16 CODE:F38A
P10				  Near16 CODE:F403
P11				  Near16 CODE:F40C
P12				  Near16 CODE:F413
P13				  Near16 CODE:F419
P2				  Near16 CODE:F398
P3				  Near16 CODE:F39E
P4				  Near16 CODE:F3B7
P5				  Near16 CODE:F3BD
P6				  Near16 CODE:F3D0
P7				  Near16 CODE:F3DB
P8				  Near16 CODE:F3E2
P9				  Near16 CODE:F3E8
PARM_PTR			  Dword	 ABS0:0074
PORT_A				  Number 0060
PORT_B				  Number 0061
PORT_C				  Number 0062
PORT_OFF			  Byte	 DATA:0077
POSITION			  Near16 CODE:F28B
POST				  Near16 CODE:FFF0
PRI10				  Near16 CODE:FF7F
PRI15				  Near16 CODE:FF8D
PRINTER_BASE			  Word	 DATA:0008
PRINTER_IO			  Far16	 CODE:EFD2
PRINT_SCREEN			  Far16	 CODE:FF54
PRN_HEX_BYTE			  Near16 CODE:E3ED
PRT_DEC_LOOP			  Near16 CODE:E660
PRT_HEX				  Near16 CODE:E698
PRT_SIZ				  Near16 CODE:E64C
P_MSG				  Near16 CODE:E5F5
R1				  Near16 CODE:F450
R10				  Near16 CODE:F4E5
R11				  Near16 CODE:F4F3
R12				  Near16 CODE:F517
R13				  Near16 CODE:F533
R14				  Near16 CODE:F542
R15				  Near16 CODE:F544
R16				  Near16 CODE:F553
R17				  Near16 CODE:F557
R18				  Near16 CODE:F570
R2				  Near16 CODE:F457
R3				  Near16 CODE:F45B
R4				  Near16 CODE:F46E
R5				  Near16 CODE:F486
R6				  Near16 CODE:F490
R7				  Near16 CODE:F4BC
R8				  Near16 CODE:F4D4
R9				  Near16 CODE:F4E3
READ_AC_CURRENT			  Near16 CODE:F37D
READ_CURSOR			  Near16 CODE:F21A
READ_DOT			  Near16 CODE:F427
READ_LPEN			  Near16 CODE:F7A9
RECORD_NOT_FND			  Number 0004
REGEN				  Byte	 VIDEO_RAM:0000
REGENW				  Word	 VIDEO_RAM:0000
RESET				  Near16 CODE:E06C
RESET_FLAG			  Word	 DATA:0072
RESULTS				  Near16 CODE:EF6B
RES_FL				  Word	 ABS0:0472
RIGHT_KEY			  Number 0055
RIGHT_SHIFT			  Number 0001
ROS				  Near16 CODE:E0EC
RS232_BASE			  Word	 DATA:0000
RS232_IO			  Near16 CODE:F929
RUST				  Byte	 CODE:F8CB
RUST2				  Byte	 CODE:E6BD
RUS_KEY				  Number 005B
RW_OPN				  Near16 CODE:ED4D
S1				  Near16 CODE:F594
S10				  Near16 CODE:F5FC
S11				  Near16 CODE:F618
S12				  Near16 CODE:F648
S13				  Near16 CODE:F660
S14				  Near16 CODE:F664
S15				  Near16 CODE:F676
S16				  Near16 CODE:F683
S17				  Near16 CODE:F688
S18				  Near16 CODE:F6B1
S19				  Near16 CODE:F6B7
S2				  Near16 CODE:F5A3
S20				  Near16 CODE:F6C0
S21				  Near16 CODE:F6CC
S22				  Near16 CODE:F6D5
S23				  Near16 CODE:F6EF
S24				  Near16 CODE:F6F9
S25				  Near16 CODE:F6FF
S26				  Near16 CODE:F70C
S3				  Near16 CODE:F5B3
S4				  Near16 CODE:F5B7
S5				  Near16 CODE:F5BF
S6				  Near16 CODE:F5D3
S7				  Near16 CODE:F5DF
S8				  Near16 CODE:F5E6
S9				  Near16 CODE:F5EA
SCROLL_DOWN			  Near16 CODE:F341
SCROLL_KEY			  Number 0046
SCROLL_POSITION			  Near16 CODE:F2EA
SCROLL_SHIFT			  Number 0010
SCROLL_STATE			  Number 0010
SCROLL_UP			  Near16 CODE:F29C
SEEK				  Near16 CODE:EE67
SEEK_STATUS			  Byte	 DATA:003E
SET_COLOR			  Near16 CODE:F254
SET_CPOS			  Near16 CODE:F1F0
SET_CTYPE			  Near16 CODE:F1CF
SET_MODE			  Near16 CODE:F0FC
SKIP_SIZE_DET			  Near16 CODE:E3C5
SP_TEST				  Near16 CODE:E5D8
STA				  Number 0030
START				  Near16 CODE:E06C
STATUS_BYTE			  Byte	 XXDATA:0000
STAT_OFFSET			  Byte	 DATA:007C
STGTST				  Near16 CODE:E01A
STGTST_CNT			  Near16 CODE:E01D
STG_LOC0			  Byte	 ABS0:0000
T1				  Near16 CODE:FE7F
T2				  Near16 CODE:FE82
T3				  Near16 CODE:FE95
T4				  Near16 CODE:FEB8
T5				  Near16 CODE:FED8
T6				  Near16 CODE:FEE9
TABL				  Word	 DATA:00E0
TABL1				  Word	 ABS0:04E0
TIMER				  Number 0040
TIMERO				  Number 0040
TIMER_HIGH			  Word	 DATA:006E
TIMER_INT			  Far16	 CODE:FEA5
TIMER_LOW			  Word	 DATA:006C
TIMER_OFL			  Byte	 DATA:0070
TIME_OF_DAY			  Far16	 CODE:FE6E
TIME_OUT			  Number 0080
TIM_CTL				  Number 0043
TMINT				  Number 0001
TMP_TOS				  Word	 DATA:3FF0
TOS				  Word	 STAC:0100
TST12				  Near16 CODE:E427
TST14				  Near16 CODE:E47D
TST6				  Near16 CODE:E221
TST8				  Near16 CODE:E2D4
U1				  Near16 CODE:F753
U10				  Near16 CODE:F793
U11				  Near16 CODE:F79A
U2				  Near16 CODE:F766
U3				  Near16 CODE:F76C
U4				  Near16 CODE:F77A
U5				  Near16 CODE:F77C
U6				  Near16 CODE:F780
U7				  Near16 CODE:F782
U8				  Near16 CODE:F786
U9				  Near16 CODE:F78F
V1				  Byte	 CODE:F7A1
V2				  Near16 CODE:F7E8
V3				  Near16 CODE:F80F
V4				  Near16 CODE:F81B
V5				  Near16 CODE:F82D
V6				  Near16 CODE:F82F
V7				  Near16 CODE:F839
VECTOR_TABLE			  Word	 CODE:FEF3
VIDEO_INT			  Word	 ABS0:0040
VIDEO_IO			  Near16 CODE:F065
VIDEO_PARMS			  Byte	 CODE:F0A4
VIDEO_RA			  Number B800
VIDEO_RETURN			  Near16 CODE:F1C7
VIDEO_STATE			  Near16 CODE:F27A
WAIT_INT			  Near16 CODE:EF30
WRITE_AC_CURRENT		  Near16 CODE:F3C3
WRITE_C_CURRENT			  Near16 CODE:F3F6
WRITE_DOT			  Near16 CODE:F438
WRITE_PROTECT			  Number 0003
WRITE_TTY			  Near16 CODE:F722
WRITE_TTY2			  Near16 CODE:F966
X1				  Near16 CODE:ED8B
X2				  Near16 CODE:ED87
XLAT_PRINT_COD			  Near16 CODE:E3FC
XXDAT				  Number 0050
ZB				  Byte	 ABS0:0000
ZW				  Word	 ABS0:0000

Groups & Segments		  Bit Size Align  Combine Class

ABS0				  16  7C00 Para	  none
CODE				  16  00010000 Para   none
DATA				  16  3FF0 Para	  none
STAC				  16  0100 Para	  Stack
VIDEO_RAM			  16  4000 Para	  none
XXDATA				  16  0001 Para	  none

